this.android=this.android||{},this.android.constraint=this.android.constraint||{},this.android.constraint.guideline=function(){"use strict";var t=squared.base.LayoutUI;const{CONTAINER_NODE:n}=android.lib.constant,{formatPX:a}=squared.lib.css,{hypotenuse:e}=squared.lib.math,{withinRange:i}=squared.lib.util;class Guideline extends squared.base.ExtensionUI{constructor(){super(...arguments),this.options={circlePosition:!0}}is(t){return this.included(t.element)}condition(t){return!t.isEmpty()}processNode(a,e){return{output:this.application.renderNode(new t(e,a,n.CONSTRAINT,16))}}postBaseLayout(t){const n=this.controller,o=this.options.circlePosition,{left:r,top:s}=t.box;let c;if(t.each((t=>{const n=t.linear;i(n.left,r)&&t.anchorParent("horizontal",0),i(n.top,s)&&t.anchorParent("vertical",0),o&&(t.anchored?c=t:c?t.constraint.vertical&&!c.constraint.vertical&&(c=t):(t.constraint.vertical||t.constraint.horizontal)&&(c=t)),t.positioned=!0})),o){c||(c=t.item(0)),c.anchored||n.addGuideline({target:c,parent:t});const{x:i,y:o}=c.center;t.each((t=>{if(!t.anchored){const{x:n,y:r}=t.center,s=Math.abs(n-i),d=Math.abs(r-o),l=Math.round(e(s,d));let u=Math.round(Math.atan(Math.min(s,d)/Math.max(s,d))*(180/Math.PI));r>o?n>i?s>d?u+=90:u=180-u:s>d?u=270-u:u+=180:r<o?i>n?s>d?u+=270:u=360-u:s>d&&(u=90-u):u=n>i?90:270,t.app("layout_constraintCircle",c.documentId),t.app("layout_constraintCircleRadius",a(l)),t.app("layout_constraintCircleAngle",u.toString())}}))}else t.each((a=>{a.anchored||n.addGuideline({target:a,parent:t})}))}}const o=new Guideline("android.constraint.guideline",2);return squared&&squared.add(o),o}();
