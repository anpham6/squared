this.squared=this.squared||{},this.squared.svg=function(t){"use strict";var e=squared.lib.base.Pattern;const{CSS_PROPERTIES:s}=squared.lib.internal,{STRING:i,TRANSFORM:n}=squared.lib.regex,{asPercent:a,calculateStyle:r,calculateVar:o,calculateVarAsString:l,convertAngle:c,getFontSize:h,getStyle:u,hasEm:f,isLength:d,parseUnit:g}=squared.lib.css,{getNamedItem:p}=squared.lib.dom,{convertRadian:m,hypotenuse:y,truncateExponential:v,truncateFraction:S,truncateTrailingZero:b}=squared.lib.math,{getElementCache:k}=squared.lib.session,{convertCamelCase:T,lastItemOf:A,resolvePath:x,splitPair:E,startsWith:R}=squared.lib.util,w=new e(/(\w+)\([^)]+\)/g),V=new e(/rotate\((-?[\d.]+)\s*(?:,?\s+(-?[\d.]+))?\s*(?:,?\s+(-?[\d.]+))?\)/g),_=new RegExp(i.DECIMAL_EXPONENT,"g"),P=new Map;function N(t,e,s,i,n){if(d(i))e[s]=g(i,O(t,i));else{const t=a(i);isNaN(t)||(e[s]=t*n)}}function M(t,e){var s;const i=t.dataset.baseValue;if(i)try{const t=JSON.parse(i);if(t)return(null===(s=t[e])||void 0===s?void 0:s.toString().trim())||""}catch(t){}return""}const B=(t,e)=>{var s;return M(t,e)||t.style[e=T(e)]||(null===(s=k(t,"styleMap"))||void 0===s?void 0:s[e])},C=(t,e)=>t.tagName.toLowerCase()===e,G=(t,e)=>e?Math.min(t.width,t.height):y(t.width,t.height),O=(t,e)=>f(e)?{fontSize:h(t)}:void 0;Object.assign(s,{alignmentBaseline:{trait:0,value:"auto"},baselineShift:{trait:257,value:"0"},clipRule:{trait:0,value:"nonzero"},colorInterpolation:{trait:0,value:"sRGB"},colorIinterpolationFilters:{trait:0,value:"linearRGB"},cx:{trait:257,value:"0"},cy:{trait:257,value:"0"},dominantBaseline:{trait:0,value:"auto"},fill:{trait:17,value:"black"},fillOpacity:{trait:1,value:"1"},fillRule:{trait:0,value:"nonzero"},floodColor:{trait:17,value:"black"},floodOpacity:{trait:1,value:"1"},lightingColor:{trait:17,value:"white"},markerEnd:{trait:0,value:"none"},markerMid:{trait:0,value:"none"},markerStart:{trait:0,value:"none"},mask:{trait:67,value:["maskImage","maskMode","maskRepeat","maskPosition","maskClip","maskOrigin","maskSize","maskComposite"]},maskComposite:{trait:0,value:"add"},maskClip:{trait:0,value:"border-box"},maskImage:{trait:1,value:"none"},maskMode:{trait:0,value:"match-source"},maskRepeat:{trait:0,value:"no-repeat"},maskOrigin:{trait:0,value:"border-box"},maskPosition:{trait:1,value:"center"},maskSize:{trait:1,value:"auto"},pointerEvents:{trait:0,value:"visiblePainted"},r:{trait:257,value:"0"},rx:{trait:257,value:"auto"},ry:{trait:257,value:"auto"},shapeRendering:{trait:0,value:"auto"},stopColor:{trait:17,value:"black"},stopOpacity:{trait:1,value:"1"},stroke:{trait:17,value:"none"},strokeDasharray:{trait:0,value:"none"},strokeDashoffset:{trait:1,value:"0"},strokeLinecap:{trait:0,value:"butt"},strokeLinejoin:{trait:0,value:"miter"},strokeMiterlimit:{trait:1,value:"4"},strokeOpacity:{trait:1,value:"1"},strokeWidth:{trait:257,value:"1px"},textAnchor:{trait:0,value:"start"},textRendering:{trait:0,value:"auto"},vectorEffect:{trait:0,value:"none"},x:{trait:257,value:"0"},y:{trait:257,value:"0"}});const L=new Map,F="([01](?:\\.\\d+)?)\\s*,?\\s+(-?\\d+(?:\\.\\d+)?)\\s*,?\\s+([01](?:\\.\\d+)?)\\s*,?\\s+(-?\\d+(?:\\.\\d+)?)",I={svg:t=>C(t,"svg"),g:t=>C(t,"g"),symbol:t=>C(t,"symbol"),path:t=>C(t,"path"),shape:t=>{switch(t.tagName.toLowerCase()){case"path":case"line":case"rect":case"ellipse":case"circle":case"polyline":case"polygon":return!0}return!1},image:t=>C(t,"image"),use:t=>C(t,"use"),line:t=>C(t,"line"),rect:t=>C(t,"rect"),circle:t=>C(t,"circle"),ellipse:t=>C(t,"ellipse"),polygon:t=>C(t,"polygon"),polyline:t=>C(t,"polyline"),clipPath:t=>C(t,"clippath"),pattern:t=>C(t,"pattern"),linearGradient:t=>C(t,"lineargradient"),radialGradient:t=>C(t,"radialgradient")},q={applyX:(t,e,s)=>t.a*e+t.c*s+t.e,applyY:(t,e,s)=>t.b*e+t.d*s+t.f,clone:t=>({a:t.a,b:t.b,c:t.c,d:t.d,e:t.e,f:t.f}),rotate(t){const e=m(t),s=Math.cos(e),i=Math.sin(e);return{a:s,b:i,c:-1*i,d:s,e:0,f:0}},skew:(t=0,e=0)=>({a:1,b:Math.tan(m(e)),c:Math.tan(m(t)),d:1,e:0,f:0}),scale:(t=1,e=1)=>({a:t,b:0,c:0,d:e,e:0,f:0}),translate:(t=0,e=0)=>({a:1,b:0,c:0,d:1,e:t,f:e})},z={create:(t,e,s=0,i=!0,n=!0)=>({type:t,matrix:e,angle:s,method:{x:i,y:n}}),parse(t,e=B(t,"transform")){if(e&&"none"!==e){const s=[];for(w.matcher(e);w.find();){const[e,i]=w.groups();if(R(i,"matrix")){const i=z.matrix(t,e);i&&s.push(z.create(SVGTransform.SVG_TRANSFORM_MATRIX,i))}else if(!i.endsWith("3d")){const a="X"===A(i),r=!a&&"Y"===A(i);if(R(i,"translate")){const i=n.TRANSLATE.exec(e);if(i){const e=g(i[2],O(t,i[2])),n=!a&&i[3]?g(i[3],O(t,i[3])):0,o=r?0:e,l=r?e:n;s.push(z.create(SVGTransform.SVG_TRANSFORM_TRANSLATE,q.translate(o,l),0))}}else if(R(i,"rotate")){const t=n.ROTATE.exec(e);if(t){const e=c(t[5],t[6]);if(!isNaN(e)){const t=q.rotate(e);a?(t.a=1,t.b=0,t.c=0):r&&(t.b=0,t.c=0,t.d=1),s.push(z.create(SVGTransform.SVG_TRANSFORM_ROTATE,t,e,!a,!r))}}}else if(R(i,"scale")){const t=n.SCALE.exec(e);if(t){const e=r?1:+t[2],i=a?1:r?+t[2]:!a&&t[3]?+t[3]:e;s.push(z.create(SVGTransform.SVG_TRANSFORM_SCALE,q.scale(e,i),0,!r,!a))}}else if(R(i,"skew")){const t=n.SKEW.exec(e);if(t){const e=c(t[2],t[3],0),i=r?0:e,n=r?e:t[4]&&t[5]?c(t[4],t[5],0):0,o=q.skew(i,n);a?s.push(z.create(SVGTransform.SVG_TRANSFORM_SKEWX,o,i,!0,!1)):r?s.push(z.create(SVGTransform.SVG_TRANSFORM_SKEWY,o,n,!1,!0)):(s.push(z.create(SVGTransform.SVG_TRANSFORM_SKEWX,Object.assign(Object.assign({},o),{b:0}),i,!0,!1)),0!==n&&s.push(z.create(SVGTransform.SVG_TRANSFORM_SKEWY,Object.assign(Object.assign({},o),{c:0}),n,!1,!0)))}}}}const i=s.length;if(i){for(let t=0;t<i;++t)s[t].fromStyle=!0;return s}}return null},matrix(t,e=Y(t,"transform")){const s=n.MATRIX.exec(e);if(s)switch(s[1]){case"matrix":return{a:+s[2],b:+s[3],c:+s[4],d:+s[5],e:+s[6],f:+s[7]};case"matrix3d":return{a:+s[2],b:+s[3],c:+s[6],d:+s[7],e:+s[14],f:+s[15]}}return null},origin(t,e){const s={x:0,y:0};if((e||(e=Y(t,"transform-origin")))&&(e=e.trim())){const i=K(t);let n=0,a=0;if(i)({width:n,height:a}=i);else{const e=t.parentElement;if(e instanceof SVGGraphicsElement){const t=e.viewportElement;t&&(I.svg(t)||I.symbol(t))&&({width:n,height:a}=t.viewBox.baseVal)}}n&&a||({width:n,height:a}=t.getBoundingClientRect());const r=e.split(/\s+/);switch(1===r.length&&r.push("center"),r[0]){case"0%":case"left":break;case"100%":case"right":s.x=n;break;case"center":r[0]="50%";default:N(t,s,"x",r[0],n)}switch(r[1]){case"0%":case"top":break;case"100%":case"bottom":s.y=a;break;case"center":r[1]="50%";default:N(t,s,"y",r[1],a)}}return s},rotateOrigin(t,e="transform"){const s=p(t,e),i=[];if(s)for(V.matcher(s);V.find();){const[t,e,s]=V.map((t=>+t||0),1);0!==t&&i.push({angle:t,x:e,y:s})}return i},typeAsName(t){switch(t){case SVGTransform.SVG_TRANSFORM_ROTATE:return"rotate";case SVGTransform.SVG_TRANSFORM_SCALE:return"scale";case SVGTransform.SVG_TRANSFORM_SKEWX:return"skewX";case SVGTransform.SVG_TRANSFORM_SKEWY:return"skewY";case SVGTransform.SVG_TRANSFORM_TRANSLATE:return"translate"}return""},typeAsValue(t){switch(t){case"rotate":case SVGTransform.SVG_TRANSFORM_ROTATE:return"0 0 0";case"scale":case SVGTransform.SVG_TRANSFORM_SCALE:return"1 1 0 0";case"skewX":case"skewY":case SVGTransform.SVG_TRANSFORM_SKEWX:case SVGTransform.SVG_TRANSFORM_SKEWY:return"0";case"translate":case SVGTransform.SVG_TRANSFORM_TRANSLATE:return"0 0"}return""}};function X(t){const e=t.getBoundingClientRect();return e.x=e.left,e.y=e.top,e}function D(t,e,s){switch(e){case"animationDelay":case"animationDuration":case"animationIterationCount":case"offsetDistance":case"offsetRotate":case"mask":return r(t,e,s);case"fill":case"stroke":case"stopColor":case"floodColor":case"lightingColor":return r(t,"fontColor",s);case"fillOpacity":case"strokeOpacity":case"stopOpacity":case"floodOpacity":return r(t,"opacity",s);case"strokeMiterlimit":{const e=o(t,s,{supportPercent:!1,unitType:32,min:1});return isNaN(e)?"":e.toString()}}const i=K(t)||(t.viewportElement||t.parentElement||t).getBoundingClientRect();switch(e){case"transform":case"transformOrigin":case"offsetAnchor":case"offsetPath":case"clipPath":case"maskImage":case"maskPosition":case"maskSize":case"width":case"height":return r(t,e,s,i);case"baselineShift":return r(t,"verticalAlign",s,i);case"cx":case"x":case"x1":case"x2":{const e=o(t,s,{boundingSize:i.width});return isNaN(e)?"":e.toString()}case"cy":case"y":case"y1":case"y2":{const e=o(t,s,{boundingSize:i.height});return isNaN(e)?"":e.toString()}case"r":{const e=o(t,s,{boundingSize:G(i,!0),min:0});return isNaN(e)?"0":e.toString()}case"rx":{const e=o(t,s,{boundingSize:i.width,min:0});return isNaN(e)?"0":I.rect(t)?Math.min(e,i.width/2).toString():e.toString()}case"ry":{const e=o(t,s,{boundingSize:i.height,min:0});return isNaN(e)?"0":I.rect(t)?Math.min(e,i.height/2).toString():e.toString()}case"strokeDasharray":return l(t,s,{boundingSize:G(i),min:0});case"strokeDashoffset":{const e=o(t,s,{boundingSize:G(i,!0),unitType:32});return isNaN(e)?"":e.toString()}case"strokeWidth":{const e=o(t,s,{boundingSize:G(i),unitType:32,min:0});return isNaN(e)?"":e.toString()}}return""}function Y(t,e,s){return B(t,e)||p(t,e)||(s||Array.from(t.style).includes(e))&&u(t).getPropertyValue(e)||""}function U(t,e,s){let i=t,n;do{if(n=Y(i,e,s),n&&"inherit"!==n)break;i=i.parentElement}while(i&&!(i instanceof HTMLElement));return n}function W(t,e,s){const i=p(t,"href")||p(t,"xlink:href");if("#"===i[0]){const s=i.substring(1);if(!e){let s=t.parentElement;for(e=s;s&&!(s.parentElement instanceof HTMLElement);)e=s,s=s.parentElement}if(e){const t=e.querySelectorAll("*");for(let e=0,i=t.length;e<i;++e){const i=t[e];if(i.id===s&&i instanceof SVGElement)return i}}const n=document.getElementById(s);if(n instanceof SVGElement)return n}else if(s){const[e,n]=E(i,"#");if(e){const i=s[x(e)];if(i){if(document.body.insertAdjacentHTML("beforeend",i),(t=document.body.lastElementChild)instanceof SVGGraphicsElement)return t.style.display="none",t.querySelector(`#${n}`);t&&document.body.removeChild(t)}}}return null}function $(t,e=3){let s=P.get(e);s||(s=new RegExp(`(-?\\d+\\.\\d{${e}})(\\d)\\d*`,"g"),P.set(e,s));let i=t,n;for(;n=s.exec(t);){let t=n[1];+n[2]>=5&&(t=S(+t+1/Math.pow(10,e)).toString()),i=i.replace(n[0],b(t))}return s.lastIndex=0,i}function K(t){let e=t.parentElement;for(;e;){if(I.svg(e)||I.symbol(e)){const t=e.viewBox;if(t){const s=t.baseVal;return s&&s.width&&s.height?s:X(e)}}e=e.parentElement}return null}function j(t,e){let s=0,i=0,n=t.parentElement;for(;n&&n!==e;)(I.svg(n)||I.use(n))&&(s+=n.x.baseVal.value,i+=n.y.baseVal.value),n=n.parentElement;return{x:s,y:i}}function H(t){let e=t,s;for(;s=_.exec(e);)t=t.replace(s[0],v(s[0],!1,1/0));let i=/(\d*)\.(\d+)\.(\d+)/g;for(;s=i.exec(e=t);){let e;if(s[1])if(s[3].length>=2)e=s[1]+"."+s[2]+" ."+s[3];else{const t=s[2].length;e=s[1]+"."+(1===t?s[2]+" ."+s[3]:s[2].substring(0,t-1)+" "+s[2][t-1]+"."+s[3])}else e="."+s[2]+" ."+s[3];t=t.replace(s[0],e+" ")}for(i=/(\d)([A-Za-z])/g;s=i.exec(e=t);)t=t.replace(s[0],s[1]+" "+s[2]);for(i=/([A-Za-z])\s+(\d)/g;s=i.exec(e=t);)t=t.replace(s[0],s[1]+s[2]);for(i=/([Aa](?:-?[\d.]+[\s,]+){3}\s*)(0|1)(0|1)(-?[\d.]+)/g;s=i.exec(e=t);)t=t.replace(s[0],s[1]+" "+s[2]+" "+s[3]+" "+s[4]);for(i=/((?:-?[\d.]+[\s,]+){3}\s*)0(0|1)(-?[\d.]+)/g;s=i.exec(e=t);)for(let n=i.lastIndex-1;n>=0;--n){const i=e[n];if("A"===i||"a"===i){t=t.replace(s[0],i+s[1]+" 0 "+s[2]+" "+s[3]);break}}for(i=/([A-Za-z\s,])(?:(0+)(\d)|(0{2,}))/g;s=i.exec(e=t);)t=t.replace(s[0],s[1]+" "+(s[4]?"0 ".repeat(s[4].length):"0 ".repeat(s[2].length)+" "+s[3]));for(i=/(\d+)-/g;s=i.exec(e=t);)t=t.replace(s[0],s[1]+" -");return _.lastIndex=0,t.replace(/\s{2,}/g," ")}function Z(t){const e=document.createElementNS("http://www.w3.org/2000/svg","path");return e.setAttribute("d",t),e}function Q(t){const e=undefined;return Z(t).getTotalLength()}var J=Object.freeze({__proto__:null,CACHE_VIEWNAME:L,PATTERN_CUBICBEZIER:F,SVG:I,MATRIX:q,TRANSFORM:z,getDOMRect:X,calculateStyle:D,getAttribute:Y,getParentAttribute:U,getTargetElement:W,truncateString:$,getNearestViewBox:K,getRootOffset:j,sanitizePath:H,createPath:Z,getPathLength:Q});const{STRING:tt}=squared.lib.regex,{isAngle:et,parseAngle:st}=squared.lib.css,{getNamedItem:it}=squared.lib.dom,{absoluteAngle:nt,offsetAngleY:at,relativeAngle:rt,truncate:ot,truncateFraction:lt}=squared.lib.math,{hasBit:ct,isArray:ht,splitPair:ut,splitPairEnd:ft,splitSome:dt}=squared.lib.util,gt=new RegExp(tt.DECIMAL_SIGNED,"g"),pt=/([A-Za-z])([^A-Za-z]+)?/g;class SvgBuild{static isUse(t){return ct(t.instanceType,1)}static isContainer(t){return ct(t.instanceType,2)}static isElement(t){return ct(t.instanceType,4)}static isShape(t){return ct(t.instanceType,2052)}static isAnimate(t){return ct(t.instanceType,32776)}static isAnimateTransform(t){return ct(t.instanceType,98312)}static asSvg(t){return 18===t.instanceType}static asG(t){return 34===t.instanceType}static asPattern(t){return 258===t.instanceType}static asShapePattern(t){return 514===t.instanceType}static asImage(t){return 8196===t.instanceType}static asUseG(t){return 115===t.instanceType}static asUseSymbol(t){return 131===t.instanceType}static asUseShape(t){return 6149===t.instanceType}static asUseShapePattern(t){return 1539===t.instanceType}static asSet(t){return 8===t.instanceType}static asAnimate(t){return 32776===t.instanceType}static asAnimateTransform(t){return 98312===t.instanceType}static asAnimateMotion(t){return 229384===t.instanceType}static drawCircle(t,e,s,i){return SvgBuild.drawEllipse(t,e,s,s,i)}static drawPolygon(t,e){return t.length>0?SvgBuild.drawPolyline(t,e)+"Z":""}static drawLine(t,e,s=0,i=0,n){return n&&(t=ot(t,n),e=ot(e,n),s=ot(s,n),i=ot(i,n)),`M${t},${e} L${s},${i}`}static drawRect(t,e,s=0,i=0,n){return n?(t=ot(s+t,n),e=ot(i+e,n),s=ot(s,n),i=ot(i,n)):(t+=s,e+=i),`M${s},${i} ${t},${i} ${t},${e} ${s},${e}Z`}static drawEllipse(t,e,s,i,n){void 0===i&&(i=s);let a=2*s;return t-=s,n&&(t=ot(t,n),e=ot(e,n),s=ot(s,n),i=ot(i,n),a=ot(a,n)),`M${t},${e} a${s},${i},0,0,1,${a},0 a${s},${i},0,0,1,-${a},0`}static drawPolyline(t,e){let s="M";const i=t.length;if(e)for(let n=0;n<i;++n){const{x:i,y:a}=t[n];s+=" "+ot(i,e)+","+ot(a,e)}else for(let e=0;e<i;++e){const{x:i,y:n}=t[e];s+=" "+i+","+n}return s}static drawPath(t,e){let s="";for(let e=0,i=t.length;e<i;++e){const i=t[e];switch(s+=e>0?" "+i.key:i.key,i.key.toUpperCase()){case"M":case"L":case"C":case"S":case"Q":case"T":s+=i.coordinates.join(",");break;case"H":s+=i.coordinates[0];break;case"V":s+=i.coordinates[1];break;case"A":s+=`${i.radiusX},${i.radiusY},${i.xAxisRotation},${i.largeArcFlag},${i.sweepFlag},${i.coordinates.join(",")}`}}return e?$(s,e):s}static drawRefit(t,e,s){let i;if(I.path(t)){if(i=it(t,"d"),e&&e.requireRefit){const t=SvgBuild.toPathCommands(i);if(t.length){const n=SvgBuild.toPathPoints(t);n.length&&(e.refitPoints(n),i=SvgBuild.drawPath(SvgBuild.syncPath(t,n),s))}}}else if(I.line(t)){const n=[{x:t.x1.baseVal.value,y:t.y1.baseVal.value},{x:t.x2.baseVal.value,y:t.y2.baseVal.value}];e&&e.requireRefit&&e.refitPoints(n),i=SvgBuild.drawPolyline(n,s)}else if(I.circle(t)||I.ellipse(t)){let n,a;I.ellipse(t)?(n=t.rx.baseVal.value,a=t.ry.baseVal.value):(n=t.r.baseVal.value,a=n);const r=[{x:t.cx.baseVal.value,y:t.cy.baseVal.value,rx:n,ry:a}];e&&e.requireRefit&&e.refitPoints(r);const o=r[0];i=SvgBuild.drawEllipse(o.x,o.y,o.rx,o.ry,s)}else if(I.rect(t)){let n=t.x.baseVal.value,a=t.y.baseVal.value,r=t.width.baseVal.value,o=t.height.baseVal.value;e&&e.requireRefit&&(n=e.refitX(n),a=e.refitY(a),r=e.refitSize(r),o=e.refitSize(o)),i=SvgBuild.drawRect(r,o,n,a,s)}else if(I.polygon(t)||I.polyline(t)){const n=SvgBuild.clonePoints(t.points);e&&e.requireRefit&&e.refitPoints(n),i=I.polygon(t)?SvgBuild.drawPolygon(n,s):SvgBuild.drawPolyline(n,s)}return i||""}static transformRefit(t,e){let s,i,n,a;e&&({transforms:s,parent:i,container:n,precision:a}=e);const r=SvgBuild.toPathCommands(t);if(r.length){let e=SvgBuild.toPathPoints(r);if(e.length){const o=ht(s);o&&(e=SvgBuild.applyTransforms(s,e,i&&z.origin(i.element))),n&&n.requireRefit&&n.refitPoints(e),t=SvgBuild.drawPath(SvgBuild.syncPath(r,e,o),a)}}return t}static toOffsetPath(t,e="auto 0deg"){const s=Z(t),i=Math.ceil(s.getTotalLength()),n=[];if(i){const a=[],r=[];let o=0,l=0,c=0,h=0,u=null,f;if(et(e))o=st(e,0);else{for(const e of SvgBuild.toPathCommands(t))switch(e.key.toUpperCase()){case"M":case"L":case"H":case"V":case"Z":a.push(...e.value),r.push(...new Array(e.value.length).fill(!1));break;case"C":case"S":case"Q":case"T":case"A":a.push(e.end),r.push(!0)}"auto 0deg"!==e&&(l=st(ft(e," "),0))}for(let t=0;t<i;++t){const e=s.getPointAtLength(t);if(a.length){const t=a.findIndex((t=>{const s=t.x.toString(),i=t.y.toString();return s===e.x.toPrecision(s.length-(-1!==s.indexOf(".")?1:0))&&i===e.y.toPrecision(i.length-(-1!==i.indexOf(".")?1:0))}));if(-1!==t){const s=a[t+1];s?(f=r[t+1])?(u=SvgBuild.centerOf(a[t],s),o=0):(u=null,o=lt(nt(e,s))):u=null,h=0,a.splice(0,t+1),r.splice(0,t+1)}}let i;f?(i=u?lt(rt(u,e)):0,c>0&&c%360==0&&0===Math.floor(i)&&(h=c),i+=h):i=o,i+=l,n.push({key:t,value:e,rotate:i}),c=Math.ceil(i)}}return n}static toPathCommands(t){const e=[];let s=0,i;for(;i=pt.exec(t);){let t=i[1];if(0===s&&"M"!==t.toUpperCase())break;const n=i[2]?SvgBuild.parseCoordinates(i[2].trim()):[],a=[];let r=n.length,o,l;if(s>0){const t=e[s-1];o=t.key.toUpperCase(),l=t.end}switch(t.toUpperCase()){case"M":0===s&&(t="M");case"L":r>=2&&(r-=r%2,a.push(n));break;case"H":if(l)for(let e=0;e<r;++e)a.push([n[e],"h"===t?0:l.y]);break;case"V":if(l)for(let e=0;e<r;++e)a.push(["v"===t?0:l.x,n[e]]);break;case"Z":s>0&&(a.push(e[0].coordinates.slice(0,2)),t="Z");break;case"C":if(r>=6){r-=r%6;for(let t=0;t<r;t+=6)a.push(n.slice(t,t+6))}break;case"S":if(r>=4&&("C"===o||"S"===o)){r-=r%4;for(let t=0;t<r;t+=4)a.push(n.slice(t,t+4))}break;case"Q":if(r>=4){r-=r%4;for(let t=0;t<r;t+=4)a.push(n.slice(t,t+4))}break;case"T":if(r>=2&&("Q"===o||"T"===o)){r-=r%2;for(let t=0;t<r;t+=2)a.push(n.slice(t,t+2))}break;case"A":if(r>=7){r-=r%7;for(let t=0;t<r;t+=7)a.push(n.slice(t,t+7))}break;default:continue}for(let s=0,i=a.length;s<i;++s){const i=a[s],n=t.toLowerCase(),r="a"===n?i.splice(0,5):null,o=t===n,c=i.length,h=new Array(c/2);let u=0;for(let t=0;t<c;t+=2){let e=i[t],s=i[t+1];o&&l&&(e+=l.x,s+=l.y),h[u++]={x:e,y:s}}const f={key:t,value:h,start:h[0],end:h[u-1],relative:o,coordinates:i};r&&(f.radiusX=r[0],f.radiusY=r[1],f.xAxisRotation=r[2],f.largeArcFlag=r[3],f.sweepFlag=r[4]),e.push(f),l=f.end}s=e.length}return pt.lastIndex=0,e}static toPathPoints(t){const e=[];let s=0,i=0;for(let n=0,a=t.length;n<a;++n){const a=t[n],{key:r,relative:o,coordinates:l}=a;for(let t=0,n=l.length;t<n;t+=2){o?(s+=l[t],i+=l[t+1]):(s=l[t],i=l[t+1]);const n={x:s,y:i};"A"===r.toUpperCase()&&(n.rx=a.radiusX,n.ry=a.radiusY),e.push(n)}o&&(a.key=r.toUpperCase())}return e}static syncPath(t,e,s){t:{let i;for(let n=0,a=t.length;n<a;++n){const a=t[n],{key:r,coordinates:o,value:l}=a;if(a.relative){if(!i)break;if(!s||"H"!==r&&"V"!==r){const t=o.length;for(let s=0,n=0;s<t;s+=2){const t=e.shift();if(!t)break t;o[s]=t.x-i.x,o[s+1]=t.y-i.y,"a"===r&&void 0!==t.rx&&void 0!==t.ry&&(a.radiusX=t.rx,a.radiusY=t.ry),l[n++]=t,i=t}a.key=r.toLowerCase()}else{const t=e.shift();if(!t)break t;o[0]=t.x,o[1]=t.y,l[0]=t,a.key="L",a.relative=!1}}else switch(r.toUpperCase()){case"M":case"L":case"H":case"V":case"C":case"S":case"Q":case"T":case"Z":{const s=o.length;for(let i=0,n=0;i<s;i+=2){const s=e.shift();if(!s){t=[];break t}o[i]=s.x,o[i+1]=s.y,a.value[n++]=s}break}case"A":{const s=e.shift();if(!s){t=[];break t}o[0]=s.x,o[1]=s.y,a.radiusX=s.rx,a.radiusY=s.ry,a.value[0]=s;break}}i=l[l.length-1],a.start=l[0],a.end=i}}return t}static filterTransforms(t,e){const s=[];for(let i=0,n=t.length;i<n;++i){const n=t[i],a=n.type;if(!e||!e.includes(a)){switch(a){case SVGTransform.SVG_TRANSFORM_ROTATE:case SVGTransform.SVG_TRANSFORM_SKEWX:case SVGTransform.SVG_TRANSFORM_SKEWY:if(0===n.angle)continue;break;case SVGTransform.SVG_TRANSFORM_SCALE:{const t=n.matrix;if(1===t.a&&1===t.d)continue;break}case SVGTransform.SVG_TRANSFORM_TRANSLATE:{const t=n.matrix;if(0===t.e&&0===t.f)continue;break}}s.push(n)}}return s}static applyTransforms(t,e,s){const i=SvgBuild.clonePoints(e),n=i.length;for(const e of t.slice(0).reverse()){const t=e.matrix;let a=0,r=0,o=0,l=0;if(s){const{x:i,y:n}=s,{x:c,y:h}=e.method;switch(e.type){case SVGTransform.SVG_TRANSFORM_SCALE:c&&(o=i*(1-t.a)),h&&(l=n*(1-t.d));break;case SVGTransform.SVG_TRANSFORM_SKEWX:(c||h)&&(r-=n);break;case SVGTransform.SVG_TRANSFORM_SKEWY:(c||h)&&(a-=i);break;case SVGTransform.SVG_TRANSFORM_ROTATE:c&&(a-=i,o=i+at(e.angle,i)),h&&(r-=n,l=n+at(e.angle,n))}}for(let s=0;s<n;++s){const n=i[s],{x:c,y:h}=n;if(n.x=q.applyX(t,c,h+r)+o,n.y=q.applyY(t,c+a,h)+l,e.type===SVGTransform.SVG_TRANSFORM_SCALE){const{rx:e,ry:s}=n;void 0!==e&&void 0!==s&&(n.rx=q.applyX(t,e,s+r),n.ry=q.applyY(t,e+a,s))}}}return i}static convertTransforms(t){const e=t.numberOfItems,s=new Array(e);for(let i=0;i<e;++i){const{type:e,matrix:n,angle:a}=t.getItem(i);s[i]=z.create(e,n,a)}return s}static convertPoints(t){const e=t.length;if(e%2==0){const s=new Array(e/2);for(let i=0,n=0;i<e;i+=2)s[n++]={x:t[i],y:t[i+1]};return s}return[]}static clonePoints(t){if(Array.isArray(t)){const e=t.length,s=new Array(e);for(let i=0;i<e;++i){const{x:e,y:n,rx:a,ry:r}=t[i],o={x:e,y:n};void 0!==a&&void 0!==r&&(o.rx=a,o.ry=r),s[i]=o}return s}const e=t.numberOfItems,s=new Array(e);for(let i=0;i<e;++i){const{x:e,y:n}=t.getItem(i);s[i]={x:e,y:n}}return s}static minMaxOf(t,e){let{x:s,y:i}=t[0],n=s,a=i;for(let r=1,o=t.length;r<o;++r){const{x:o,y:l}=t[r];if(e&&r>0){const{rx:e,ry:c}=t[r];if(void 0!==e&&void 0!==c){const{x:h,y:u}=t[r-1];let f=(o+h)/2,d=(l+u)/2;o>h?d-=c:o<h&&(d+=c),l<u?f+=e:l>h&&(f-=e),s=Math.min(f,s),n=Math.max(f,n),i=Math.min(d,i),a=Math.max(d,a)}}o<s?s=o:o>n&&(n=o),l<i?i=l:l>a&&(a=l)}return{top:i,right:n,bottom:a,left:s}}static centerOf(...t){const e=this.minMaxOf(t);return{x:(e.left+e.right)/2,y:(e.top+e.bottom)/2}}static boxRectOf(t){const e=[];for(let s=0,i=t.length;s<i;++s)e.push(...SvgBuild.toPathPoints(SvgBuild.toPathCommands(t[s])));return this.minMaxOf(e,!0)}static parsePoints(t){const e=[];return dt(t,(t=>{const[s,i]=ut(t,",");e.push({x:+s,y:+i})}),/\s+/g),e}static parseCoordinates(t){const e=[];let s;for(;s=gt.exec(t);){const t=+s[0];isNaN(t)||e.push(t)}return gt.lastIndex=0,e}}const{getNamedItem:mt}=squared.lib.dom;function yt(t,e,s,i,n){for(let a=0,r=t.length;a<r;++a){const r=t[a];r.x+=e,r.y+=s,void 0!==r.rx&&void 0!==r.ry&&(r.rx*=i,r.ry*=n)}}var vt=t=>class extends t{constructor(){super(...arguments),this._baseVal={}}setBaseValue(t,e){if(void 0!==e){if(1===this.verifyBaseValue(t,e))return this._baseVal[t]=e,!0}else switch(t){case"d":return this._baseVal[t]=mt(this.element,"d"),!0;case"points":{const e=this.element[t];if(Array.isArray(e))return this._baseVal[t]=SvgBuild.clonePoints(e),!0;break}default:{const e=this.element[t];if(e){const s=e.baseVal;if(s)return this._baseVal[t]=s.value,!0}break}}return!1}getBaseValue(t,e){var s;return null!==(s=this._baseVal[t])&&void 0!==s?s:this.setBaseValue(t)?void 0:e}refitBaseValue(t,e,s,i=1,n=1){const a=this._baseVal;for(const r in a){const o=a[r];if("string"==typeof o){if("d"===r){const l=SvgBuild.toPathCommands(o),c=SvgBuild.toPathPoints(l);yt(c,t,e,i,n),a[r]=SvgBuild.drawPath(SvgBuild.syncPath(l,c),s)}}else if("number"==typeof o)switch(r){case"cx":case"x1":case"x2":case"x":a[r]+=t;break;case"cy":case"y1":case"y2":case"y":a[r]+=e;break;case"r":a[r]*=Math.min(i,n);break;case"rx":case"width":a[r]*=i;break;case"ry":case"height":a[r]*=n}else Array.isArray(o)&&"points"===r&&yt(o,t,e,i,n)}}verifyBaseValue(t,e){switch(t){case"d":return"string"==typeof e?1:0;case"cx":case"cy":case"r":case"rx":case"ry":case"x1":case"x2":case"y1":case"y2":case"x":case"y":case"width":case"height":return"number"==typeof e?1:0;case"points":return Array.isArray(e)?1:0}return 2}};const{getFontSize:St,getStyle:bt,hasEm:kt,isLength:Tt,parseUnit:At}=squared.lib.css,{getNamedItem:xt}=squared.lib.dom,{capitalize:Et,hasValue:Rt,sortNumber:wt,splitSome:Vt}=squared.lib.util,_t=/^(-)?(\d+(?:\.\d+)?)(ms|s|min|h)?$/,Pt=/^(-)?(?:(\d+):)?(?:([0-5][0-9]):)?([0-5][0-9])(?:\.(\d{1,3}))?$/;function Nt(t,e){const s=this.fillMode&e;t?s||(this.fillMode|=e):s&&(this.fillMode^=e)}class SvgAnimation{constructor(t,e){if(this.element=null,this.fillMode=0,this.synchronizeState=0,this.paused=!1,this.id=null,this.baseValue="",this.animationElement=null,this.instanceType=8,this._to="",this._duration=-1,this._delay=0,this._parent=null,this._attributeName="",this._dataset=null,this._group=null,t){const e=t.dataset;for(const t in e)try{(this._dataset||(this._dataset={}))[t]=JSON.parse(e[t])}catch(t){}this.element=t}if(e){this.animationElement=e,this.setAttribute("attributeName"),this.setAttribute("to"),this.setAttribute("fill","freeze");const t=xt(e,"dur");if(t&&"indefinite"!==t){const e=SvgAnimation.parseClockTime(t);this.duration=!isNaN(e)&&e>0?e:0}}}static getClockTimes(t){const e=[];return Vt(t,(t=>{const s=this.parseClockTime(t);isNaN(s)||e.push(s)}),";"),wt(e),e}static parseClockTime(t){let e=_t.exec(t=t.trim());if(e){let t=+e[2]*(e[1]?-1:1);switch(e[3]){case"ms":break;case"h":t*=60;case"min":t*=60;default:t*=1e3}return Math.round(t)}if(e=Pt.exec(t)){const t=e[5];let s=+e[4]*(e[1]?-1:1);return e[1]&&(s+=60*+e[2]*60),e[2]&&(s+=60*+e[3]),1e3*s+(t?+t*(t.length<3?Math.pow(10,3-t.length):1):0)}return NaN}setAttribute(t,e){const s=this.animationElement;if(s){const i=xt(s,t);i&&(e?this[t+Et(e)]=i===e:this[t]=i)}}addState(...t){for(const e of t)~this.synchronizeState&e&&(this.synchronizeState|=e)}removeState(...t){t.forEach((t=>this.synchronizeState&=~t))}hasState(...t){return t.some((t=>this.synchronizeState&t))}set attributeName(t){var e,s,i,n;if("transform"!==t&&!this.baseValue){let a=null===(s=null===(e=this._dataset)||void 0===e?void 0:e.baseValue)||void 0===s?void 0:s[t];if(Rt(a))this.baseValue=a.toString().trim();else{const e=this.element;if(e){switch(t){case"opacity":case"stroke-opacity":case"fill-opacity":a=Y(e,t)||"1";break;default:a=Y(e,t)}if(a)this.baseValue=a;else{const s=this.animationElement;if(s&&"paused"===bt(e).animationPlayState){const e=s.parentElement;if(e){const s=null===(n=null===(i=e[t])||void 0===i?void 0:i.baseVal)||void 0===n?void 0:n.valueAsString;s&&Tt(s)&&(this.baseValue=At(s,kt(s)?{fontSize:St(e)}:void 0).toString())}}}}}}this._attributeName=t}get attributeName(){return this._attributeName}set delay(t){this._delay=t}get delay(){return this._delay}set duration(t){this._duration=Math.round(t)}get duration(){return this._duration}set to(t){this._to=t}get to(){return this._to}set fillBackwards(t){Nt.call(this,t,4)}get fillBackwards(){return(4&this.fillMode)>0}set fillForwards(t){Nt.call(this,t,2)}get fillForwards(){return(2&this.fillMode)>0}set fillFreeze(t){Nt.call(this,t,1)}get fillFreeze(){return(1&this.fillMode)>0}set parent(t){this._parent=t}get parent(){return this._parent}set group(t){this._group=t}get group(){return this._group||(this._group={id:-1/0,name:""})}set setterType(t){}get setterType(){return!0}get fillReplace(){switch(this.fillMode){case 0:case 4:return!0}return!1}get parentContainer(){let t=this._parent;for(;t&&!SvgBuild.isContainer(t);)t=t.parent;return t}}const{convertHex:Mt,parseColor:Bt}=squared.lib.color,{getFontSize:Ct,hasEm:Gt,isLength:Ot,parseUnit:Lt}=squared.lib.css,{getNamedItem:Ft}=squared.lib.dom,{lastItemOf:It,replaceMap:qt,splitSome:zt}=squared.lib.util,{trimEnd:Xt}=squared.base.lib.util,Dt=new RegExp(`^(?:^|\\s+)${F}(?:$|\\s+)$`),Yt=new RegExp(`cubic-bezier\\(${F}\\)`),Ut=t=>+(1-t).toPrecision(5);class SvgAnimate extends SvgAnimation{constructor(t,e){if(super(t,e),this.type=0,this.additiveSum=!1,this.accumulateSum=!1,this.instanceType=32776,this._reverse=!1,this._alternate=!1,this._values=null,this._keyTimes=null,this._keySplines=null,this._iterationCount=1,this._from="",this._setterType=!1,this._repeatDuration=-1,this._timingFunction="",e){const t=Ft(e,"values"),s=-1!==this.duration?SvgAnimate.toFractionList(Ft(e,"keyTimes")):[];if(t){const e=Xt(t,";").split(/\s*;\s*/);this.values=e;const i=e.length;i>1&&i===s.length?(this.from=e[0],this.to=e[i-1],this.keyTimes=s):1===i&&(this.to=this.values[0],this.convertToValues())}else this.from=Ft(e,"from"),this.convertToValues(s);const i=Ft(e,"repeatDur");if(i&&"indefinite"!==i){const t=SvgAnimation.parseClockTime(i);!isNaN(t)&&t>0&&(this._repeatDuration=t)}const n=Ft(e,"repeatCount");this.iterationCount="indefinite"===n?-1:+n||0,"animate"===e.tagName.toLowerCase()&&this.setCalcMode()}}static getSplitValue(t,e,s){return t+(e-t)*s}static findTimingFunction(t){const e=SvgAnimate.KEYSPLINE_NAME[t];if(e)return e;if(Dt.test(t))return t.trim();if(t.startsWith("step"))return SvgAnimate.KEYSPLINE_NAME.linear;const s=Yt.exec(t);return s?s[1]+" "+s[2]+" "+s[3]+" "+s[4]:SvgAnimate.KEYSPLINE_NAME.ease}static fromStepTimingFunction(t,e,s,i,n,a){const r=n[a],o=n[a+1],l=e=>Gt(e)?{fontSize:Ct(t)}:void 0;let c,h;switch(e){case"fill":case"stroke":{const t=Bt(r)||0===a&&Bt("#000000")||Bt(n[a-1]),e=Bt(o);t&&e&&(c=[t],h=[e]);break}case"points":c=SvgBuild.convertPoints(SvgBuild.parseCoordinates(r)),h=SvgBuild.convertPoints(SvgBuild.parseCoordinates(o));break;case"rotate":case"scale":case"translate":c=[],h=[],zt(r,(t=>{c.push(+t)}),/\s+/g),zt(o,(t=>{h.push(+t)}),/\s+/g);break;default:{let t=+r;isNaN(t)?Ot(r)&&(c=[Lt(r,l(r))]):c=[t],isNaN(t=+o)?Ot(o)&&(h=[Lt(o,l(o))]):h=[t];break}}if(c&&h){const t=c.length;if(t===h.length){switch(s){case"step-start":s="steps(1, start)";break;case"step-end":s="steps(1, end)"}const n=/steps\((\d+)(?:,\s*(start|end|jump-(?:start|end|both|none)))?\)/.exec(s);if(n){const s=i[a+1]-i[a],r=+n[1],o=100/r,l=r+1,u=new Array(l),f=new Array(l);for(let d=0;d<l;++d){let g=0;switch(n[2]){case"start":case"jump-start":0===d&&(g=1);break;case"jump-both":d<l-1&&(g=1/l);break;case"jump-none":d>0&&(g=1/r)}const p=i[a]+s*(d/r),m=p>0?o*(d+g)/100:0;let y="";switch(e){case"fill":case"stroke":{const t=c[0].rgba,e=h[0].rgba;y=Mt({r:SvgAnimate.getSplitValue(t.r,e.r,m),g:SvgAnimate.getSplitValue(t.g,e.g,m),b:SvgAnimate.getSplitValue(t.b,e.b,m),a:SvgAnimate.getSplitValue(t.a,e.a,m)});break}case"points":for(let e=0;e<t;++e){const t=c[e],s=h[e];y+=(e>0?" ":"")+SvgAnimate.getSplitValue(t.x,s.x,m)+","+SvgAnimate.getSplitValue(t.y,s.y,m)}break;default:for(let e=0;e<t;++e)y+=(e>0?" ":"")+SvgAnimate.getSplitValue(c[e],h[e],m)}if(!y)return null;u[d]=p,f[d]=y}return[u,f]}}}return null}static toFractionList(t,e=";",s=!0){let i=0;const n=qt(t.split(e),(t=>{const e=+t;return isNaN(e)||s&&!(e>=i&&e<=1)?-1:(i=e,e)}));return n.length>1&&(!s||0===n[0]&&n.some((t=>-1!==t)))?n:[]}setCalcMode(t,e){const s=this.animationElement;if(s)switch(e||(e=Ft(s,"calcMode")||"linear")){case"discrete":{const e=this.keyTimes;if(0===e[0]&&2===e.length){const i=this.values,n=[],a=[];for(let r=0,o=e.length-1;r<o;++r){const o=SvgAnimate.fromStepTimingFunction(s,t||this.attributeName,"step-end",e,i,r);o&&(n.push(...o[0]),a.push(...o[1]))}n.push(e.pop()),a.push(i.pop()),this._values=a,this._keyTimes=n,this._keySplines=[SvgAnimate.KEYSPLINE_NAME["step-end"]]}break}case"paced":this._keySplines=null;break;case"spline":{const t=[];zt(Ft(s,"keySplines"),(e=>{t.push(e)}),";"),this.keySplines=t}case"linear":{const t=this.keyTimes;if(0!==t[0]&&1!==It(t)){const t=this.values.length,e=new Array(t);for(let s=0;s<t;++s)e[s]=s/(t-1);this._keyTimes=e,this._keySplines=null}break}}}convertToValues(t){const e=this.to;if(e){if(this.values=[this.from,e],t&&2===t.length){const e=this.keyTimes;if(2!==e.length||0===e[0]&&e[1]<=1)return void(this.keyTimes=t)}this.keyTimes=[0,1]}}setGroupOrdering(t){if(this.group.ordering=t,this.fillBackwards){const e=this.group.name;let s;for(let i=t.length-1;i>=0;--i){const n=t[i];if(s){if("forwards"!==n.fillMode){this.fillBackwards=!1;break}}else n.name===e&&(s=!0)}}}getIntervalEndTime(t,e){const s=this.getTotalDuration();if(t<s){const{duration:i,keyTimes:n}=this;let a=this.delay;for(;a+i<=t;)a+=i;return Math.min(a+(e?1:It(n)||0)*i,s)}return s}getTotalDuration(t){let e=this.iterationCount;return t&&-1===e&&(e=1),-1!==e?Math.min(this.delay+this.duration*e,this.end||1/0):1/0}set delay(t){this._delay=t;const e=this.animationElement,s=e&&Ft(e,"end");if(s){const e=SvgAnimation.getClockTimes(s)[0];if(!isNaN(e)){const{duration:s,iterationCount:i}=this;(-1===i||s>0&&e<s*i)&&(t>e?(this.end=e,-1===i&&(this.iterationCount=Math.ceil((e-t)/s))):this.duration=-1)}}}get delay(){return this._delay}set duration(t){super.duration=t}get duration(){const t=this._duration;return-1===t&&-1!==this._repeatDuration?this._repeatDuration:t}set to(t){this._to=t}get to(){return this._setterType?this.valueTo||this._to:this.setterType?this.values[0]:this._to}get from(){return this._from}set from(t){if(!this._values){const e=this.animationElement;if(e){if(!this.to){const s=Ft(e,"by"),i=SvgBuild.parseCoordinates(s);if(i.length&&(t||(t=this.baseValue||""))){const e=SvgBuild.parseCoordinates(t),s=e.length;if(i.length===s){let t="";for(let n=0;n<s;++n)t+=(n>0?",":"")+(e[n]+i[n]);this.to=t}}}SvgBuild.parseCoordinates(this.to).length&&this.setAttribute("additive","sum")}}this._from=t}set iterationCount(t){this._iterationCount=isNaN(t)?1:t;const e=this.animationElement;e&&(-1!==this.iterationCount?(this.setAttribute("accumulate","sum"),this.fillFreeze="freeze"===Ft(e,"fill")):(this.accumulateSum=!1,this.fillFreeze=!1))}get iterationCount(){const t=this.duration;if(t>0){const e=this._iterationCount,s=this._repeatDuration;return-1!==s&&(-1===e||s<e*t)?s/t:e}return 1}set values(t){this._values=t,t&&t.length!==this.keyTimes.length&&(this._keyTimes=null,this._keySplines=null)}get values(){return this._values||(this._values=[])}set keyTimes(t){const e=this._values;e&&e.length!==t.length||!t.every((t=>t>=0&&t<=1))||(this._keyTimes=t)}get keyTimes(){return this._keyTimes||(this._keyTimes=[])}set keySplines(t){if(t&&t.length){const e=this.keyTimes.length-1;if(t.length>=e&&!t.every((t=>!t||t===SvgAnimate.KEYSPLINE_NAME.linear))){const s=[];for(let i=0;i<e;++i){const e=[];zt(t[i],(t=>{if(isNaN(t=+t))return!0;e.push(t)}),/\s+/g),4===e.length&&e[0]>=0&&e[0]<=1&&e[2]>=0&&e[2]<=1?s.push(e.join(" ")):s.push(SvgAnimate.KEYSPLINE_NAME.linear)}this._keySplines=s}}else this._keySplines=null}get keySplines(){return this._keySplines}set timingFunction(t){this._timingFunction=t?SvgAnimate.findTimingFunction(t):t}get timingFunction(){var t;return this._timingFunction||(null===(t=this.keySplines)||void 0===t?void 0:t[0])||""}set reverse(t){if(this.length&&t!==this._reverse){const t=this.keyTimes,e=this._keySplines,s=t.length,i=new Array(s);for(let e=s-1,n=0;e>=0;--e)i[n++]=1-t[e];if(this.keyTimes=i,this.values.reverse(),e){const t=[];for(let s=e.length-1;s>=0;--s){const i=qt(e[s].split(" "),(t=>+t));t.push(4===i.length?Ut(i[2])+" "+Ut(i[3])+" "+Ut(i[0])+" "+Ut(i[1]):SvgAnimate.KEYSPLINE_NAME.linear)}this._keySplines=t}}this._reverse=t}get reverse(){return this._reverse}set alternate(t){this._alternate=t}get alternate(){return this._alternate}set setterType(t){this._setterType=t}get setterType(){if(this._setterType)return!0;if(this.animationElement&&0===this.duration){const t=this.keyTimes;return t.length>=2&&0===t[0]&&""!==this.values[0]}return!1}set length(t){0===t&&(this._values=null)}get length(){return this._values?this._values.length:0}get valueTo(){return this._values&&It(this._values)||""}get valueFrom(){return this.values[0]||""}get playable(){return!this.paused&&this.duration>0&&this.keyTimes.length>0}get fillReplace(){return super.fillReplace||-1===this.iterationCount}get fromToType(){const t=this.keyTimes;return 2===t.length&&0===t[0]&&1===t[1]}get evaluateStart(){const t=this.keyTimes;return t.length>0&&t[0]>0}get evaluateEnd(){const t=this.keyTimes;return t.length>0&&It(t)<1}}SvgAnimate.KEYSPLINE_NAME={ease:"0.25 0.1 0.25 1","ease-in":"0.42 0 1 1","ease-in-out":"0.42 0 0.58 1","ease-out":"0 0 0.58 1",linear:"0 0 1 1","step-start":"0 1 0 1","step-end":"1 0 1 0"};const{getNamedItem:Wt}=squared.lib.dom;class SvgAnimateTransform extends SvgAnimate{constructor(t,e){if(super(t,e),this.instanceType=98312,e){const t=Wt(e,"type");this.setType(t),this.setCalcMode(t)}}static toRotateList(t){const e=t.length,s=new Array(e);for(let i=0;i<e;++i)if(t[i]){const e=SvgBuild.parseCoordinates(t[i]);if(2===e.length&&(e[2]=0),3!==e.length)return null;s[i]=e}else s[i]=[0,0,0];return s}static toScaleList(t){const e=t.length,s=new Array(e);for(let i=0;i<e;++i)if(t[i]){const e=SvgBuild.parseCoordinates(t[i]);if(1===e.length&&(e[1]=e[0]),2===e.length&&(e[2]=0,e[3]=0),4!==e.length)return null;s[i]=e}else s[i]=[1,1,0,0];return s}static toTranslateList(t){const e=t.length,s=new Array(e);for(let i=0;i<e;++i)if(t[i]){const e=SvgBuild.parseCoordinates(t[i]);if(1===e.length&&(e[1]=0),2!==e.length)return null;s[i]=e}else s[i]=[0,0];return s}static toSkewList(t){const e=t.length,s=new Array(e);for(let i=0;i<e;++i)if(t[i]){const e=SvgBuild.parseCoordinates(t[i]);if(1!==e.length)return null;s[i]=e}else s[i]=[0];return s}expandToValues(){if(this.additiveSum){const{duration:t,keyTimes:e,iterationCount:s}=this;if(-1!==s&&t>0&&e.length){const i=t*s;t:{const{type:n,keySplines:a,values:r}=this,o=[],l=[],c=[];let h;for(let u=0,f=e.length;u<s;++u){u>0&&a&&c.push("");for(let d=0;d<f;++d){const g=SvgBuild.parseCoordinates(r[d]),p=g.length;if(!p)break t;{let r;switch(n){case SVGTransform.SVG_TRANSFORM_TRANSLATE:1===p?r=[g[0],0]:2===p&&(r=g);break;case SVGTransform.SVG_TRANSFORM_SCALE:1===p?r=[g[0],g[0]]:2===p&&(r=g);break;case SVGTransform.SVG_TRANSFORM_ROTATE:1===p?r=[g[0],0,0]:3===p&&(r=g);break;case SVGTransform.SVG_TRANSFORM_SKEWX:case SVGTransform.SVG_TRANSFORM_SKEWY:1===p&&(r=g)}if(!r)break t;{let n=(e[d]+u)*t;if(h)for(let t=0,e=r.length;t<e;++t)r[t]+=h[t];u<s-1&&d===f-1&&(this.accumulateSum&&(h=r),--n),o.push(n/i),l.push(r.join(" ")),a&&d<f-1&&c.push(a[d])}}}}this.values=l,this.keyTimes=o,this.keySplines=c.length?c:null,this.duration=i,this.iterationCount=1,this.accumulateSum=!1}}}}setType(t){let e=null;switch(t){case"translate":this.type=SVGTransform.SVG_TRANSFORM_TRANSLATE,this.animationElement&&(e=SvgAnimateTransform.toTranslateList(this.values));break;case"scale":this.type=SVGTransform.SVG_TRANSFORM_SCALE,this.animationElement&&(e=SvgAnimateTransform.toScaleList(this.values));break;case"rotate":this.type=SVGTransform.SVG_TRANSFORM_ROTATE,this.animationElement&&(e=SvgAnimateTransform.toRotateList(this.values));break;case"skewX":this.type=SVGTransform.SVG_TRANSFORM_SKEWX,this.animationElement&&(e=SvgAnimateTransform.toSkewList(this.values));break;case"skewY":this.type=SVGTransform.SVG_TRANSFORM_SKEWY,this.animationElement&&(e=SvgAnimateTransform.toSkewList(this.values));break;default:return}e&&(this.values=e.map((t=>t.join(" ")))),this.baseValue=z.typeAsValue(this.type)}set attributeName(t){}get attributeName(){return"transform"}}const{sortNumber:$t,splitPairStart:Kt}=squared.lib.util;function jt(t,e,s,i=0,n,a=!1,r=!1,o=0,l=!1,c){if(s){let h=t.get(e);h||t.set(e,h=[]),h.push({time:e,value:s,animation:n,start:a,end:r,endTime:i,fillMode:o,infinite:l,valueFrom:c})}}class SvgAnimationIntervalMap{constructor(t,...e){var s;t=(e.length?t.filter((t=>e.includes(t.attributeName))):t.slice(0)).sort(((t,e)=>t.delay===e.delay?e.group.id-t.group.id:t.delay-e.delay));const i={},n={},a=new Set,r=t.length;for(let e=0;e<r;++e)a.add(SvgAnimationIntervalMap.getKeyName(t[e]));for(const e of a){i[e]=new Map,n[e]=new Map;const s=Kt(e,":"),a=t.filter((t=>t.fillBackwards&&t.attributeName===s)).sort(((t,e)=>e.group.id-t.group.id))[0];if(a){const t=a.delay;jt(n[e],0,a.values[0],t,a,0===t,!1,4)}}for(let e=0;e<r;++e){const s=t[e],i=undefined,a=n[SvgAnimationIntervalMap.getKeyName(s)];if(a)if(s.baseValue&&!a[-1]&&jt(a,-1,s.baseValue),s.setterType){const{delay:t,duration:e}=s,i=s.fillReplace&&e>0;jt(a,t,s.to,i?t+e:0,s,i,!i,1),i&&jt(a,t+e,"",0,s,!1,!0,1)}else if(SvgBuild.isAnimate(s)&&s.duration>0){const t=-1===s.iterationCount,e=s.getTotalDuration();jt(a,s.delay,s.valueTo,e,s,!0,!1,0,t,s.valueFrom),t||s.fillReplace||jt(a,e,s.valueTo,0,s,!1,!0,s.fillForwards?2:1)}}for(const t in n){const e=n[t],s=$t(Array.from(e.keys()));for(let n=0,a=s.length;n<a;++n){const a=s[n],r=e.get(a);for(let e=0;e<r.length;++e){const s=r[e],n=s.animation;if(!s.value||n&&s.start&&SvgBuild.isAnimate(n)&&!n.from){let a;for(const e of i[t].values())for(let t=0,s=e.length;t<s;++t){const s=e[t];if(n!==s.animation&&s.value&&(-1===s.time||2===s.fillMode||1===s.fillMode)){a=s.value;break}}a?s.value=a:s.value||r.splice(e--,1)}}r.length&&(r.sort(((t,e)=>t.animation&&e.animation?t.fillMode===e.fillMode?e.animation.group.id-t.animation.group.id:e.fillMode-t.fillMode:0)),i[t].set(a,r))}}for(const t in i)for(const[e,n]of i[t])for(let a=0,r=n.length;a<r;++a){const r=n[a],o=r.animation;if(o)if(1===r.fillMode){const s=[];for(const[n,a]of i[t])if(n<e)for(let t=0,e=a.length;t<e;++t){const e=a[t];if(e.start){const t=e.animation;t&&t.animationElement&&s.push(t)}}else for(let t=0;t<a.length;++t){const i=a[t];if(n>e)i.end&&s.includes(i.animation)&&a.splice(t--,1);else if(i.end){const e=i.animation;e&&e.animationElement&&e.group.id<o.group.id&&a.splice(t--,1)}}}else if(2===r.fillMode||r.infinite){let n;const a=o.group,r=a.ordering;if(r){const t=o.getTotalDuration(),e=a.name;for(let s=0,i=r.length;s<i;++s){const i=r[s];if(i.name===e)n=!0;else if(SvgAnimationIntervalMap.getGroupEndTime(i)>=t)break}}const l=[];for(const[a,r]of i[t])if(!n&&a<e)for(let t=0,e=r.length;t<e;++t){const e=r[t];if(e.start){const t=e.animation;t&&l.push(t)}}else for(let t=0;t<r.length;++t){const i=r[t];if(a>e){const e=i.animation;(n||e&&(i.end&&l.includes(e)||!o.animationElement&&e.group.id<o.group.id))&&r.splice(t--,1)}else if(i.end){const e=undefined;((null===(s=i.animation)||void 0===s?void 0:s.group.id)||NaN)<o.group.id&&r.splice(t--,1)}}}}for(const t in i){const e=i[t];for(const[t,s]of e)0===s.length&&e.delete(t)}this.map=i}static getGroupEndTime(t){return"infinite"===t.iterationCount?1/0:t.delay+t.duration*+t.iterationCount}static getKeyName(t){return t.attributeName+(SvgBuild.isAnimateTransform(t)?":"+z.typeAsName(t.type):"")}has(t,e,s){const i=this.map[t];return void 0!==e?!(!i||!i.has(e))&&(!s||-1!==i.get(e).findIndex((t=>t.animation===s))):!!i}get(t,e,s){const i=this.map[t];if(i){let t;for(const[n,a]of i){if(!(n<=e))break;for(let i=0,r=a.length;i<r;++i){const r=a[i];if(r.value&&(-1===r.time||r.end&&(2===r.fillMode||1===r.fillMode))||s&&r.start&&e!==n){t=r.value;break}}}return t}}paused(t,e){const s=this.map[t];if(s){let t=0;for(const[i,n]of s){if(!(i<=e))break;for(let s=0,i=n.length;s<i;++s){const i=n[s];if(i.start&&(i.infinite||0===i.fillMode&&i.endTime>e)){if(!i.animation){t=1;break}t=2}else if(i.end&&(2===i.fillMode||1===t&&1===i.fillMode)){t=0;break}}}return 0===t}return!0}evaluateStart(t,e){const s=t.values,i=s.length;if(i){const n=(t.reverse?s[i-1]:s[0])||this.get(t.attributeName,t.delay)||e||t.baseValue;n&&(t.reverse?(s[i-1]=n,t.to=n):(s[0]=n,t.from=n))}return s}}const{clamp:Ht,equal:Zt,multipleOf:Qt}=squared.lib.math,{hasKeys:Jt,hasValue:te,isEqual:ee,joinArray:se,lastItemOf:ie,replaceMap:ne,spliceArray:ae,sortNumber:re}=squared.lib.util;function oe(t,e,s,i,n){let a=0,r,o,l;for(const[e,i]of t){if(s===e){o={key:e,value:i};break}if(s>a&&s<e&&void 0!==r){o={key:a,value:r},l={key:e,value:i};break}a=e,r=i}if(o&&l)Se(t,s,pe(s,o.key,o.value,l.key,l.value),!0);else if(o)Se(t,s,o.value,!0);else if(!n){let n=i.get(e,s,!0);void 0!==n&&(n=ce(n,!0),""!==n&&Se(t,s,n))}}function le(t){const e=new Set,s=t.length,i=t[s-1][0];for(let n=0;n<s;++n){const s=t[n];let a=s[0]/i;if(a>0){let t=7;do{const s=+a.toString().substring(0,t);if(!e.has(s)){a=s;break}}while(++t)}s[0]=a,e.add(a)}return t}function ce(t,e){if("string"==typeof t){if(e)return"";if(t){const e=+t;if(!isNaN(e))return e;if(0===(t=SvgBuild.parsePoints(t)).length)return""}}return t}function he(t,e){let s;if(t)for(let i=0,n=t.length;i<n;++i){const n=t[i];if(!(n.time<=e))break;s=n.value}return s}function ue(t,e,s,i,n){var a;const r=[],o=e.element.tagName;let l;switch(o){case"line":l=["x1","y1","x2","y2"];break;case"rect":l=["width","height","x","y"];break;case"polyline":case"polygon":l=["points"];break;case"circle":l=["cx","cy","r"];break;case"ellipse":l=["cx","cy","rx","ry"];break;default:return}const c=z.origin(e.element);for(let h=0,u=t.length;h<u;++h)t:{const[u,f]=t[h],d=[];for(let t=0,s=l.length;t<s;++t){const s=l[t];let n=f.get(s);if(void 0===n&&(n=null!==(a=he(i[s],u))&&void 0!==a?a:e.getBaseValue(s)),void 0===n)break t;d.push(n)}let g,p;switch(o){case"line":g=[{x:d[0],y:d[1]},{x:d[2],y:d[4]}];break;case"rect":{const[t,e,s,i]=d;g=[{x:s,y:i},{x:s+t,y:i},{x:s+t,y:i+e},{x:s,y:i+e}];break}case"polygon":case"polyline":g=d[0];break;case"circle":case"ellipse":g=[{x:d[0],y:d[1],rx:d[2],ry:ie(d)}]}switch(e.transformed&&(g=SvgBuild.applyTransforms(e.transformed,g,c)),s&&s.refitPoints(g),o){case"line":case"polyline":p=SvgBuild.drawPolyline(g,n);break;case"rect":case"polygon":p=SvgBuild.drawPolygon(g,n);break;case"circle":case"ellipse":{const{x:t,y:e,rx:s,ry:i}=g[0];p=SvgBuild.drawEllipse(t,e,s,i,n);break}}void 0!==p&&r.push({key:u,value:p})}return r}function fe(t,e,s){var i;const n=new Map;for(let a=0,r=e.length;a<r;++a){const r=e[a],o=new Map;for(const e in t){const n=null!==(i=t[e].get(r))&&void 0!==i?i:he(s[e],r);void 0!==n&&o.set(e,n)}n.set(r,o)}return n}function de(t,e,s,i){e&&(t.set(s,e),void 0!==i&&t.set(i,e))}function ge(t,e,s,i,n){switch(t.alternate&&s%2!=0&&(e=e.slice(0).reverse()),t.attributeName){case"transform":if(t.additiveSum&&"string"==typeof n){const a=ne(n.split(" "),(t=>+t)),r=e.map((t=>ne(t.trim().split(/\s+/),(t=>+t)))),o=a.length;if(r.every((t=>t.length===o))){const e=r[i];t.accumulateSum||(s=0);for(let t=0;t<o;++t)e[t]+=a[t];for(let t=0,i=r.length;t<s;++t)for(let t=0;t<i;++t){const s=r[t];for(let t=0,i=s.length;t<i;++t)e[t]+=s[t]}return e.join(" ")}}return e[i];case"points":return SvgBuild.parsePoints(e[i]);default:{let a=+e[i];if(!isNaN(a)){if(t.additiveSum&&"number"==typeof n){a+=n,t.accumulateSum||(s=0);for(let t=0,i=e.length;t<s;++t)for(let t=0;t<i;++t)a+=+e[t]}return a}}}return n||0}function pe(t,e,s,i,n){if(t>e){if("number"==typeof s&&"number"==typeof n)return SvgAnimate.getSplitValue(s,n,(t-e)/(i-e));if("string"==typeof s&&"string"==typeof n){const a=ne(s.split(" "),(t=>+t)),r=ne(n.split(" "),(t=>+t)),o=a.length;if(o===r.length){let s="";for(let n=0;n<o;++n)s+=(n>0?" ":"")+pe(t,e,a[n],i,r[n]);return s}}else if(Array.isArray(s)&&Array.isArray(n)){const a=[];for(let r=0,o=Math.min(s.length,n.length);r<o;++r){const o=s[r],l=n[r];a.push({x:pe(t,e,o.x,i,l.x),y:pe(t,e,o.y,i,l.y)})}return a}}return s}function me(t,e,s,i,n,a,r,o,l,c,h,u,f,d){r<0&&(e-=r,r=0);const g=t.duration,p=e-(r+g*o),m=0===p?0===l?0:1:Ht(p/g);let y=-1,v=-1,S;for(let t=0,e=i.length;t<e;++t){if(-1!==y&&m<=i[t]){v=t;break}m>=i[t]&&(y=t)}return-1!==y&&-1!==v?S=pe(m,i[y],ge(t,n,o,y,s),i[v],ge(t,n,o,v,s)):(v=-1!==y?y+1:i.length-1,S=ge(t,n,o,v,s)),be(t,c=Se(u,c,S),a,v,h,f,d),[c,S]}function ye(t,e,s,i,n,a,r,o){const l=(t-e)/a;for(let t=1,e=i.length;t<e;++t){const e=i[t-1],a=i[t];if(l>=e&&l<=a)return Ce(pe(l,e,ge(s,n,r,t-1,o),a,ge(s,n,r,t,o)))}}function ve(t,e,s,i,n,a,r,o,l,c,h){let u=r.length;o||(o=new Array(u-1).fill(""));const{delay:f,duration:d}=n,g=f+d*i,p=n.getTotalDuration(),m=g+(h?a[0]:1)*d,y=+r[h?0:u-1];let v=g;t:{u=c.length;for(let i=0;i<u;++i){const f=c[i];if(f!==n){const n=f.getTotalDuration();if(f.addState(2),n>v){const[S,b,k]=Fe(f);ke(t,e,s,f,l,S,b,k);let T=m;e:{let t,e=Ie(v,f.delay,f.duration)-1;const s=(s,i,c)=>{let u=h?v!==g||t?s%d/d:0:i===m?1:i%d/d,T=s===i?Ce(ge(f,b,e,c,l)):ye(s,i,f,S,b,f.duration,e,l);if(T){u>0&&(T=Math.round((+T+y)/2).toString());const e=a.length;if(u!==a[e-1]||T!==r[e-1]){const l=t||0===u?k&&k[c]||f.timingFunction:"";if(h){!t&&u>0&&s===v&&(u+=.001);for(let t=0;t<e;++t)if(u<=a[t]){0===t||0===u?(a.unshift(u),r.unshift(T),o.unshift(l)):(a.splice(t,0,u),r.splice(t,0,T),o.splice(t,0,l));break}}else(i===n||i===m)&&i<p&&(u-=.001),a.push(u),r.push(T),o.push(l)}}};do{if(h)for(let t=i+1;t<u;++t){const e=c[t];if(e.delay>v){T=e.delay;break}}for(let i=0,a=S.length;i<a;++i){const a=Be(f.delay,f.duration,S,e,i);if(a>=v&&(t||(s(a,v,i),t=!0),a>v)){if(h&&a>=m)break t;if(s(a,Math.min(a,n,m),i),a>=m)break t;if(v=a,a>=n){n<=p&&f.addState(8);break e}if(a>=T)break e}}}while(++e)}}}}}return[a,r,o]}function Se(t,e,s,i){if(te(s)){let n=t.get(e),a;if(void 0===n&&(n=t.get(e-1),a=!0),n!==s||i){if(!i){if("number"==typeof n&&Zt(s,n))return e;for(;e>0&&t.has(e);)++e}t.set(e,s)}else a&&!t.has(e)&&(t.delete(e-1),t.set(e,s))}return e}function be(t,e,s,i,n,a,r){if(!Ge(SvgBuild.isAnimateTransform(t),n)){if(0===i)return;--i}const o=s&&s[i];o&&a.set(e,o),r&&Te(r,t,e,i)}function ke(t,e,s,i,n,a,r,o){var l;if(0!==a[0]){let s;if(s=i.additiveSum?Ce(n):(null===(l=Ae(e,i.attributeName))||void 0===l?void 0:l.value.toString())||t.get(SvgAnimationIntervalMap.getKeyName(i),i.delay)||Ce(n),i.by){const t=+s;isNaN(t)||(s=(t+i.by).toString())}a.unshift(0),r.unshift(s),o&&o.unshift(i.timingFunction)}if(ie(a)<1){const e=t.get(SvgAnimationIntervalMap.getKeyName(i),i.delay)||Ce(s[i.attributeName])||r[0];a.push(1),r.push(e),o&&o.unshift(i.timingFunction)}}function Te(t,e,s,i){var n;if(SvgBuild.asAnimateTransform(e)){const a=null===(n=e.transformOrigin)||void 0===n?void 0:n[i];a&&t.set(s,a)}}function Ae(t,e){const s=t[e];return s&&ie(s)}function xe(t,e,s,i,n){return void 0===i&&(i=e.delay),void 0===n&&(n=e.to),Se(t,i,s?n:ce(n))}function Ee(t,e){e&&t.push(e),t.sort(((t,e)=>t.delay===e.delay?t.group.id-e.group.id:t.delay-e.delay));for(let e=0;e<t.length-1;++e)t[e].delay===t[e+1].delay&&t.splice(e--,1)}function Re(t,e){if(!e.hasState(8,32)){const s=t.indexOf(e);-1!==s&&t.splice(s,1),t.push(e),e.addState(2)}}function we(t,e=1/0){t.sort(((t,s)=>{const i=t.delay,n=t.delay;if(e!==1/0){if(e===i&&e!==n)return-1;if(e!==i&&e===n)return 1;if(i>e&&n<e)return 1;if(i<e&&n>e)return-1}return i!==n?n-i:s.group.id-t.group.id}))}function Ve(t,e){e?-1!==e.iterationCount&&ae(t,(t=>t===e)):ae(t,(t=>!!t.animationElement))}function _e(t,e){t.sort(((t,s)=>{const i=undefined;if(t.getTotalDuration()<=e)return 1;const n=undefined;if(s.getTotalDuration()<=e)return-1;const a=t.delay,r=s.delay;return a===r?s.group.id-t.group.id:a===e?-1:r===e?1:a<e&&r<e?r-a:a-r}))}function Pe(t,e){const s=t.get("x")||0,i=t.get("y")||0;return e?e.refitX(s)+" "+e.refitX(i):s+" "+i}function Ne(t,e,s){s||(e.iterationCount=-1),e.from=e.valueFrom,e.to=e.valueTo,t.push(e)}function Me(t,e){e.length&&ae(t,(t=>e.includes(t)))}const Be=(t,e,s,i,n)=>Math.round(t+(s[n]+i)*e),Ce=t=>Array.isArray(t)?t.map((t=>t.x+","+t.y)).join(" "):void 0!==t?t.toString():"",Ge=(t,e)=>((t?16:2)&e)>0,Oe=(t,e)=>((t?8:1)&e)>0,Le=t=>t.playable||t.animationElement&&-1!==t.duration,Fe=t=>{var e;return[t.keyTimes.slice(0),t.values.slice(0),(null===(e=t.keySplines)||void 0===e?void 0:e.slice(0))||null]},Ie=(t,e,s)=>Math.floor(Math.max(0,t-e)/s);var qe=t=>class extends t{getAnimateShape(t){const e=[],s=this.animations;for(let i=0,n=s.length;i<n;++i){const n=s[i];if(Le(n))switch(n.attributeName){case"r":case"cx":case"cy":if(I.circle(t)){e.push(n);break}case"rx":case"ry":I.ellipse(t)&&e.push(n);break;case"x1":case"x2":case"y1":case"y2":I.line(t)&&e.push(n);break;case"points":(I.polyline(t)||I.polygon(t))&&e.push(n);break;case"x":case"y":case"width":case"height":I.rect(t)&&e.push(n)}}return e}getAnimateTransform(t){const e=[],s=this.animations;for(let i=0,n=s.length;i<n;++i){const n=s[i];if(SvgBuild.isAnimateTransform(n)&&n.duration>0&&(e.push(n),t&&SvgBuild.asAnimateMotion(n))){const e=t.framesPerSecond;e&&(n.framesPerSecond=e)}}return e}getAnimateViewRect(t){t||(t=this.animations);const e=[];for(let s=0,i=t.length;s<i;++s){const i=t[s];if(Le(i))switch(i.attributeName){case"x":case"y":e.push(i)}}return e}animateSequentially(t,e,s,i){var n,a,r;let o=9,l;i&&(i.keyTimeMode&&(o=i.keyTimeMode),l=i.precision);const c=this.animations;for(const i of[t,e]){const t=i===e;if(!i||0===i.length||!t&&4&o||t&&32&o)continue;const h=[],u={},f=new Set;let d=0;const g=t=>{var e;(u[e=t.attributeName]||(u[e]=[])).push(t),++d};{const t=[],e=i.length;for(let s=0;s<e;++s){const n=i[s];if(n.setterType)g(n);else{const a=n.getTotalDuration();for(let r=0;r<e;++r){const e=i[r];if(s!==r&&n.attributeName===e.attributeName&&n.group.id<e.group.id&&n.fillReplace&&!e.evaluateEnd)if(e.setterType){if(n.delay===e.delay){t[s]=n;break}}else if(!e.evaluateStart&&!e.evaluateEnd&&(n.delay===e.delay&&(!e.fillReplace||-1===e.iterationCount||a<=e.getTotalDuration())||e.fillBackwards&&n.delay<=e.delay&&(e.fillForwards||n.fillReplace&&a<=e.delay)||n.animationElement&&!e.animationElement&&(n.delay>=e.delay&&a<=e.getTotalDuration()||e.fillForwards))){t[s]=n;break}}}}const s=[];for(let n=0;n<e;++n){const e=i[n];t[n]?e.fillReplace?s.push(e):(e.setterType=!0,g(e)):e.setterType||(h.push(e),f.add(e.group.name))}Me(c,s)}if(h.length+d>1||1===h.length&&(h[0].alternate||void 0!==h[0].end)){const e={},d={},g=new SvgAnimationIntervalMap(i),p={},m=new Map,y=t?new Map:null,v={},S=new Set,b={},k=new Map,T=t?new Map:null,A={},x={},E=new Map;let R=0,w=-1,V,_;for(let t=0,s=h.length;t<s;++t){const s=h[t],i=s.group.ordering;i&&ae(i,(t=>!f.has(t.name)));const n=s.attributeName;let a=e[n];a||(a=new Map,e[n]=a,d[n]=[]);const r=s.delay,o=a.get(r)||[];o.push(s),d[n].push(s),a.set(r,o)}for(const t in e){const s=new Map,i=e[t],n=re(Array.from(i.keys()));for(let t=0,e=n.length;t<e;++t){const e=n[t],a=i.get(e);for(let t=0,e=a.length;t<e;++t)R=Math.max(R,a[t].getTotalDuration(!0));s.set(e,a.reverse())}e[t]=s,d[t].reverse()}for(const i in e){const a=new Map;if(p[i]=a,!t){let t;s?t=s.getBaseValue(i):(t=this[i],void 0===t&&"getBaseValue"in this&&(t=this.getBaseValue(i))),te(t)&&(A[i]=t)}const r=u[i]||[],l=[],c=[];let h=[];for(const[t,s]of e[i])l.push(t),c.push(s);let f=-1,k=0,T=1/0,w,V=null,_;const P=(e,s)=>{if(S.add(e),e.addState(8),_=e,e.fillForwards){B(k,w,e.type,e);const{name:t,ordering:s}=e.group;if(s){const i=e.getTotalDuration();for(let e=0,n=s.length;e<n;++e){const n=s[e];if(n.name===t)return!0;if(SvgAnimationIntervalMap.getGroupEndTime(n)>=i)return!1}}}else{if(e.fillFreeze&&B(k,w,e.type,e),void 0!==s){let i=f;const n=N(k,k+1);void 0!==n&&e.fillReplace&&s>k&&0===h.length&&(i=Se(a,i,n),t&&de(E,e.type,i),w=n,f=i)}M()}return!1},N=(e,s)=>{var n;let o=null===(n=Ae(x,i))||void 0===n?void 0:n.value;return ae(r,(t=>t.delay>=e&&t.delay<s),(s=>{const i=s.to;s.animationElement&&Ve(h),0===h.length&&(w=i),B(s.delay,i,s.type,s),s.delay===e?o=t?i:ce(i):(f=xe(a,s,t),k=s.delay)})),o},M=(t,e)=>{h.length&&ae(h,(t=>t.getTotalDuration()<=k),(s=>{if(s.addState(8),s.fillForwards&&(B(s.getTotalDuration(),s.valueTo,s.type,s),void 0!==t&&void 0!==e))for(let i=t,n=l.length;i<n;++i){i!==t&&(e=-1);const n=c[i];for(let t=e+1,i=n.length;t<i;++t){const e=n[t];s.group.id>e.group.id&&e.addState(8)}}}))},B=(e,s,n=0,a)=>{if(te(s)){t||(s=ce(s));const a=Ae(x,i);(!a||e>=a.time)&&(x[i]||(x[i]=[])).push({key:n,value:s,time:e})}if(a&&SvgBuild.isAnimate(a)&&!a.fillReplace)if(a.fillForwards){ae(r,(t=>t.group.id<a.group.id||t.delay<e)),h=[];for(let t=0,e=c.length;t<e;++t){const e=c[t];for(let t=0,s=e.length;t<s;++t){const s=e[t];s.group.id<a.group.id&&s.addState(8)}}}else a.fillFreeze&&Ve(h)},C=(t,e,s)=>{V&&!t&&(void 0===s&&(s=z.typeAsValue(V.type)),f=Se(a,e,s),e!==f&&de(E,V.type,f)),V=null},G=d[i].find((t=>t.fillBackwards));if(G){w=ge(G,G.values,0,0),f=Se(a,0,w),t&&(de(E,G.type,0),V=G);let e=!0;for(const t of d[i])if(t.group.id>G.group.id&&t.delay<=G.delay){e=!1;break}const s=G.getTotalDuration(),n=[];for(let t=0;t<l.length;++t){const i=c[t];for(let a=0;a<i.length;++a){const o=i[a];if(e){if(o===G&&(0!==t||0!==a)){i.splice(a--,1),l.unshift(G.delay),c.unshift([G]);continue}if(o.group.id<G.group.id&&(G.fillForwards||o.getTotalDuration()<=s)){o.fillForwards&&(o.setterType=!0,r.push(o)),n.push(o);continue}}o.animationElement&&o.delay<=G.delay&&(i.splice(a--,1),Re(h,o))}}for(let t=0;t<l.length;++t){const e=c[t];if(n.length)for(let t=0;t<e.length;++t)n.includes(e[t])&&e.splice(t--,1);0===e.length&&(c.splice(t,1),l.splice(t--,1))}G.addState(1)}if(!t){const t=A[i];te(t)&&!x[i]&&B(0,t,0),null!=w||(w=(null===(n=Ae(x,i))||void 0===n?void 0:n.value)||t)}Ee(r);{let e;ae(r,(t=>t.delay<=l[0]),(s=>{const n=SvgBuild.isAnimate(s)&&s.fillForwards,r=s.delay;if(r<l[0]&&(!G||n))if(G&&n)B(r,s.to,s.type);else{const n=r-1;if(e)xe(a,e,t,n);else if(a.has(0))t||xe(a,s,t,n,w);else{const e=t&&SvgBuild.isAnimateTransform(s)?z.typeAsValue(s.type):A[i];void 0!==e&&(xe(a,s,t,0,e),xe(a,s,t,n,e))}f=xe(a,s,t),k=r,e=s}})),e&&xe(a,e,t,l[0]-1)}t:{for(let e=0,s=l.length;e<s;++e){let n=c[e],u=l[e];for(let d=0;d<n.length;++d){const p=n[d];if(p.hasState(8,32)||p.hasState(2)&&p.animationElement)continue;const v=-1===p.iterationCount,S=p.duration,_=p.iterationCount;let G,O,L;if(v)G=u+S;else if(G=p.getTotalDuration(),G<=f){p.fillReplace?p.addState(32):Re(h,p);continue}v?(O=Math.ceil((R-u)/S),L=0):(O=Math.ceil(_),L=_-Math.floor(_)),r.length&&k>0&&k<u&&N(k,u),-1!==f&&f<u&&(f=Se(a,u-1,w),k=u),T=1/0;const F=p.group.ordering;if(F&&F.length>1){let t=!0;for(let e=0,s=F.length;e<s;++e){const s=F[e];if(s.name===p.group.name){t=!1;break}if(!s.paused&&k<=s.delay&&s.attributes.includes(i))break}if(t)e:for(let t=e+1;t<s;++t){const e=c[t];for(let t=0,s=e.length;t<s;++t){const s=e[t];if(s.group.ordering){T=s.delay;break e}s.getTotalDuration()<=G?(s.fillFreeze&&Ee(r,s),s.addState(8)):s.delay<G&&Re(h,s)}}}else for(let t=e+1;t<s;++t){const e=l[t];if(e!==1/0){const s=c[t];if(s.length&&!s.every((t=>t.hasState(8,32)))){T=e;break}}}const I=k;let q=f+1,X=Math.min(T,p.end||1/0),D,Y,U;if(p.animationElement&&r.length){const e=Math.min(T,G,X);if(D=r.find((t=>t.delay>=k&&t.delay<=e))){switch(D.delay){case k:w=D.to,B(k,w,D.type,D),D.group.id>p.group.id&&(t&&V&&C(p.additiveSum,Math.max(u-1,f)),f=xe(a,D,t,Math.max(D.delay,f),w),X=-1);break;case T:D.addState(16);break;default:X=D.delay,D.addState(16)}ae(r,(t=>t!==D)),p.addState(2)}}if(X>f){t&&(V&&(C(p.additiveSum,Math.max(u-1,f)),q=f+1),w=z.typeAsValue(p.type),B(k,w,p.type));let r=u===1/0||(-1!==f||p.hasState(1))&&!(0===e&&0===d)||p.hasState(4);Y=!0;e:{const t=Ae(x,i);for(let e=Ie(k,u,S);e<O;++e){let i,l,c;if(p.evaluateStart||p.evaluateEnd){[i,l,c]=Fe(p);const t=n.length;if(p.evaluateStart){const s=h.concat(n.slice(d+1,t)).filter((t=>t.animationElement&&t.delay<X)),a=s.length;if(a){_e(s,k),[i,l,c]=ve(g,x,A,e,p,i,l,c,w,s,!0);for(let t=0;t<a;++t){const e=s[t];e.hasState(2)&&n.includes(e)&&Re(h,e)}}}if(p.evaluateEnd&&p.getIntervalEndTime(k)<X&&(h.length||d<t-1)){const s=h.filter((t=>t.animationElement));for(let e=d+1;e<t;++e){const t=n[e];t.animationElement&&(s.includes(t)||s.push(t),Re(h,t))}s.length&&(we(s,k),[i,l,c]=ve(g,x,A,e,p,i,l,c,w,s,!1))}ke(g,x,A,p,w,i,l,c)}else({keyTimes:i,values:l,keySplines:c}=p);for(let n=0,h=i.length;n<h;++n){const d=i[n];let g=-1,v=ge(p,l,e,n,w);if(e===O-1&&L>0)if(L===d)L=-1;else if(n===h-1)g=G,k=g,v=pe(L,i[n-1],ge(p,l,e,n-1,w),d,v),L=-1;else if(L>d)for(let t=n+1;t<h;++t)if(L<=i[t]){g=G,k=g,v=pe(L,d,v,i[t],ge(p,l,e,t,w)),L=-1;break}if(-1===g){if(g=Be(u,S,i,e,n),g<0||g<f)continue;if(g===X)Y=e===O-1&&n===h-1,k=g;else{const t=t=>[f,U]=me(p,k,w,i,l,c,u,e,n,t,o,a,m,y);if(u<0&&-1===f)g>0&&(k=0,t(0));else{if(g>X){r&&f+1<X&&t(f),k=X,t(X+(X!==T||a.has(X-1)?0:-1)),Y=!1;break e}if(r)p.hasState(1)&&(k=I),u>=f?(g=Math.max(u,f+1),k=u):g===f?(k=g,g=f+1):(t(f),k=Math.max(g,f)),r=!1;else{if(k=g,e>0&&0===n&&p.accumulateSum){be(p,g,c,n,o,m,y),f=g;continue}g=Math.max(g,f+1)}}}}if(g>f&&(n===s-1&&!p.accumulateSum&&(e<O-1||p.fillReplace&&(!t||v!==t.value))&&--g,f=Se(a,g,v),be(p,f,c,n,o,m,y),U=v),!Y||-1===L)break e}}}M(e,d)}if(void 0!==U&&(w=U,t&&(de(E,p.type,q,f),V=p)),D&&(D.hasState(16)?(U=D.to,f=xe(a,D,t,D.delay,U),k=D.delay,B(k,U,D.type,D)):p.hasState(32)&&de(E,f,D.type),Ve(h),Y=!0),ae(r,(t=>t.delay>=I&&t.delay<=k),(t=>{B(t.delay,t.to,t.type,t),t.animationElement&&Ve(h)})),v){if(!Y){h=[p];continue}if(!D){b[i]=p;break t}}if(Y){if(!v&&P(p,T))break t;for(let t=e;t<s;++t)if(l[t]<k){const e=c[t];for(let t=0,s=e.length;t<s;++t){const s=e[t],i=s.getTotalDuration();i>k&&!s.hasState(2,8,32)?Re(h,s):s.fillReplace||B(i,s.valueTo,s.type,s)}l[t]=1/0,e.length=0}if(h.length&&k<T){we(h);const t=h.find((t=>t.delay<=k));t&&(t.removeState(2,1),t.addState(4),Ve(h,t),u=t.delay,n=[t],d=-1)}}else Re(h,p)}}if(h.length)for(we(h);h.length;){const e=h.shift(),{delay:s,duration:n}=e,r=f-s;let l=1/0;const c=()=>{let[c,u,d]=Fe(e);const v=Ie(k,s,n);if(h.length){if(e.evaluateStart){const t=h.slice(0);_e(t,k),[c,u,d]=ve(g,x,A,v,e,c,u,d,w,t,!0)}e.evaluateEnd&&e.getIntervalEndTime(k)<l&&([c,u,d]=ve(g,x,A,v,e,c,u,d,w,h,!1))}ke(g,x,A,e,w,c,u,d);const S=f+1;let b=!1,T=Math.floor(r/n);const R=(t,n)=>me(e,k,w,c,u,d,s,T,t,n,o,p[i],m,y);do{for(let t=0,i=c.length;t<i;++t){let r=Be(s,n,c,T,t);if(!b&&r>=f&&([f,w]=R(t,f),b=!0),b)if(r>=l){if(l>f){const s=e.fillReplace||-1===e.iterationCount;[f,w]=R(t,l-(s?1:0)),s&&(w=ge(e,u,T,0,w),f=Se(a,l,w)),k=l}}else r>f&&(k=r,t===i-1&&r<l&&--r,w=ge(e,u,T,t,w),f=Se(a,r,w),be(e,f,d,t,o,m,y))}}while(f<l&&++T);t&&de(E,e.type,S,f)};if(-1===e.iterationCount){r>0&&r%e.duration!=0&&(l=s+e.duration*Math.ceil(r/n),c()),b[i]=e;break t}if(l=Math.min(s+e.duration*e.iterationCount,e.end||1/0),l>f&&(c(),P(e)))break t}if(_&&_.fillReplace&&!(i in b)){let e=0,s;if(x[i]){const t=Ae(x,i);t&&({key:e,value:s}=t)}else t?(e=Array.from(E.values()).pop(),s=z.typeAsValue(e)):s=A[i];void 0===s||ee(a.get(f),s)||(f=Se(a,f,s),t&&de(E,e,f))}}v[i]=f}{const e=new Set;let i=0;for(const t in p){let s=0;for(const i of p[t].keys())e.add(i),s=i;i=Math.max(i,s),null===(a=x[t])||void 0===a||a.sort(((t,e)=>t.time-e.time))}if(Jt(b)){const t=[],s=[];for(const e in b){const i=b[e];t.push(i.delay),s.push(i.duration)}const n=t[0];if(0===S.size&&1===new Set(t).size&&1===new Set(s).size&&n===e.values().next().value)w=n;else if(s.length>1&&s.every((t=>t%250==0)))i=Qt(s,i,t);else{const t=s[0];(i-n)%t!=0&&(i=t*Math.ceil(i/t))}}if(-1===w)for(const s in p){const n=b[s];if(n){let a=v[s];if(a<i){const r=p[s],l=n.delay,c=a+1;let h=Array.from(r.values()).pop();const[u,f,d]=Fe(n);ke(g,x,A,n,h,u,f,d);const S=u.length;let b=Math.floor((a-l)/n.duration);do{let t;for(let s=0;s<S;++s){let c=Be(l,n.duration,u,b,s);!t&&c>=a&&([a,h]=me(n,a,h,u,f,d,l,b,s,a,o,r,m,y),e.add(a),t=!0),t&&c>a&&(s===S-1&&c<i&&--c,h=ge(n,f,b,s,h),a=Se(r,c,h),be(n,c,d,s,o,m,y),e.add(a))}}while(a<i&&++b);v[s]=a,t&&de(E,n.type,c,a)}}}const n=re(Array.from(e));if(s||t){let t;for(const e in p){const s=p[e];if(!s.has(0)){const i=A[e];if(void 0!==i){const e=s.keys().next().value-1;s.set(0,i),s.set(e,i),n.includes(0)||(n.push(0),t=!0),n.includes(e)||(n.push(e),t=!0)}}}t&&re(n)}if(!t)for(const e in p){const s=p[e],i=s.keys().next().value,a=s.values().next().value;for(let r=0,o=n.length;r<o;++r){const o=n[r];if(!(o<=v[e]))break;if(!s.has(o)){if(g.paused(e,o))if(o<i)s.set(o,a);else{let t=g.get(e,o);if(void 0!==t&&(t=ce(t,!0),""!==t)){s.set(o,t);continue}}oe(s,e,o,g,t)}}}V=fe(p,n,x)}if(-1===w&&Jt(b)){const e={},s=[],i=[],n=[];for(const t in b){const e=b[t];n.push(e.duration),s.push(e)}const a=Qt(n);for(let t=0,n=s.length;t<n;++t){const n=s[t],l=n.attributeName;e[l]=new Map;let c=null!==(r=p[l].get(v[l]))&&void 0!==r?r:A[l];const[h,u,f]=Fe(n);ke(g,x,A,n,c,h,u,f);const d=h.length;let m=0,y=0;do{for(let t=0;t<d;++t){let s=Be(0,n.duration,h,y,t);t===h.length-1&&s<a&&--s,c=ge(n,u,y,t,c),m=Se(e[l],s,c),be(n,m,f,t,o,k,T),i.includes(m)||i.push(m)}++y}while(m<a)}if(s.every((t=>t.alternate))){let t=-1;for(const s in b){const n=e[s],r=Array.from(n.keys()),o=Array.from(n.values()).reverse();for(let e=0,s=r.length;e<s;++e){const s=r[e];if(0!==s){t=a+s;const r=k.get(s);r&&k.set(t,r),t=Se(n,t,o[e]),i.includes(t)||i.push(t)}}}}re(i);for(const s in e){const n=e[s];for(let e=0,a=i.length;e<a;++e){const a=i[e];n.has(a)||oe(n,s,a,g,t)}}_=fe(e,i,x)}if(V||_){Me(c,h);const e=Array.from(E),i=se(h,(t=>SvgBuild.isAnimateTransform(t)?z.typeAsName(t.type):t.attributeName),"-"),n=this.parent;for(const a of[V,_])if(a){const r=a===V,h=r?m:k,u=r?y:T;if(Ge(t,o)){const i=[];if(t){const t=[];if(r){const s=Array.from(a);let i=e[0][1];for(let n=0,a=0,r=0,o=e.length;n<o;++n){const l=n<o-1?e[n+1][1]:-1;if(i!==l){const o=new Map;for(let t=r,l=s.length;t<l;++t){const l=s[t][0];if(l>=e[a][0]&&l<=e[n][0])o.set(l,new Map([[i,s[t][1].values().next().value]])),r=t;else if(l>e[n][0])break}t.push(o),i=l,a=n+1}}}else{if(!b.transform)continue;{const e=new Map;for(const[t,s]of a)e.set(t,new Map([[b.transform.type,s.values().next().value]]));t.push(e)}}let s=0;for(let e=0,n=t.length;e<n;++e){const a=Array.from(t[e]),o=a[0];let l=o[0];const f=o[1];1===a.length&&(e<n-1?a.push([t[e+1].keys().next().value,f]):a.push([l+1,f]));const d=a.length,g=a[d-1][0];let p=g-l;const m=new SvgAnimateTransform;m.type=f.keys().next().value;for(let t=0;t<d;++t){const e=a[t];if(i.push(h.get(e[0])||""),m.type!==SVGTransform.SVG_TRANSFORM_ROTATE){const s=u.get(e[0]);s&&((m.transformOrigin||(m.transformOrigin=[]))[t]=s)}e[0]-=l}for(const[t,e]of le(a))m.keyTimes.push(t),m.values.push(e.values().next().value);l-=s,l>1?m.delay=l:1===l&&(p+1)%10==0&&++p,m.duration=p,m.keySplines=i,m.synchronized={key:e,value:""},s=g,Ne(c,m,r)}}else{const t=Array.from(a),e=-1!==w?w:0;let o;for(let s=0,n=t.length;s<n;++s){const n=t[s];i.push(h.get(n[0])||""),n[0]-=e}if(s){const e=ue(le(t),s,n,x,l);if(!e)continue;o=new SvgAnimate,o.attributeName="d";for(let t=0,s=e.length;t<s;++t){const s=e[t];o.keyTimes.push(s.key),o.values.push(s.value.toString())}}else{const t=new SvgAnimateTransform;t.type=SVGTransform.SVG_TRANSFORM_TRANSLATE;for(const[e,s]of a){const i=s.get("x")||0,a=s.get("y")||0;t.keyTimes.push(e),t.values.push(n?n.refitX(i)+" "+n.refitX(a):i+" "+a)}o=t}o.delay=e,o.keySplines=i,o.duration=ie(t)[0],Ne(c,o,r)}}else if(Oe(t,o)){const o=Array.from(a);for(let a=0,f=o.length-1;a<f;++a){const[f,d]=o[a],[g,p]=o[a+1];let m=i,y;if(t){const t=new SvgAnimateTransform;if(r)for(let s=0,i=e.length-1;s<i;++s){const i=e[s],n=e[s+1];if(i[1]===n[1]&&f>=i[0]&&g<=n[0]){t.type=i[1];break}if(g-f==1&&g===n[0]){t.type=n[1];break}}else b.transform&&(t.type=b.transform.type);if(0===t.type)continue;t.values=[d.values().next().value,p.values().next().value];const s=u.get(g);s&&(t.transformOrigin=[s]),y=t}else if(s){const t=ue([[f,d],[g,p]],s,n,x,l);if(!t)continue;y=new SvgAnimate,y.attributeName="d",y.values=ne(t,(t=>t.value.toString()))}else{const t=new SvgAnimateTransform;t.type=SVGTransform.SVG_TRANSFORM_TRANSLATE,t.values=[Pe(d,n),Pe(p,n)],m+=a,y=t}r&&(y.delay=0===a?f:0),y.duration=g-f,y.keyTimes=[0,1],y.synchronized={key:a,value:m};const v=h.get(g);v&&(y.keySplines=[v]),Ne(c,y,r)}}}}}}}};const{asPercent:ze,parseAngle:Xe}=squared.lib.css,{getNamedItem:De}=squared.lib.dom,{truncateFraction:Ye}=squared.lib.math,{isEqual:Ue,iterateArray:We,lastItemOf:$e}=squared.lib.util,Ke=(t,e,s,i)=>t&&t.key===e&&t.rotate===i&&Ue(t.value,s);class SvgAnimateMotion extends SvgAnimateTransform{constructor(t,e){if(super(t,e),this.path="",this.distance="0%",this.rotate="auto 0deg",this.motionPathElement=null,this.type=SVGTransform.SVG_TRANSFORM_TRANSLATE,this.instanceType=229384,this._offsetLength=0,this._keyPoints=[],this._offsetPath=null,e){this.setAttribute("path");const t=De(e,"rotate");switch(t){case"auto":break;case"auto-reverse":this.rotate="auto 180deg";break;default:{const e=+t;isNaN(e)||(this.rotate=e+"deg");break}}We(e.children,(t=>{if("mpath"===t.tagName.toLowerCase()){let e=W(t);if(e&&(I.use(e)&&(e=W(e)),e&&I.shape(e)))return this.motionPathElement=e,!0}})),this.setCalcMode()}else if(t){const e=/path\("([^"]+)"\)/.exec(Y(t,"offset-path"));e&&(this.path=e[1]);const s=Y(t,"offset-distance");s&&(this.distance=s);const i=Y(t,"offset-rotate");i&&"auto"!==i&&(this.rotate=i)}}setCalcMode(){const t=this.animationElement;if(t){const e=De(t,"calcMode")||"paced";switch(e){case"paced":case"discrete":case"spline":super.setCalcMode("translate",e);break;case"linear":{const e=SvgAnimateTransform.toFractionList(De(t,"keyPoints"),";",!1);let s=super.keyTimes;0===s.length&&-1!==this.duration&&(s=SvgAnimateTransform.toFractionList(De(t,"keyTimes")),this.length=0,super.keyTimes=s),e.length===s.length&&(this._keyPoints=e);break}}}}addKeyPoint(t){if(!this._offsetPath){const e=t.key;if(e>=0&&e<=1){const s=super.keyTimes,i=this._keyPoints;if(s.length===i.length){let n=ze(t.value)||parseFloat(t.value)/this.offsetLength;if(!isNaN(n)){n=Math.min(n,1);const a=s.indexOf(e);-1!==a?(s[a]=t.key,i[a]=n):(s.push(t.key),i.push(n))}}}}}setOffsetPath(){if(!this._offsetPath&&this.path){let t=SvgBuild.toOffsetPath(this.path,this.rotate),e=t.length;if(e){const{duration:s,keyPoints:i,rotateData:n,framesPerSecond:a}=this;let r=1;if(s>=e){r=s/e;const i=e-1;for(let e=1;e<i;++e)t[e].key*=r;t[i].key=s}else if(s>0){const i=new Array(s),n=e/s;let a;for(let e=0;e<s;++e)a=t[Math.floor(e*n)],a.key=e,i[e]=a;const r=$e(t);a.value!==r.value&&(r.key=s,i.push(r)),t=i,e=i.length}const o=a?1e3/a:0;if(i.length){const n=e-1,a=super.keyTimes,l=[];if(i.length>1){let e;for(let c=0,h=a.length-1;c<h;++c){const h=a[c],u=Ye(h*s),f=Ye((a[c+1]-h)*s),d=i[c],g=i[c+1];if(0===f){const s=u,{value:i,rotate:a}=t[Math.floor(g*n)];Ke(e,s,i,a)||(e={key:s,value:i,rotate:a},l.push(e))}else{let s=u,i=0;if(d===g){const{value:a,rotate:c}=t[Math.floor(d*n)];for(Ke(e,u,a,c)&&(i+=r,s+=o);i<f;i+=r){const t=u+i;t>=s&&(l.push({key:t,value:a,rotate:c}),i<f-1?s+=o:s=0)}}else{const a=Math.floor(Math.min(d,g)*n),r=Math.floor(Math.max(d,g)*n),c=[];for(let e=a;e<=r;++e)c.push(t[e]);d>g&&c.reverse();const h=c.length,p=f/h,m=c[0];for(Ke(e,u,m.value,m.rotate)&&(++i,s+=o);i<h;++i){const t=u+i*p;if(t>=s){const e=c[i];e.key=t,l.push(e),i<h-1?s+=o:s=0}}}$e(l).key=u+f}}}else l.push(t[Math.floor(i[0]*n)]),0===a[0]&&(l[0].rotate=0);this._offsetPath=l}else if(o>0){const s=[];for(let i=0;i<e;i+=o)s.push(t[Math.floor(i)]);const i=$e(t);$e(s)!==i&&s.push(i),this._offsetPath=s}else this._offsetPath=t;if(n){t=this._offsetPath;for(let e=0,i=0,a=n.length-1;e<a;++e){const a=n[e],r=n[e+1],o=r.key,l=[];if(a.key===o)l.push(t[i++]);else{const e=Math.floor(Ye(o*s));do{const s=t[i];if(!(s&&s.key<=e))break;l.push(s)}while(++i)}const c=a.value,h=r.value,u=Xe($e(c.split(" "))),f=Xe($e(h.split(" ")));if(isNaN(u)||isNaN(f))continue;const d=c.startsWith("auto");if(c===h||u===f){const t=l.length;if(d){if(0!==u)for(let e=0;e<t;++e)l[e].rotate+=u}else for(let e=0;e<t;++e)l[e].rotate=u}else{const t=f-u,e=l.length-1,s=t/e;if(d){for(let t=0;t<e;++t)l[t].rotate+=u+t*s;l[e].rotate+=u+t}else{for(let t=0;t<e;++t)l[t].rotate=u+t*s;l[e].rotate=u+t}}}}this.keySplines=null,this.timingFunction=SvgAnimateTransform.KEYSPLINE_NAME.linear}}}reverseKeyPoints(){let t,e;return this.validKeyPoints()&&(e=this._keyPoints.slice(0).reverse(),t=super.keyTimes.map((t=>1-t)).reverse()),{keyTimes:t,keyPoints:e}}validKeyPoints(){const t=this.keyPoints;return t.length>0&&t.length===super.keyTimes.length}set keyTimes(t){this.path||(super.keyTimes=t)}get keyTimes(){this.setOffsetPath();const t=this._offsetPath;if(t){const e=this.duration;return t.map((t=>t.key/e))}return super.keyTimes}set values(t){this.path||(super.values=t)}get values(){return this.setOffsetPath(),this._offsetPath?this._offsetPath.map((t=>t.value.x+" "+t.value.y)):super.values}set reverse(t){if(t!==this._reverse){const{keyTimes:e,keyPoints:s}=this.reverseKeyPoints();e&&s&&(this.length=0,this._keyPoints=s,super.keyTimes=e,super.reverse=t)}}get reverse(){return this._reverse}set alternate(t){const e=this.iterationCount;if(t!==this._alternate&&(-1===e||e>1)){const{keyTimes:s,keyPoints:i}=this.reverseKeyPoints();if(s&&i){const n=super.keyTimes.slice(0),a=this.keyPoints.slice(0),r=n.length;if(-1===e){for(let t=0;t<r;++t)n[t]/=2,s[t]=.5+s[t]/2;n.push(...s),a.push(...i),this.duration*=2}else{for(let t=0;t<e;++t)if(0===t)for(let t=0;t<r;++t)n[t]/=e;else{const o=t*(1/e),l=t%2==0?super.keyTimes.slice(0):s.slice(0);for(let t=0;t<r;++t)l[t]=Ye(o+l[t]/e);n.push(...l),a.push(...t%2==0?this.keyPoints.slice(0):i)}this.duration=this.duration*e,this.iterationCount=1}this._keyTimes=n,this._keyPoints=a,this._alternate=t}}}get alternate(){return this._alternate}set parent(t){this._parent=t;const e=this.parentContainer;e&&e.requireRefit&&this.path&&(this.path=SvgBuild.transformRefit(this.path,{container:e}))}get parent(){return this._parent}get offsetPath(){return this._offsetPath}get playable(){return!this.paused&&-1!==this.duration&&!!this.path}get rotateValues(){return this.setOffsetPath(),this._offsetPath&&this._offsetPath.map((t=>t.rotate))}get keyPoints(){return this._keyPoints}get offsetLength(){return 0===this._offsetLength&&this.path?Q(this.path):this._offsetLength}}var je=squared.lib.base.Pattern;const{STRING:He}=squared.lib.regex,{asPercent:Ze,hasCalc:Qe,isAngle:Je,hasCustomProperty:ts,parseAngle:es,parseVar:ss}=squared.lib.css,{getNamedItem:is}=squared.lib.dom,{convertCamelCase:ns,convertWord:as,iterateArray:rs,splitEnclosing:os,splitPairEnd:ls,spliceString:cs,startsWith:hs}=squared.lib.util,{getKeyframesRules:us}=squared.base.lib.css,fs=new je(`(ease|ease-(?:in|out|in-out)|linear|step-(?:start|end)|steps\\(\\d+,\\s*(?:start|end|jump-(?:start|end|both|none))\\)|cubic-bezier\\(${F}\\))\\s*,?`),ds={"animation-delay":"0s","animation-duration":"0s","animation-iteration-count":"1","animation-play-state":"running","animation-direction":"normal","animation-fill-mode":"none","animation-timing-function":"ease"},gs=new RegExp(He.PERCENT,"g");function ps(t,e){const s=Y(t,e);if("animation-timing-function"===e){const t=[];for(fs.matcher(s);fs.find();)t.push(fs.group(1));return t}return s.split(/\s*,\s*/)}function ms(t){if(hs(t,"reverse")){const e=ls(t," ");return`auto ${e?Je(e)?180+es(e,0):"0":"180"}deg`}return t}function ys(t,e,s){var i;const n=null===(i=t["transform-origin"])||void 0===i?void 0:i.find((t=>t.key===s));if(n)return z.origin(e,n.value)}function vs(t,e,s){var i;if(s){const i=t.querySelector(`:scope > ${e}[lang="${s}"]`);if(i)return i.textContent.trim()||""}return(null===(i=t.querySelector(`:scope > ${e}`))||void 0===i?void 0:i.textContent.trim())||""}const Ss=t=>t.sort(((t,e)=>t.key-e.key));var bs=t=>class extends t{constructor(){super(...arguments),this.transformed=null,this._transforms=null,this._animations=null,this._name=null}getTransforms(t=this.element){return SvgBuild.filterTransforms(z.parse(t)||SvgBuild.convertTransforms(t.transform.baseVal))}getAnimations(t=this.element){var e,s,i,n;const a=[];let r=0;const o=(t,e,s="")=>{s||++r,t.delay=e,t.group={id:r,name:s},t.parent=this,a.push(t)};rs(t.children,(e=>{var s;if(e instanceof SVGAnimationElement){const i=is(e,"begin");let n;if(i){if(n=SvgAnimation.getClockTimes(i),0===n.length)return}else n=[0];const a=null===(s=this.viewport)||void 0===s?void 0:s.precision;switch(e.tagName.toLowerCase()){case"set":n.forEach((s=>o(new SvgAnimation(t,e),s)));break;case"animate":n.forEach((s=>o(new SvgAnimate(t,e),s)));break;case"animatetransform":for(const s of n){const i=new SvgAnimateTransform(t,e);SvgBuild.isShape(this)&&this.path&&(i.transformFrom=SvgBuild.drawRefit(t,this.parent,a)),o(i,s)}break;case"animatemotion":for(const s of n){const i=new SvgAnimateMotion(t,e),n=i.motionPathElement;n&&(i.path=SvgBuild.drawRefit(n,this.parent,a)),o(i,s)}}}}));const l=ps(t,"animation-name"),c=l.length;if(0===c)return a;const h=(null===(e=this.viewport)||void 0===e?void 0:e.keyframesMap)||us(),u={},f=[],d=[];for(const e in ds){const s=ps(t,e);for(0===s.length&&s.push(ds[e]);s.length<c;)s.push(...s.slice(0));s.length=c,u[e]=s}for(let e=0;e<c;++e){const a=h.get(l[e]),c=SvgAnimation.parseClockTime(u["animation-duration"][e]);if(a&&!isNaN(c)&&c>0){++r;const h={},g={},p="paused"===u["animation-play-state"][e],m=SvgAnimation.parseClockTime(u["animation-delay"][e])||0,y=u["animation-iteration-count"][e],v=u["animation-fill-mode"][e],S=l[e]+"_"+e,b=[];let k=!0;d.push({name:S,attributes:b,paused:p,delay:m,duration:c,iterationCount:y,fillMode:v});for(const e in a){const s=Ze(e),i=a[e];for(const e in i){let n=i[e];if(-1!==n.indexOf("%")){const t=os(n);let e;for(let s=0;s<t.length;s+=2){let i=t[s];for(;e=gs.exec(i);){const t=`calc(${e[0]})`;i=cs(i,e.index,e[0].length,t),gs.lastIndex=e.index+t.length}t[s]=i,gs.lastIndex=0}n=t.join("")}if(Qe(n)?n=D(t,ns(e),n):ts(n)&&(n=ss(t,n)),n){const t=ds[e]?g:h;(t[e]||(t[e]=[])).push({key:s,value:n})}}}if(h.transform){const e=Ss(h.transform);for(let i=0,n=e.length;i<n;++i){const n=e[i],a=n.key,r=ys(h,t,a)||z.origin(t);null===(s=z.parse(t,n.value))||void 0===s||s.forEach((t=>{const e=t.matrix;let s,i,n;switch(t.type){case SVGTransform.SVG_TRANSFORM_TRANSLATE:s="translate",i=e.e+" "+e.f;break;case SVGTransform.SVG_TRANSFORM_SCALE:s="scale",i=e.a+" "+e.d+" "+(r?r.x+" "+r.y:"0 0"),!r||0===a&&0===r.x&&0===r.y||(n={x:r.x*(1-e.a),y:r.y*(1-e.d)});break;case SVGTransform.SVG_TRANSFORM_ROTATE:s="rotate",i=t.angle+" "+(r?r.x+" "+r.y:"0 0");break;case SVGTransform.SVG_TRANSFORM_SKEWX:s="skewX",i=t.angle.toString(),!r||0===a&&0===r.y||(n={x:r.y*e.c*-1,y:0});break;case SVGTransform.SVG_TRANSFORM_SKEWY:s="skewY",i=t.angle.toString(),!r||0===a&&0===r.x||(n={x:0,y:r.x*e.b*-1});break;default:return}const o=h[s]||(h[s]=[]),l=o.findIndex((t=>t.key===a));if(-1!==l){const t=o[l];t.value=i,t.transformOrigin=n}else o.push({key:a,value:i,transformOrigin:n})}))}delete h.transform,delete h["transform-origin"]}if("none"===Y(t,"offset-path"))delete h["offset-distance"],delete h["offset-rotate"];else if(h["offset-rotate"]){const e=h["offset-rotate"];if(h["offset-distance"]||!h.rotate){let s=Y(t,"offset-rotate");s&&"auto"!==s||(s="auto 0deg"),Ss(e);const i=e[0],n=e[e.length-1];0!==i.key&&e.unshift({key:0,value:s}),1!==n.key&&e.push({key:1,value:s});for(let t=1;t<e.length;++t){const s=e[t-1],i=e[t],n=ms(s.value),a=ms(i.value);if(s.value=n,i.value=a,n.split(" ").pop()!==a.split(" ").pop()){const r=hs(n,"auto"),o=hs(a,"auto");if(r&&!o||!r&&o){const r=(s.key+i.key)/2;e.splice(t++,0,{key:r,value:n}),e.splice(t++,0,{key:r,value:a})}}}if(!h["offset-distance"]){const s=new SvgAnimateMotion(t);s.duration=0,s.iterationCount=1,s.fillForwards=!0,s.addKeyPoint({key:0,value:s.distance}),o(s,m,S);for(let t=0,s=e.length;t<s;++t){const s=e[t];s.value=es(s.value.split(" ").pop(),0)+(hs(s.value,"auto")?90:0)+" 0 0"}h.rotate=e,delete h["offset-rotate"],k=!1}}else delete h["offset-rotate"]}for(const s in h){let a;switch(s){case"offset-rotate":continue;case"offset-distance":a=new SvgAnimateMotion(t),a.rotateData=h["offset-rotate"];break;case"rotate":case"scale":case"skewX":case"skewY":case"translate":a=new SvgAnimateTransform(t),a.setType(s);break;default:a=new SvgAnimate(t),a.attributeName=s}o(a,m,S);const r=h[s],l=u["animation-direction"][e],d=u["animation-timing-function"][e],T=r.length;if(Ss(r),"offset-distance"===s){const t=a;0!==r[0].key&&t.addKeyPoint({key:0,value:t.distance});for(let e=0;e<T;++e)t.addKeyPoint(r[e]);1!==r.pop().key&&t.addKeyPoint({key:1,value:t.distance}),d&&(t.timingFunction=d)}else{b.push(s);const e=[],o=new Array(T),l=new Array(T);for(let t=0;t<T;++t){const s=r[t],{key:c,value:h}=s;o[t]=c,l[t]=h,k&&t<T-1&&e.push((null===(n=null===(i=g["animation-timing-function"])||void 0===i?void 0:i.find((t=>t.key===c)))||void 0===n?void 0:n.value)||d);const u=s.transformOrigin;u&&SvgBuild.asAnimateTransform(a)&&((a.transformOrigin||(a.transformOrigin=[]))[t]=u)}if(k&&!e.every((t=>"linear"===t))){const i=[],n=[],r=[];for(let a=0,h=o.length;a<h;++a){const u=o[a],f=l[a];if(a<h-1){const h=e[a];if(f&&hs(h,"step")){const e=SvgAnimate.fromStepTimingFunction(t,s,h,o,l,a);if(e){const[t,s]=e,l=(o[a+1]-u)*c,f=t.length-(1===o[a+1]?1:0);for(let e=0;e<f;++e){let a=(u+t[e]*l)/c;i.includes(a)&&(a+=.001),i.push(a),n.push(s[e]),r.push(SvgAnimate.KEYSPLINE_NAME[-1!==h.indexOf("start")?"step-start":"step-end"])}continue}}r.push(SvgAnimate.findTimingFunction(h))}i.push(u),n.push(f)}a.values=n,a.keyTimes=i,a.keySplines=r}else a.values=l,a.keyTimes=o,k?a.keySplines=e:a.timingFunction=d}a.paused=p,a.duration=c,a.iterationCount="infinite"!==y?+y:-1,a.fillForwards="forwards"===v||"both"===v,a.fillBackwards="backwards"===v||"both"===v,a.reverse=l.endsWith("reverse"),a.alternate=(-1===a.iterationCount||a.iterationCount>1)&&hs(l,"alternate"),f.push(a)}}}d.reverse();for(let t=0,e=f.length;t<e;++t)f[t].setGroupOrdering(d);return a}getTitle(t){return vs(this.element,"title",t)}getDesc(t){return!t&&is(this.element,"aria-describedby")||vs(this.element,"desc",t)}set name(t){this._name=t}get name(){let t=this._name;if(null===t){const e=this.element;let s=e.id.trim(),i,n;s?(s=as(s),L.has(s)||(i=s),n=s):n=e.tagName.toLowerCase();let a=L.get(n)||0;i?(L.set(i,a),t=i):(L.set(n,++a),t=n+"_"+a),this._name=t}return t}get transforms(){return this._transforms||(this._transforms=this.getTransforms())}get animations(){return this._animations||(this._animations=this.getAnimations())}get visible(){const t=Y(this.element,"visibility");return"hidden"!==t&&"collapse"!==t&&"none"!==Y(this.element,"display")}get opacity(){return Y(this.element,"opacity")||"1"}};const{isUserAgent:ks}=squared.lib.client;function Ts(t){if("svg"===t.tagName.toLowerCase()){if(ks(4))return t.parentElement instanceof HTMLElement;if(ks(2))return!(t.parentElement instanceof HTMLElement)}return!1}var As=t=>class extends t{constructor(){super(...arguments),this._x=NaN,this._y=NaN,this._width=NaN,this._height=NaN}setRect(){const t=this.parent;let{x:e,y:s,width:i,height:n}=this;t&&(e=t.refitX(e),s=t.refitY(s),i=t.refitSize(i),n=t.refitSize(n)),this.setBaseValue("x",e),this.setBaseValue("y",s),this.setBaseValue("width",i),this.setBaseValue("height",n)}getRectElement(){const t=this.rectElement||this.element;switch(t.tagName.toLowerCase()){case"svg":case"use":case"image":return t}return null}set x(t){this._x=t}get x(){var t;return isNaN(this._x)?(null===(t=this.getRectElement())||void 0===t?void 0:t.x.baseVal.value)||0:this._x}set y(t){this._y=t}get y(){var t;return isNaN(this._y)?(null===(t=this.getRectElement())||void 0===t?void 0:t.y.baseVal.value)||0:this._y}set width(t){this._width=t}get width(){if(isNaN(this._width)){const t=this.getRectElement();return t?Ts(t)?t.getBoundingClientRect().width:t.width.baseVal.value:0}return this._width}set height(t){this._height=t}get height(){if(isNaN(this._height)){const t=this.getRectElement();return t?Ts(t)?t.getBoundingClientRect().height:t.height.baseVal.value:0}return this._height}};const{isLength:xs}=squared.lib.css,{cloneObject:Es,iterateArray:Rs}=squared.lib.util;function ws(t,e,s,i){if(t){const n=e.aspectRatio,a=t.aspectRatio;if(s&&i){Es(s,{target:n});const{width:e,height:r}=n;if(e>0&&r>0){const s=e/r;let o=a.width||t.viewBox.width,l=a.height||t.viewBox.height,c=NaN,h=NaN,u;0===o&&0===l&&(({width:o,height:l}=X(t.element)),a.width=o,a.height=l,u=!0);const f=o/l,d=o/e,g=l/r,p=Y(i,"width"),m=Y(i,"height");if(u)c=o,h=l;else{if(I.svg(i))try{c=i.width.baseVal.value,h=i.height.baseVal.value}catch(t){}c||h||(c=+p,h=+m)}const y=xs(p,!0),v=xs(m,!0),S=c/e,b=h/r;let k=y&&v;if(c>=e&&h>=r?(n.unit=Math.min(S,b),k=!1):(d!==g||u)&&(n.unit=Math.min(d,g)),y||v){if(c&&h){const{align:t,meetOrSlice:s}=i.preserveAspectRatio.baseVal;if(S===b)k&&(n.unit*=S),n.align=SVGPreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMIN,e>r?n.alignX=!0:n.alignY=!0;else{switch(s){case SVGPreserveAspectRatio.SVG_MEETORSLICE_MEET:b<S?(k&&(r>=e&&r>=l?n.unit=b:n.unit*=b),n.alignX=!0):(k&&(e>=r&&e>=o?n.unit=S:n.unit*=S),n.alignY=!0);break;case SVGPreserveAspectRatio.SVG_MEETORSLICE_SLICE:b>S?(k&&(r>=e&&r>=l?n.unit=b:n.unit*=b),n.alignX=!0,n.alignY=r>l):(k&&(e>=r&&e>=o?n.unit=S:n.unit*=S),n.alignX=e>o,n.alignY=!0)}n.align=t}n.meetOrSlice=s}}else f>s?n.position.x=(o-l*s)/2:f<s&&(n.position.y=(l-o*(1/s))/2)}}const{parent:r,position:o,unit:l,x:c,y:h}=a;n.parent.x=c+c*(l-1),n.position.x*=a.unit,n.position.x+=o.x-r.x,n.parent.y=h+h*(l-1),n.position.y*=l,n.position.y+=o.y-r.y,n.unit*=l}}function Vs(t){do{if(SvgBuild.asSvg(t)&&t.documentRoot)return t;t=t.parent}while(t);return null}function _s(t){do{if(t.hasViewBox())return t;t=t.parent}while(t)}class SvgContainer extends squared.lib.base.Container{constructor(t){super(),this.element=t,this.parent=null,this.viewport=null,this.instanceType=2,this.aspectRatio={x:0,y:0,width:0,height:0,position:{x:0,y:0},parent:{x:0,y:0},unit:1,meetOrSlice:SVGPreserveAspectRatio.SVG_MEETORSLICE_UNKNOWN,align:SVGPreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMIN,alignX:!1,alignY:!1},this._clipRegion=[]}add(t,e){return t.parent=this,t.viewport=e||Vs(this),super.add(t)}build(t){let e=!0,s,i;t?(s=t.targetElement||this.element,i=t.precision,"targetElement"in(t=Object.assign({},t))&&delete t.targetElement,!1===t.initialize&&(e=!1)):s=this.element;const n=Vs(this);let a,r=null;n&&(({element:a,contentMap:r}=n),void 0===i&&(i=n.precision));const o=_s(this),l=this.aspectRatio;let c;if(this.clear(),Rs(s.children,(s=>{let i;if(I.svg(s))i=new squared.svg.Svg(s,!1),ws(o,i,s.viewBox.baseVal,s),c=!0;else if(I.g(s))i=new squared.svg.SvgG(s),ws(o,i);else if(I.use(s)){const t=W(s,a,r);if(t)if(I.symbol(t))i=new squared.svg.SvgUseSymbol(t,s),ws(o,i,t.viewBox.baseVal,t),c=!0;else if(I.g(t))i=new squared.svg.SvgUseG(t,s),ws(o,i);else if(I.image(t))i=new squared.svg.SvgImage(s,t);else if(I.shape(t)){const a=n&&n.findFill(s);a?(i=new squared.svg.SvgUseShapePattern(t,s,a),ws(o,i)):i=new squared.svg.SvgUseShape(t,s,e)}}else if(I.image(s))i=new squared.svg.SvgImage(s);else if(I.shape(s)){const t=n&&n.findFill(s);t?(i=new squared.svg.SvgShapePattern(s,t),ws(o,i)):i=new squared.svg.SvgShape(s,e)}i&&(this.add(i,n),i.build(t))})),SvgBuild.asSvg(this)&&(this.documentRoot||l.meetOrSlice))if(this.documentRoot)(l.x<0||l.y<0)&&this.clipViewBox(l.x,l.y,l.width,l.height,i,!0);else{const{x:t,y:e}=this.parent.aspectRatio;this.clipViewBox(t,e,this.width+t,this.height+e,i,!0)}else if(c&&this.hasViewBox()&&(0!==l.x||0!==l.y)){const{left:t,top:e}=SvgBuild.boxRectOf(this.getPathAll(!1)),s=this.refitX(l.x),n=this.refitY(l.y);(t<s||e<n)&&this.clipViewBox(t,e,this.refitSize(l.width),this.refitSize(l.height),i)}}hasViewBox(){return SvgBuild.asSvg(this)&&(!!this.element.viewBox.baseVal||this.documentRoot)||SvgBuild.asUseSymbol(this)&&!!this.symbolElement.viewBox.baseVal}clipViewBox(t,e,s,i,n,a){a&&(s-=t,i-=e,SvgBuild.asSvg(this)&&this.documentRoot?(t=t<0?-1*t:0,e=e<0?-1*e:0):(t*=-1,e*=-1)),this.clipRegion=SvgBuild.drawRect(s,i,t,e,n)}synchronize(t){this.each((e=>e.synchronize(t)))}refitX(t){const e=this.aspectRatio;return(t-e.x)*e.unit-e.parent.x+e.position.x}refitY(t){const e=this.aspectRatio;return(t-e.y)*e.unit-e.parent.y+e.position.y}refitSize(t){return t*this.aspectRatio.unit}refitPoints(t){const e=this.aspectRatio.unit,s=t.length;for(let i=0;i<s;++i){const s=t[i];s.x=this.refitX(s.x),s.y=this.refitY(s.y),void 0!==s.rx&&void 0!==s.ry&&(s.rx*=e,s.ry*=e)}if(SvgBuild.asSvg(this)&&this.aspectRatio.meetOrSlice){const{align:e,alignX:i,alignY:n,parent:a}=this.aspectRatio,{width:r,height:o}=this,{top:l,right:c,bottom:h,left:u}=SvgBuild.minMaxOf(t,!0);let f=0,d=0;i&&(f=-1*a.x),n&&(d=-1*a.y);let g=f,p=d;const m=()=>r/2-(c+u)/2,y=()=>r-u-c+f,v=()=>o/2-(l+h)/2,S=()=>o-l-h+d;switch(e){case SVGPreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMIN:i&&(g-=f),n&&(p-=d);break;case SVGPreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMID:i&&(g-=f),n&&(p+=v());break;case SVGPreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMAX:i&&(g-=f),n&&(p+=S());break;case SVGPreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMIN:i&&(g+=m()),n&&(p-=d);break;case SVGPreserveAspectRatio.SVG_PRESERVEASPECTRATIO_NONE:case SVGPreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMID:i&&(g+=m()),n&&(p+=v());break;case SVGPreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMAX:i&&(g+=m()),n&&(p+=S());break;case SVGPreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMIN:i&&(g+=y()),n&&(p-=d);break;case SVGPreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMID:i&&(g+=y()),n&&(p+=v());break;case SVGPreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMAX:i&&(g+=y()),n&&(p+=S())}for(let e=0;e<s;++e){const s=t[e];s.x+=g,s.y+=p}}return t}getPathAll(t=!0){var e;const s=[];for(const i of t?this.cascade():this.children)if(SvgBuild.isShape(i)){const t=null===(e=i.path)||void 0===e?void 0:e.value;t&&s.push(t)}return s}set clipRegion(t){t?this._clipRegion.push(t):this._clipRegion=[]}get clipRegion(){return this._clipRegion.join(";")}get requireRefit(){const t=this.aspectRatio;return 0!==t.x||0!==t.y||1!==t.unit||0!==t.position.x||0!==t.position.y||0!==t.parent.x||0!==t.parent.y}}const{parseColor:Ps}=squared.lib.color,{extractURL:Ns}=squared.lib.css,{getNamedItem:Ms}=squared.lib.dom,{cloneObject:Bs}=squared.lib.util,{getKeyframesRules:Cs}=squared.base.lib.css;function Gs(t){const e=[],s=t.getElementsByTagName("stop");for(let t=0,i=s.length;t<i;++t){const i=s[t],n=Ps(Ms(i,"stop-color"),+(Ms(i,"stop-opacity")||"1"));n&&e.push({color:n,offset:parseFloat(Ms(i,"offset"))/100})}return e}function Os(t,...e){const s={};for(let i=0,n=e.length;i<n;++i){const n=e[i],a=t[n];a&&(s[n]=a.baseVal.value,s[n+"AsString"]=a.baseVal.valueAsString)}return s}function Ls(t){return Object.assign({type:"linear",element:t,spreadMethod:t.spreadMethod.baseVal,colorStops:Gs(t),dimension:null},Os(t,"x1","x2","y1","y2"))}function Fs(t){return Object.assign({type:"radial",element:t,spreadMethod:t.spreadMethod.baseVal,colorStops:Gs(t),dimension:null},Os(t,"cx","cy","r","fx","fy","fr"))}class Svg extends(qe(As(vt(bs(SvgContainer))))){constructor(t,e=!0){super(t),this.element=t,this.documentRoot=e,this.instanceType=18,this.definitions={clipPath:new Map,pattern:new Map,gradient:new Map,contentMap:null},e&&(this.viewport=this),this.init()}build(t){this.documentRoot&&(this.keyframesMap=t.keyframesMap||Cs()),this.precision=t.precision,this.setRect(),super.build(t)}synchronize(t){!this.documentRoot&&this.animations.length&&this.animateSequentially(this.getAnimateViewRect(),this.getAnimateTransform(t),void 0,t),super.synchronize(t)}findFill(t){if("string"!=typeof t&&(t=Ns(U(t,"fill"))||""),t){const e=this.definitions.pattern.get(t);if(e)return e;const s=document.getElementById(t.substring(1));if(s instanceof SVGPatternElement)return s}}findFillPattern(t){let e;if("string"!=typeof t&&(t=Ns(U(t,"fillPattern"))||""),t&&(e=this.definitions.gradient.get(t),!e)){const s=document.getElementById(t.substring(1));s&&(I.linearGradient(s)?e=Ls(s):I.radialGradient(s)&&(e=Fs(s)),e&&this.definitions.gradient.set(t,e))}return e}init(){const t=this.element;this.documentRoot&&(Bs(t.viewBox.baseVal,{target:this.aspectRatio}),t.querySelectorAll("set, animate, animateTransform, animateMotion").forEach((e=>{const s=W(e,t);if(s){const t=e.parentElement;t&&t.removeChild(e),s.appendChild(e)}}))),this.setDefinitions(t),t.querySelectorAll("defs").forEach((t=>this.setDefinitions(t)))}setDefinitions(t){const e=this.definitions;t.querySelectorAll("clipPath[id], pattern[id], linearGradient[id], radialGradient[id]").forEach((t=>{const s="#"+t.id;I.clipPath(t)?e.clipPath.has(s)||e.clipPath.set(s,t):I.pattern(t)?e.pattern.has(s)||e.pattern.set(s,t):I.linearGradient(t)?e.gradient.has(s)||e.gradient.set(s,Ls(t)):I.radialGradient(t)&&(e.gradient.has(s)||e.gradient.set(s,Fs(t)))}))}set contentMap(t){this.definitions.contentMap=t}get contentMap(){return this.definitions.contentMap}get viewBox(){return this.element.viewBox.baseVal||{x:0,y:0,width:0,height:0}}}class SvgElement{constructor(t){this.element=t,this.parent=null,this.viewport=null,this.instanceType=4}build(t){}synchronize(t){}}const{STRING:Is}=squared.lib.regex,{parseColor:qs}=squared.lib.color,{asPercent:zs,extractURL:Xs,getFontSize:Ds,getStyle:Ys,hasCalc:Us,hasEm:Ws,hasCustomProperty:$s,isLength:Ks,parseUnit:js,parseVar:Hs}=squared.lib.css,{truncate:Zs}=squared.lib.math,{convertCamelCase:Qs,splitSome:Js}=squared.lib.util,ti={polygon:/polygon\(([^)]+)\)/,inset:new RegExp(`inset\\(${Is.LENGTH_PERCENTAGE}\\s?${Is.LENGTH_PERCENTAGE}?\\s?${Is.LENGTH_PERCENTAGE}?\\s?${Is.LENGTH_PERCENTAGE}?\\)`),circle:new RegExp(`circle\\(${Is.LENGTH_PERCENTAGE}(?:\\s+at\\s+${Is.LENGTH_PERCENTAGE}\\s+${Is.LENGTH_PERCENTAGE})?\\)`),ellipse:new RegExp(`ellipse\\(${Is.LENGTH_PERCENTAGE}\\s+${Is.LENGTH_PERCENTAGE}(?:\\s+at\\s+${Is.LENGTH_PERCENTAGE}\\s+${Is.LENGTH_PERCENTAGE})?\\)`)};var ei=t=>class extends t{constructor(){super(...arguments),this.fill="",this.fillPattern="",this.fillOpacity="",this.fillRule="",this.stroke="",this.strokePattern="",this.strokeOpacity="",this.strokeLinecap="",this.strokeLinejoin="",this.strokeMiterlimit="",this.strokeDasharray="",this.strokeDashoffset="",this.color="",this.clipPath="",this.clipRule="",this._strokeWidth=""}setStroke(){this.setAttribute("stroke"),this.setAttribute("stroke-width")}setPaint(t,e){this.resetPaint(),this.setAttribute("color"),this.setAttribute("fill"),this.setAttribute("fill-opacity"),this.setAttribute("fill-rule"),this.setStroke(),this.setAttribute("stroke-opacity"),this.setAttribute("stroke-linecap"),this.setAttribute("stroke-linejoin"),this.setAttribute("stroke-miterlimit"),this.setAttribute("stroke-dasharray"),this.setAttribute("stroke-dashoffset"),this.setAttribute("clip-rule");const s=this.getAttribute("clip-path");if(s&&"none"!==s){const i=Xs(s);if(i)this.clipPath=i;else if(t&&t.length)for(const i in ti){const n=ti[i].exec(s);if(n){const{top:s,right:a,bottom:r,left:o}=SvgBuild.boxRectOf(t),l=a-o,c=r-s,h=this.parent;switch(i){case"inset":{let t=0,i=this.convertLength(n[1],c),u=0,f=0;n[4]?(t=o+this.convertLength(n[4],l),u=a-this.convertLength(n[2],l),f=r-this.convertLength(n[3],c)):n[2]?(t=this.convertLength(n[2],l),u=a-t,f=r-(n[3]?this.convertLength(n[3],c):i),t+=o):(t=o+i,u=a-i,f=r-i),i+=s;const d=[{x:t,y:i},{x:u,y:i},{x:u,y:f},{x:t,y:f}];h&&h.refitPoints(d),this.clipPath=SvgBuild.drawPolygon(d,e);break}case"polygon":{const t=[];Js(n[1],(e=>{let i=o,n=s;e.split(/\s+/).forEach(((t,e)=>{0===e?i+=this.convertLength(t,l):n+=this.convertLength(t,c)})),t.push({x:i,y:n})})),h&&h.refitPoints(t),this.clipPath=SvgBuild.drawPolygon(t,e);break}default:if("circle"===i||"ellipse"===i){const t=l<c?l:c;let a,r;"circle"===i?(a=this.convertLength(n[1],t),r=a):(a=this.convertLength(n[1],l),r=this.convertLength(n[2],c));let u=o,f=s;const d=n.length;d>=4&&(u+=this.convertLength(n[d-2],t),f+=this.convertLength(n[d-1],t)),h&&(u=h.refitX(u),f=h.refitX(f),a=h.refitSize(a),r=h.refitSize(r)),this.clipPath=SvgBuild.drawEllipse(u,f,a,r,e)}}break}}}}setAttribute(t){const e=this.element;let s=this.getAttribute(t);if(s){switch(t=Qs(t),Us(s)?s=D(e,t,s)||Ys(e)[t]:$s(s)&&(s=Hs(e,s)||Ys(e)[t]),t){case"strokeDasharray":if("none"===s)return;{let t="";Js(s,(e=>{t+=(t?", ":"")+this.convertLength(e)})),s=t}break;case"strokeDashoffset":case"strokeWidth":s=this.convertLength(s).toString();break;case"fill":case"stroke":{const i=Xs(s);if(i)this[t+"Pattern"]=i;else{let i;switch(s){case"none":case"transparent":case"rgba(0, 0, 0, 0)":return void(this[t]="none");case"currentcolor":case"currentColor":s=this.color||Y(e,"color",!0);default:i=qs(s)}i&&(this[t]=i.value)}return}}this[t]=s}}getAttribute(t){let e=Y(this.element,t);if(!e){if(this.patternParent)switch(t){case"fill-opacity":case"stroke-opacity":break;default:return e}let s=this.useParent||this.parent;for(;s&&!(e=Y(SvgBuild.isUse(s)?s.useElement:s.element,t));)s=s.parent}return e}convertLength(t,e){let s=+t;return isNaN(s)?Ks(t)?js(t,Ws(t)?{fontSize:Ds(this.element)}:void 0):isNaN(s=zs(t))?0:Math.round(("number"==typeof e?e:this.element.getBoundingClientRect()[e||"width"])*s):s}resetPaint(){this.fill="black",this.fillPattern="",this.fillOpacity="1",this.fillRule="nonzero",this.stroke="",this.strokeWidth="1",this.strokePattern="",this.strokeOpacity="1",this.strokeLinecap="butt",this.strokeLinejoin="miter",this.strokeMiterlimit="4",this.strokeDasharray="",this.strokeDashoffset="0",this.color="",this.clipPath="",this.clipRule=""}set strokeWidth(t){this._strokeWidth=t}get strokeWidth(){var t;const e=this.stroke;if(e&&"none"!==e){const e=this._strokeWidth;if(e)return(null===(t=this.parent)||void 0===t?void 0:t.requireRefit)?Zs(this.parent.refitSize(+e)):e}return""}};class SvgG extends(ei(bs(SvgContainer))){constructor(t){super(t),this.element=t,this.instanceType=34}build(t){super.build(t),this.setPaint(this.getPathAll(),t&&t.precision)}}const{resolvePath:si}=squared.lib.util;class SvgImage extends(As(vt(bs(SvgElement)))){constructor(t,e){super(t),this.element=t,this.imageElement=null,this.instanceType=8196,e&&(this.imageElement=e,this.rectElement=e)}build(){this.setRect()}renderStatic(t){let{x:e,y:s,width:i,height:n,parent:a}=this;const r=t?SvgBuild.filterTransforms(this.transforms,t):this.transforms,o=r.length;if(o){r.reverse();for(let t=0;t<o;++t){const a=r[t],o=a.matrix,l=e;e=q.applyX(o,l,s),s=q.applyY(o,l,s);let c=this.rotateAngle;switch(a.type){case SVGTransform.SVG_TRANSFORM_SCALE:i*=o.a,n*=o.d;break;case SVGTransform.SVG_TRANSFORM_ROTATE:0!==a.angle&&(o.a<0&&(e+=o.a*i),o.c<0&&(e+=o.c*i),o.b<0&&(s+=o.b*n),o.d<0&&(s+=o.d*n),c?c+=a.angle:c=a.angle)}this.rotateAngle=c}this.transformed=r}if(a){if(this.imageElement){const t=this.element;e+=t.x.baseVal.value,s+=t.y.baseVal.value}e=a.refitX(e),s=a.refitY(s),i=a.refitSize(i),n=a.refitSize(n);do{if(SvgBuild.asSvg(a)||SvgBuild.isUse(a)){const{x:t,y:i}=a;(a=a.parent)&&(0!==t&&(e+=a.refitX(t)),0!==i&&(s+=a.refitY(i)))}else a=a.parent}while(a)}this.setBaseValue("x",e),this.setBaseValue("y",s),this.setBaseValue("width",i),this.setBaseValue("height",n)}set x(t){super.x=t}get x(){var t;return super.x||(null===(t=this.imageElement)||void 0===t?void 0:t.x.baseVal.value)||0}set y(t){super.y=t}get y(){var t;return super.y||(null===(t=this.imageElement)||void 0===t?void 0:t.y.baseVal.value)||0}set width(t){super.width=t}get width(){var t;return super.width||(null===(t=this.imageElement)||void 0===t?void 0:t.width.baseVal.value)||0}set height(t){super.height=t}get height(){var t;return super.height||(null===(t=this.imageElement)||void 0===t?void 0:t.height.baseVal.value)||0}get href(){const t=this.imageElement||this.element;return I.image(t)?si(t.href.baseVal):""}get transforms(){return this._transforms?this._transforms:this._transforms=this.imageElement?super.transforms.concat(this.getTransforms(this.imageElement)):super.transforms}get animations(){return this._animations?this._animations:this._animations=this.imageElement?super.animations.concat(this.getAnimations(this.imageElement)):super.animations}}const{getNamedItem:ii}=squared.lib.dom,{equal:ni,lessEqual:ai,multipleOf:ri,offsetAngleX:oi,offsetAngleY:li,relativeAngle:ci,truncateFraction:hi}=squared.lib.math,{cloneObject:ui,convertInt:fi,convertFloat:di,startsWith:gi}=squared.lib.util;function pi(t,e,s,i){const n=t[0],a=t[t.length-1];if(void 0!==s)switch(e){case"x":s-=n.start.x;break;case"x1":case"cx":return n.start.x=s,void(n.coordinates[0]=s);case"x2":return a.end.x=s,void(a.coordinates[0]=s)}if(void 0!==i)switch(e){case"y":i-=n.start.y;break;case"y1":case"cy":return n.start.y=i,void(n.coordinates[1]=i);case"y2":return a.end.y=i,void(a.coordinates[1]=i)}for(let e=0,n=t.length;e<n;++e){const n=t[e],{coordinates:a,value:r}=n;for(let t=0,e=0,o=a.length;t<o;t+=2,++e)void 0!==s&&(n.relative||(a[t]+=s),r[e].x+=s),void 0!==i&&(n.relative||(a[t+1]+=i),r[e].y+=i)}}function mi(t,e,s){for(let i=0,n=t.length;i<n;++i){const n=t[i];if("A"===n.key.toUpperCase()){if(void 0!==e){const s=e-n.radiusX,a=2*e*(n.coordinates[0]<0?-1:1);if(n.radiusX=e,n.coordinates[0]=a,n.start.x=a,n.end.x=a,1===i){const e=t[0];e.coordinates[0]-=s,e.start.x-=s,e.end.x-=s}}void 0!==s&&(n.radiusY=s)}}}function yi(t,e,s,i){const n=t.get("stroke-dashoffset",s,i);return n?+n:e}function vi(t,e,s,i){const n=t.get("stroke-dasharray",s,i);return n?SvgBuild.parseCoordinates(n):e}const Si=t=>t?t.start+" "+t.end:"1 1";class SvgPath extends(ei(vt(SvgElement))){constructor(t){super(t),this.element=t,this.name="",this.value="",this.baseValue="",this.parent=null,this.transformed=null,this.instanceType=16388,this.init()}static extrapolate(t,e,s,i,n,a){const r=n&&n.parent,o=i&&i.length>0||r&&r.requireRefit,l=[];let c;for(let h=0,u=s.length;h<u;++h){if("d"===t)l[h]=s[h];else if("points"===t){const t=SvgBuild.convertPoints(SvgBuild.parseCoordinates(s[h]));t.length&&(l[h]=n&&I.polygon(n.element)?SvgBuild.drawPolygon(t,a):SvgBuild.drawPolyline(t,a))}else if(e){c||(c=SvgBuild.toPathCommands(e));const i=+s[h];if(!isNaN(i)){const e=h<u-1?ui(c,{deep:!0}):c;switch(t){case"x":case"x1":case"x2":case"cx":pi(e,t,i);break;case"y":case"y1":case"y2":case"cy":pi(e,t,void 0,i);break;case"r":mi(e,i,i);break;case"rx":mi(e,i);break;case"ry":mi(e,void 0,i);break;case"width":for(const t of[1,2]){const s=e[t];switch(s.key){case"m":case"l":case"h":s.coordinates[0]=i*(s.coordinates[0]<0?-1:1);break;case"M":case"L":case"H":s.coordinates[0]=e[0].end.x+i}}break;case"height":for(const t of[2,3]){const s=e[t];switch(s.key){case"m":case"l":case"v":s.coordinates[1]=i*(s.coordinates[1]<0?-1:1);break;case"M":case"L":case"V":s.coordinates[1]=e[0].end.y+i}}break;default:l[h]="";continue}l[h]=SvgBuild.drawPath(e,a)}}l[h]?o&&(l[h]=SvgBuild.transformRefit(l[h],{transforms:i,parent:n,container:r,precision:a})):l[h]=""}return l}build(t){var e;this.draw(t&&t.transforms?SvgBuild.filterTransforms(t.transforms,null===(e=t.exclude)||void 0===e?void 0:e[this.element.tagName.toLowerCase()]):null,t)}draw(t,e){let s,i;e&&({residualHandler:s,precision:i}=e);const n=this.element,a=this.parent,r=this.patternParent,o=a&&a.requireRefit,l=r&&2===r.patternContentUnits;let c;if(this.transformed=null,I.path(n)){if(c=H(this.getBaseValue("d")),t&&t.length||o||l){const e=SvgBuild.toPathCommands(c);if(e.length){let h=SvgBuild.toPathPoints(e);h.length&&(l&&r.patternRefitPoints(h),t&&t.length&&("function"==typeof s&&([this.transformResidual,t]=s.call(this,n,t)),t.length&&(h=SvgBuild.applyTransforms(t,h,z.origin(this.element)),this.transformed=t)),this.baseValue=SvgBuild.drawPath(SvgBuild.syncPath(o?ui(e,{deep:!0}):e,o?ui(h,{deep:!0}):h,!!this.transformed),i),o?(a.refitPoints(h),c=SvgBuild.drawPath(SvgBuild.syncPath(e,h,!!this.transformed),i)):c=this.baseValue)}}this.baseValue||(this.baseValue=c)}else if(I.line(n)){let e=[{x:this.getBaseValue("x1"),y:this.getBaseValue("y1")},{x:this.getBaseValue("x2"),y:this.getBaseValue("y2")}];l&&r.patternRefitPoints(e),t&&t.length&&("function"==typeof s&&([this.transformResidual,t]=s.call(this,n,t)),t.length&&(e=SvgBuild.applyTransforms(t,e,z.origin(this.element)),this.transformed=t));const h=()=>SvgBuild.drawPolyline(e,i);this.baseValue=h(),o?(a.refitPoints(e),c=h()):c=this.baseValue}else if(I.circle(n)||I.ellipse(n)){const e=this.getBaseValue("cx"),h=this.getBaseValue("cy");let u,f;I.ellipse(n)?(u=this.getBaseValue("rx"),f=this.getBaseValue("ry")):(u=this.getBaseValue("r"),f=u);let d=[{x:e,y:h,rx:u,ry:f}];l&&r.patternRefitPoints(d),t&&t.length&&("function"==typeof s&&([this.transformResidual,t]=s.call(this,n,t,u,f)),t.length&&(d=SvgBuild.applyTransforms(t,d,z.origin(this.element)),this.transformed=t));const g=d[0],p=()=>SvgBuild.drawEllipse(g.x,g.y,g.rx,g.ry,i);this.baseValue=p(),o?(a.refitPoints(d),c=p()):c=this.baseValue}else if(I.rect(n)){let e=this.getBaseValue("x"),h=this.getBaseValue("y"),u=this.getBaseValue("width"),f=this.getBaseValue("height");if(o||t&&t.length){let d=[{x:e,y:h},{x:e+u,y:h},{x:e+u,y:h+f},{x:e,y:h+f}];l&&r.patternRefitPoints(d),t&&t.length&&("function"==typeof s&&([this.transformResidual,t]=s.call(this,n,t)),t.length&&(d=SvgBuild.applyTransforms(t,d,z.origin(this.element)),this.transformed=t)),this.baseValue=SvgBuild.drawPolygon(d,i),o?(a.refitPoints(d),c=SvgBuild.drawPolygon(d,i)):c=this.baseValue}else l&&(e=r.patternRefitX(e),h=r.patternRefitY(h),u=r.patternRefitX(u),f=r.patternRefitY(f)),c=SvgBuild.drawRect(u,f,e,h,i),this.baseValue=c}else if(I.polygon(n)||I.polyline(n)){let e=this.getBaseValue("points");l&&r.patternRefitPoints(e),t&&t.length&&("function"==typeof s&&([this.transformResidual,t]=s.call(this,n,t)),t.length&&(e=SvgBuild.applyTransforms(t,e,z.origin(this.element)),this.transformed=t));const h=()=>I.polygon(n)?SvgBuild.drawPolygon(e,i):SvgBuild.drawPolyline(e,i);this.baseValue=h(),o?(this.transformed||(e=SvgBuild.clonePoints(e)),a.refitPoints(e),c=h()):c=this.baseValue}else c="";switch(this.value=c,this.setPaint([c],i),n.tagName.toLowerCase()){case"line":case"polyline":this.fill=""}return c}extendLength(t,e){if(this.value)switch(this.element.tagName.toLowerCase()){case"path":case"line":case"polyline":{const s=SvgBuild.toPathCommands(this.value),i=s.length;if(i){const n=s[0],a=n.start,r=s[i-1],o=r.end,l=r.key.toUpperCase(),{leading:c,trailing:h}=t;let u;if("Z"!==l&&(a.x!==o.x||a.y!==o.y)){if(c>0){let t;if(n.value.length>1?t=n.value[1]:i>1&&(t=s[1].start),t){const e=n.coordinates;if(t.x===a.x)e[1]+=a.y>t.y?c:-1*c,u=!0;else if(t.y===a.y)e[0]+=a.x>t.x?c:-1*c,u=!0;else{const s=ci(t,a);e[0]-=oi(s,c),e[1]-=li(s,c),u=!0}}}switch(l){case"M":case"L":if(h>0){let t;if(1===i){const e=n.value;e.length>1&&(t=e[e.length-2])}else{const e=r.value;t=e.length>1?e[e.length-2]:s[s.length-2].end}if(t){const e=r.coordinates;if(t.x===o.x)e[1]+=o.y>t.y?h:-1*h,u=!0;else if(t.y===o.y)e[0]+=o.x>t.x?h:-1*h,u=!0;else{const s=ci(t,o);e[0]+=oi(s,h),e[1]+=li(s,h),u=!0}}}break;case"H":case"V":{const t=r.coordinates,e="H"===l?0:1;t[e]+=(c+h)*(t[e]>=0?1:-1),u=!0;break}}}if(u)return t.leading=c,t.trailing=h,t.path=SvgBuild.drawPath(s,e),t;break}}}return t}flattenStrokeDash(t,e,s,i,n){i||(i=s);let a=0,r,o,l,c,h,u=0;const f=t=>r[t%o];if(n)({dashArray:r,dashArrayTotal:l,extendedLength:c,startIndex:u}=n),o=r.length,n.items=[],n.leading=0;else{o=t.length,r=t.slice(0);const a=ri([2,o]);l=0;for(let e=0;e<a;++e){const s=t[e%o];l+=s,e>=o&&r.push(s)}if(o=a,e>0){let t=f(0);for(;e-t>=0;)e-=t,t=f(++u);u%=o}else if(e<0){for(r.reverse();e<0;)e+=f(u++);u=o-u%o,r.reverse()}c=i,n={dashArray:r,dashArrayTotal:l,items:[],leading:0,trailing:0,startIndex:u,extendedLength:c,lengthRatio:s/(i||s)}}for(let t=0,s=0;;t+=s,++u){let i,r;s=f(u),t<e?(n.leading=e-t,i=0,r=s-n.leading):(i=t-e,r=s);const o=hi(i/c);if(h=hi(o+r/c),u%2==0?o<1&&(n.items.push({start:o,end:Math.min(h,1),length:s}),a+=s):a+=s,h>=1)break}for(n.trailing=hi((h-1)*c);a%l!=0;){const t=f(++u);n.trailing+=t,a+=t}return 0===n.items.length?n.items.push({start:1,end:1}):(n.leadingOffset=hi(n.items[0].start*c),n.leading*=n.lengthRatio,n.trailing*=n.lengthRatio),n}extractStrokeDash(t,e){const s=+this.strokeWidth;let i="",n="",a;if(s){let r=SvgBuild.parseCoordinates(this.strokeDasharray);if(r.length){const o=this.totalLength,l=this.pathLength||o,c=[];let h=fi(this.strokeDashoffset),u=0,f;const d=(t,e,s,i=0)=>{const n=this.flattenStrokeDash(t,e,o,l);return 0===c.length&&(f=n),u=Math.max(u,n.items.length),c.push({items:n.items,delay:s,duration:i}),n.items};if(a=d(r,h,0),t){const g=t.slice(0).sort(((t,e)=>{if(gi(t.attributeName,"stroke-dash")&&gi(e.attributeName,"stroke-dash")){if(t.delay!==e.delay)return t.delay-e.delay;if(SvgBuild.asSet(t)&&SvgBuild.asAnimate(e)||!t.animationElement&&e.animationElement)return-1;if(SvgBuild.asAnimate(t)&&SvgBuild.asSet(e)||t.animationElement&&!e.animationElement)return 1}return 0})),p=new SvgAnimationIntervalMap(g,"stroke-dasharray","stroke-dashoffset"),m=t=>{let e=h;for(let s=t,i=g.length;s<i;++s){const t=g[s];if("stroke-dasharray"===t.attributeName){const s=p.get("stroke-dashoffset",t.delay);s&&(e=+s);for(const s of SvgBuild.asAnimate(t)?p.evaluateStart(t):[t.to])u=Math.max(u,this.flattenStrokeDash(SvgBuild.parseCoordinates(s),e,o,l).items.length)}}},y=[];let v,S;if(g.length>1)for(let t=0;t<g.length;++t){const e=g[t];p.has(e.attributeName,e.delay,e)||g.splice(t--,1)}for(let t=0;t<g.length;++t){const b=g[t];if(b.setterType){const t=(t,e)=>{d(t,e,b.delay,b.fillReplace&&b.duration>0?b.duration:0),S=!0};switch(b.attributeName){case"stroke-dasharray":r=SvgBuild.parseCoordinates(b.to),t(r,yi(p,h,b.delay));continue;case"stroke-dashoffset":h=fi(b.to),t(vi(p,r,b.delay),h);continue}}else if(SvgBuild.asAnimate(b)&&b.playable)switch(p.evaluateStart(b),b.attributeName){case"stroke-dasharray":{v||(m(t),v=!0);const e=yi(p,h,b.delay),s=this.flattenStrokeDash(vi(p,r,b.delay),e,o,l).items,i=[],n=[];for(let t=0;t<u;++t){const e=new SvgAnimate(this.element);e.id=t,e.baseValue=Si(s[t]),e.attributeName="stroke-dasharray",e.delay=b.delay,e.duration=b.duration,e.iterationCount=b.iterationCount,e.fillMode=b.fillMode,n[t]=[],i.push(e)}const a=b.values;for(let t=0,s=a.length;t<s;++t){const s=this.flattenStrokeDash(SvgBuild.parseCoordinates(a[t]),e,o,l).items;for(let t=0;t<u;++t)n[t].push(Si(s[t]))}const{keyTimes:c,keySplines:f}=b,d=b.timingFunction;for(let t=0;t<u;++t){const e=i[t];e.values=n[t],e.keyTimes=c,f?e.keySplines=f:d&&(e.timingFunction=d)}if(b.fillReplace){const t=b.getTotalDuration(),e=this.flattenStrokeDash(vi(p,r,t),yi(p,h,t),o,l).items;for(let t=0;t<u;++t)i[t].replaceValue=Si(e[t])}y.push(...i),S=!0;continue}case"stroke-dashoffset":{const t=b.duration,r=+b.values[0];let d=0,g=0,m=o,y=1,v;if(h===r||0!==b.delay||b.fillReplace||(f=this.flattenStrokeDash(f.dashArray,r,o,l),a=f.items,c[0].items=a,u=Math.max(u,f.items.length),h=r),(f.leading>0||f.trailing>0)&&(this.extendLength(f,e),f.path)){const t=SvgBuild.boxRectOf([this.value]);m=hi(Q(f.path)),y=m/o,f.extendedLength=this.pathLength,f.extendedLength?f.extendedLength*=y:f.extendedLength=m;const e=undefined;a=this.flattenStrokeDash(f.dashArray,0,o,l,f).items,c[0].items=a,u=Math.max(u,a.length);const r=Math.ceil(s/2);i=f.path,n=SvgBuild.drawRect(t.right-t.left,t.bottom-t.top+2*r,t.left,t.top-r)}if(b.fillReplace&&-1!==b.iterationCount){const t=di(p.get(b.attributeName,b.getTotalDuration()));if(t!==h){let e=Math.abs(t-h)%m/m;t>h&&(e=1-e),v=e.toString()}}const k=b.keyTimes,T=b.values,A=[],x=[];for(let e=0,s=k.length;e<s;++e){const s=0===e?h:+T[e-1],i=+T[e],n=Math.abs(i-s),a=k[e];if(0===n){if(e>0){d=a,x.push(d);const t=A.length;t?(A.push(A[t-1]),g=+A[t-1]):(A.push("0"),g=0)}continue}const r=i>s,o=e>0?(a-k[e-1])*t:0,l=n*f.lengthRatio;let c=l/m,u=l,p=0;const y=()=>{const t=r?"1":"0";e>0&&A[A.length-1]===t||(x.push(0===d?0:hi(d)),A.push(t))},v=(t,e)=>{if(p=(u-t)/m,e){const t=hi(p);r?t>0&&(p=1-p):0===t&&(p=1)}},S=()=>{d=a,x.push(d);const t=hi(p);A.push(t.toString()),g=t>0&&t<1?p:0},b=e=>e/l*o/t;if(0===e)u%=m,v(0),r&&(p=1-p),S();else{if(g>0){const t=r?g:1-g,e=hi(t*m);if(ai(u,e)){v(0),r?p=g-p:p+=g,S();continue}A.push(r?"0":"1"),d+=b(e),x.push(hi(d)),c=hi(c-t),u=hi(u-e)}if(ni(u,m)&&(u=m),u>m){c=Math.floor(c);const t=c*m;t===u&&--c,v(t,!0)}else c=0,v(0,!0);for(;c>0;)y(),A.push(r?"0":"1"),d+=b(m),x.push(hi(d)),--c;y(),S()}}b.baseValue="0",b.replaceValue=v,b.values=A,b.keyTimes=x;const E=b.timingFunction;E&&(b.keySplines=null,b.timingFunction=E),S=!0;break}}y.push(b)}if(S){for(let t=0,e=c.length;t<e;++t){const{delay:s,duration:i,items:n}=c[t];if(n===a)for(let t=n.length;t<u;++t)n.push({start:1,end:1});else{const t=e>2?this.flattenStrokeDash(vi(p,r,s-1),yi(p,h,s-1),o,l).items:a;for(let e=0;e<u;++e){const a=new SvgAnimation(this.element);a.id=e,a.attributeName="stroke-dasharray",a.baseValue=Si(t[e]),a.delay=s,a.duration=i,a.fillFreeze=0===i,a.to=Si(n[e]),y.push(a)}}}t=y}}}}return[t,a,i,n]}init(){const t=this.element;I.path(t)?this.setBaseValue("d"):I.line(t)?(this.setBaseValue("x1"),this.setBaseValue("y1"),this.setBaseValue("x2"),this.setBaseValue("y2")):I.rect(t)?(this.setBaseValue("x"),this.setBaseValue("y"),this.setBaseValue("width"),this.setBaseValue("height")):I.circle(t)?(this.setBaseValue("cx"),this.setBaseValue("cy"),this.setBaseValue("r")):I.ellipse(t)?(this.setBaseValue("cx"),this.setBaseValue("cy"),this.setBaseValue("rx"),this.setBaseValue("ry")):(I.polygon(t)||I.polyline(t))&&this.setBaseValue("points",SvgBuild.clonePoints(t.points))}get transforms(){return this._transforms||(this._transforms=SvgBuild.filterTransforms(z.parse(this.element)||SvgBuild.convertTransforms(this.element.transform.baseVal)))}get pathLength(){return di(ii(this.element,"pathLength"))}get totalLength(){return this.element.getTotalLength()}}class SvgPattern extends(bs(SvgContainer)){constructor(t,e){super(t),this.element=t,this.patternElement=e,this.instanceType=258}build(t){super.build(Object.assign(Object.assign({},t),{targetElement:this.patternElement,initialize:!1}))}get animations(){return[]}}class SvgShape extends(qe(bs(SvgElement))){constructor(t,e=!0){super(t),this.element=t,this.instanceType=2052,this._path=null,e&&this.setPath()}setPath(){this.path=new SvgPath(this.element)}build(t){const e=this.path;e&&(e.parent=this.parent,e.build(Object.assign(Object.assign({},t),{transforms:this.transforms})))}synchronize(t){if(this.animations.length){const e=this.path;if(e){const s=t&&t.element;s?this.animateSequentially(this.getAnimateShape(s),void 0,e,t):this.animateSequentially(this.getAnimateShape(this.element),this.getAnimateTransform(t),e,t)}}}set path(t){this._path=t,t&&(t.name=this.name)}get path(){return this._path}}const{getNamedItem:bi}=squared.lib.dom,{convertPercent:ki}=squared.lib.util;class SvgShapePattern extends(ei(vt(bs(SvgContainer)))){constructor(t,e){super(t),this.element=t,this.patternElement=e,this.drawRegion=null,this.instanceType=514,this.patternUnits="userSpaceOnUse"===bi(this.patternElement,"patternUnits")?1:2,this.patternContentUnits="objectBoundingBox"===bi(this.patternElement,"patternContentUnits")?2:1}build(t){const e=this.element,s=new SvgPath(e);s.build(Object.assign({},t));const i=s.value;if(i){const n=t&&t.precision;this.clipRegion=i,s.clipPath&&(this.clipRegion=s.clipPath);const a=[i];this.setPaint(a,n),this.drawRegion=SvgBuild.boxRectOf(a);const{drawRegion:r,fillOpacity:o,patternWidth:l,patternHeight:c,tileWidth:h,tileHeight:u}=this,f=2===this.patternUnits;let d=this.offsetX%h,g=this.offsetY%u,p=0,m=0,y=r.right,v=r.bottom;f&&(p=r.left,m=r.top,y-=p,v-=m),0!==d&&(d=h-d,y+=h),0!==g&&(g=u-g,v+=u);for(let s=0;v>0;++s){const i=this.patternElement,a=2===this.patternContentUnits,r=m+s*u-g;let f=y,S=0;do{const s=p+S++*h-d,g=new SvgPattern(e,i);g.build(Object.assign({},t)),g.cascade((e=>{if(SvgBuild.isShape(e)){e.setPath();const i=e.path;i&&(i.patternParent=this,a?i.refitBaseValue(s/l,r/c,n):i.refitBaseValue(s,r,n),i.build(Object.assign(Object.assign({},t),{transforms:e.transforms})),i.fillOpacity=(+i.fillOpacity*+o).toString(),i.clipPath=SvgBuild.drawRect(h,u,s,r,n)+(i.clipPath?";"+i.clipPath:""))}})),this.add(g),f-=h}while(f>0);v-=u}if(this.stroke&&+this.strokeWidth>0){s.fill="",s.fillOpacity="0",s.stroke=this.stroke,s.strokeWidth=this.strokeWidth;const t=new SvgShape(e,!1);t.path=s,this.add(t)}}}patternRefitX(t){return this.drawRegion?t*this.patternWidth:t}patternRefitY(t){return this.drawRegion?t*this.patternHeight:t}patternRefitPoints(t){if(this.drawRegion){const e=this.patternWidth,s=this.patternHeight;for(let i=0,n=t.length;i<n;++i){const n=t[i];if(n.x*=e,n.y*=s,void 0!==n.rx&&void 0!==n.ry)if(n.rx===n.ry){const t=Math.min(e,s);n.rx*=t,n.ry*=t}else n.rx*=e,n.ry*=s}}return t}get patternWidth(){const t=this.drawRegion;return t?t.right-t.left:0}get patternHeight(){const t=this.drawRegion;return t?t.bottom-t.top:0}get transforms(){if(!this._transforms){this._transforms=super.transforms;const t=SvgBuild.convertTransforms(this.patternElement.patternTransform.baseVal),e=t.length;if(e){const s=z.rotateOrigin(this.patternElement,"patternTransform"),i=this.patternWidth/2,n=this.patternHeight/2;for(let a=0;a<e;++a){const e=t[a];switch(e.type){case SVGTransform.SVG_TRANSFORM_TRANSLATE:break;case SVGTransform.SVG_TRANSFORM_ROTATE:for(;s.length;){const t=s.shift();if(t.angle===e.angle){e.origin={x:i+t.x,y:n+t.y};break}}if(e.origin)break;default:e.origin={x:i,y:n}}}this._transforms.push(...SvgBuild.filterTransforms(t))}}return this._transforms}get offsetX(){const t=this.patternElement.x.baseVal;return 2===this.patternUnits?this.patternWidth*ki(t.valueAsString):t.value}get offsetY(){const t=this.patternElement.y.baseVal;return 2===this.patternUnits?this.patternHeight*ki(t.valueAsString):t.value}get tileWidth(){const t=this.patternElement.width.baseVal;return 2===this.patternUnits?this.patternWidth*ki(t.valueAsString):t.value}get tileHeight(){const t=this.patternElement.height.baseVal;return 2===this.patternUnits?this.patternHeight*ki(t.valueAsString):t.value}}class SvgUseG extends(As(vt(SvgG))){constructor(t,e){super(t),this.element=t,this.useElement=e,this.instanceType=115,this.useParent=this,this.rectElement=e}build(t){this.setRect(),super.build(t)}}class SvgUseShape extends(ei(As(vt(SvgShape)))){constructor(t,e,s=!0){super(t,!1),this.element=t,this.useElement=e,this.instanceType=6149,this.useParent=this,this.rectElement=e,s&&this.setPath()}setPath(){const t=new SvgPath(this.element);t.useParent=this,this.path=t}build(t){super.build(t),this.setPaint(this.path&&[this.path.value],t&&t.precision)}synchronize(t){t=Object.assign(Object.assign({},t),{element:this.element}),this.animations.length&&this.animateSequentially(this.getAnimateViewRect(),this.getAnimateTransform(t),void 0,t),super.synchronize(t)}getTransforms(){return super.getTransforms(this.useElement).concat(super.getTransforms())}getAnimations(){return super.getAnimations(this.useElement).concat(super.getAnimations())}}class SvgUseShapePattern extends(qe(As(SvgShapePattern))){constructor(t,e,s){super(t,s),this.element=t,this.useElement=e,this.instanceType=1539,this.useParent=this,this.rectElement=e}synchronize(t){const e=this.animations.filter((t=>"x"===t.attributeName||"y"===t.attributeName||this.verifyBaseValue(t.attributeName,0)>0)),s=this.getAnimateTransform(t);(e.length||s.length)&&this.animateSequentially(this.getAnimateViewRect(e),s,void 0,t),super.synchronize(t)}}class SvgUseSymbol extends(ei(qe(As(vt(bs(SvgContainer)))))){constructor(t,e){super(e),this.symbolElement=t,this.useElement=e,this.instanceType=131,this.useParent=this,this.rectElement=e}build(t){this.setRect(),super.build(Object.assign(Object.assign({},t),{targetElement:this.symbolElement})),this.setPaint(this.getPathAll(),t&&t.precision)}synchronize(t){this.animations.length&&this.animateSequentially(this.getAnimateViewRect(),this.getAnimateTransform(t),void 0,t),super.synchronize(t)}get viewBox(){return this.symbolElement.viewBox.baseVal||{x:0,y:0,width:0,height:0}}}const Ti={util:J};return t.Svg=Svg,t.SvgAnimate=SvgAnimate,t.SvgAnimateMotion=SvgAnimateMotion,t.SvgAnimateTransform=SvgAnimateTransform,t.SvgAnimation=SvgAnimation,t.SvgAnimationIntervalMap=SvgAnimationIntervalMap,t.SvgBaseVal=vt,t.SvgBuild=SvgBuild,t.SvgContainer=SvgContainer,t.SvgElement=SvgElement,t.SvgG=SvgG,t.SvgImage=SvgImage,t.SvgPaint=ei,t.SvgPath=SvgPath,t.SvgPattern=SvgPattern,t.SvgShape=SvgShape,t.SvgShapePattern=SvgShapePattern,t.SvgSynchronize=qe,t.SvgUseG=SvgUseG,t.SvgUseShape=SvgUseShape,t.SvgUseShapePattern=SvgUseShapePattern,t.SvgUseSymbol=SvgUseSymbol,t.SvgView=bs,t.SvgViewRect=As,t.lib=Ti,Object.defineProperty(t,"__esModule",{value:!0}),t}({});
