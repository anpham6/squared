!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e(((t=t||self).squared=t.squared||{},t.squared.svg={}))}(this,function(t){"use strict";const e=squared.lib.css,s=squared.lib.dom,i=squared.lib.math,a=squared.lib.regex,n=squared.lib.session,r=squared.lib.util,o=`(${a.STRING.DECIMAL})`,l={MATRIX:RegExp(`(matrix(?:3d)?)\\(${o}, ${o}, ${o}, ${o}, ${o}, ${o}(?:, ${o})?(?:, ${o})?(?:, ${o})?(?:, ${o})?(?:, ${o})?(?:, ${o})?(?:, ${o})?(?:, ${o})?(?:, ${o})?(?:, ${o})?\\)`,"g"),ROTATE:RegExp(`(rotate[XY]?)\\(${a.STRING.CSS_ANGLE}\\)`,"g"),SKEW:RegExp(`(skew[XY]?)\\(${a.STRING.CSS_ANGLE}(?:, ${a.STRING.CSS_ANGLE})?\\)`,"g"),SCALE:RegExp(`(scale[XY]?)\\(${o}(?:, ${o})?\\)`,"g"),TRANSLATE:RegExp(`(translate[XY]?)\\(${a.STRING.LENGTH_PERCENTAGE}(?:, ${a.STRING.LENGTH_PERCENTAGE})?\\)`,"g")},h={path:1,line:2,rect:3,ellipse:4,circle:5,polyline:6,polygon:7},c={applyX:(t,e,s)=>t.a*e+t.c*s+t.e,applyY:(t,e,s)=>t.b*e+t.d*s+t.f,clone:t=>({a:t.a,b:t.b,c:t.c,d:t.d,e:t.e,f:t.f}),rotate(t){const e=i.convertRadian(t),s=Math.cos(e),a=Math.sin(e);return{a:s,b:a,c:-1*a,d:s,e:0,f:0}},skew:(t=0,e=0)=>({a:1,b:Math.tan(i.convertRadian(e)),c:Math.tan(i.convertRadian(t)),d:1,e:0,f:0}),scale:(t=1,e=1)=>({a:t,b:0,c:0,d:e,e:0,f:0}),translate:(t=0,e=0)=>({a:1,b:0,c:0,d:1,e:t,f:e})},u={create:(t,e,s=0,i=!0,a=!0)=>({type:t,matrix:e,angle:s,method:{x:i,y:a}}),parse(t,s){const i=s||t.style.getPropertyValue("transform");if(""!==i){const a=[];for(const n in l){let r;for(;null!==(r=l[n].exec(i));){const i=r[1].endsWith("X"),n=r[1].endsWith("Y");if(r[1].startsWith("rotate")){const t=e.convertAngle(r[2],r[3]),s=c.rotate(t);i?(s.a=1,s.b=0,s.c=0):n&&(s.b=0,s.c=0,s.d=1),a[r.index]=u.create(SVGTransform.SVG_TRANSFORM_ROTATE,s,t,!i,!n)}else if(r[1].startsWith("skew")){const t=n?0:e.convertAngle(r[2],r[3]),s=n?e.convertAngle(r[2],r[3]):r[4]&&r[5]?e.convertAngle(r[4],r[5]):0,o=c.skew(t,s);i?a[r.index]=u.create(SVGTransform.SVG_TRANSFORM_SKEWX,o,t,!0,!1):n?a[r.index]=u.create(SVGTransform.SVG_TRANSFORM_SKEWY,o,s,!1,!0):(a[r.index]=u.create(SVGTransform.SVG_TRANSFORM_SKEWX,Object.assign({},o,{b:0}),t,!0,!1),0!==s&&(a[r.index+1]=u.create(SVGTransform.SVG_TRANSFORM_SKEWY,Object.assign({},o,{c:0}),s,!1,!0)))}else if(r[1].startsWith("scale")){const t=n?void 0:parseFloat(r[2]),e=n?parseFloat(r[2]):!i&&r[3]?parseFloat(r[3]):t,s=c.scale(t,i?void 0:e);a[r.index]=u.create(SVGTransform.SVG_TRANSFORM_SCALE,s,0,!n,!i)}else if(r[1].startsWith("translate")){const s=e.getFontSize(t),o=e.parseUnit(r[2],s),l=!i&&r[3]?e.parseUnit(r[3],s):0,h=c.translate(n?0:o,n?o:l);a[r.index]=u.create(SVGTransform.SVG_TRANSFORM_TRANSLATE,h,0)}else if(r[1].startsWith("matrix")){const e=u.matrix(t,s);e&&(a[r.index]=u.create(SVGTransform.SVG_TRANSFORM_MATRIX,e))}}}const n=[];return a.forEach(t=>{t.fromCSS=!0,n.push(t)}),n}},matrix(t,s){const i=RegExp(l.MATRIX).exec(s||e.getStyle(t).transform||"");if(i)switch(i[1]){case"matrix":return{a:parseFloat(i[2]),b:parseFloat(i[3]),c:parseFloat(i[4]),d:parseFloat(i[5]),e:parseFloat(i[6]),f:parseFloat(i[7])};case"matrix3d":return{a:parseFloat(i[2]),b:parseFloat(i[3]),c:parseFloat(i[6]),d:parseFloat(i[7]),e:parseFloat(i[14]),f:parseFloat(i[15])}}},origin(t,s){void 0===s&&(s=d(t,"transform-origin"));const i={x:0,y:0};if(""!==s){const n=v(t);function a(s,a,n){e.isLength(a)?i[s]=e.parseUnit(a,e.getFontSize(t)):e.isPercent(a)&&(i[s]=parseFloat(a)/100*n)}let r=0,o=0;if(n)r=n.width,o=n.height;else{const e=t.parentElement;e instanceof SVGGraphicsElement&&e.viewportElement&&(f.svg(e.viewportElement)||f.symbol(e.viewportElement))&&(r=e.viewportElement.viewBox.baseVal.width,o=e.viewportElement.viewBox.baseVal.height)}if(!r||!o){const e=t.getBoundingClientRect();r=e.width,o=e.height}const l=s.split(" ");switch(1===l.length&&l.push("center"),l[0]){case"0%":case"left":break;case"100%":case"right":i.x=r;break;case"center":l[0]="50%";default:a("x",l[0],r)}switch(l[1]){case"0%":case"top":break;case"100%":case"bottom":i.y=o;break;case"center":l[1]="50%";default:a("y",l[1],o)}}return i},rotateOrigin(t,e="transform"){const i=s.getNamedItem(t,e),a=[];if(""!==i){const t=/rotate\((-?[\d.]+)(?:,? (-?[\d.]+))?(?:,? (-?[\d.]+))?\)/g;let e;for(;null!==(e=t.exec(i));){const t=parseFloat(e[1]);0!==t&&a.push({angle:t,x:e[2]?parseFloat(e[2]):0,y:e[3]?parseFloat(e[3]):0})}}return a},typeAsName(t){switch(t){case SVGTransform.SVG_TRANSFORM_ROTATE:return"rotate";case SVGTransform.SVG_TRANSFORM_SCALE:return"scale";case SVGTransform.SVG_TRANSFORM_SKEWX:return"skewX";case SVGTransform.SVG_TRANSFORM_SKEWY:return"skewY";case SVGTransform.SVG_TRANSFORM_TRANSLATE:return"translate";default:return""}},typeAsValue(t){switch(t){case"rotate":case SVGTransform.SVG_TRANSFORM_ROTATE:return"0 0 0";case"scale":case SVGTransform.SVG_TRANSFORM_SCALE:return"1 1 0 0";case"skewX":case"skewY":case SVGTransform.SVG_TRANSFORM_SKEWX:case SVGTransform.SVG_TRANSFORM_SKEWY:return"0";case"translate":case SVGTransform.SVG_TRANSFORM_TRANSLATE:return"0 0";default:return""}}},f={svg:t=>"svg"===t.tagName,g:t=>"g"===t.tagName,symbol:t=>"symbol"===t.tagName,path:t=>"path"===t.tagName,shape:t=>void 0!==h[t.tagName],image:t=>"image"===t.tagName,use:t=>"use"===t.tagName,line:t=>"line"===t.tagName,rect:t=>"rect"===t.tagName,circle:t=>"circle"===t.tagName,ellipse:t=>"ellipse"===t.tagName,polygon:t=>"polygon"===t.tagName,polyline:t=>"polyline"===t.tagName,clipPath:t=>"clipPath"===t.tagName,pattern:t=>"pattern"===t.tagName,linearGradient:t=>"linearGradient"===t.tagName,radialGradient:t=>"radialGradient"===t.tagName};function p(t){const e=t.getBoundingClientRect();return e.x=e.left,e.y=e.top,e}function d(t,i,a=!0){let o=s.getNamedItem(t,i);if(""===o){const s=n.getElementCache(t,"styleMap");s&&(o=s[r.convertCamelCase(i)]||""),""===o&&a&&(o=e.getStyle(t).getPropertyValue(i))}return o}function g(t,e,s=!0){let i=t,a="";for(;i&&(""===(a=d(i,e,s))||"inherit"===a);)i=i.parentElement;return a}function m(t){const e=a.CSS.URL.exec(t);return e?e[1]:""}function y(t,e){const i=s.getNamedItem(t,"href");if("#"===i.charAt(0)){const s=i.substring(1);let a;if(e)a=e;else for(a=t.parentElement;a&&a.parentElement instanceof SVGGraphicsElement;)a=a.parentElement;if(a){const t=a.querySelectorAll("*");for(let e=0;e<t.length;e++){const i=t[e];if(i.id===s&&i instanceof SVGElement)return i}}else{const t=document.getElementById(s);if(t instanceof SVGElement)return t}}return null}function v(t){let e=t.parentElement;for(;e;){if((f.svg(e)||f.symbol(e))&&e.viewBox&&e.viewBox.baseVal.width>0&&e.viewBox.baseVal.height>0)return e.viewBox.baseVal;e=e.parentElement}}function b(t){const e=document.createElementNS("http://www.w3.org/2000/svg","path");return e.setAttribute("d",t),e}function S(t){return b(t).getTotalLength()}var k=Object.freeze({MATRIX:c,TRANSFORM:u,SVG:f,getDOMRect:p,getAttribute:d,getParentAttribute:g,getAttributeURL:m,getTargetElement:y,getNearestViewBox:v,createPath:b,getPathLength:S});const T=squared.lib.css,x=squared.lib.dom,R=squared.lib.math,A=squared.lib.regex,_=squared.lib.util,V=RegExp(A.STRING.DECIMAL,"g"),w=/([A-Za-z])([^A-Za-z]+)?/g,E=new Map;class N{static isContainer(t){return _.hasBit(t.instanceType,2)}static isElement(t){return _.hasBit(t.instanceType,4)}static isShape(t){return _.hasBit(t.instanceType,2052)}static isAnimate(t){return _.hasBit(t.instanceType,16392)}static isAnimateTransform(t){return _.hasBit(t.instanceType,49160)}static asSvg(t){return 18===t.instanceType}static asG(t){return 34===t.instanceType}static asPattern(t){return 130===t.instanceType}static asShapePattern(t){return 258===t.instanceType}static asUsePattern(t){return 514===t.instanceType}static asImage(t){return 4100===t.instanceType}static asUse(t){return 10244===t.instanceType}static asUseSymbol(t){return 66===t.instanceType}static asSet(t){return 8===t.instanceType}static asAnimate(t){return 16392===t.instanceType}static asAnimateTransform(t){return 49160===t.instanceType}static asAnimateMotion(t){return 114696===t.instanceType}static setName(t){if(t){let e,s="";if(_.isString(t.id)){const i=_.convertWord(t.id,!0);E.has(i)||(s=i),e=i}else e=t.tagName;let i=E.get(e)||0;return""!==s?(E.set(s,i),s):(E.set(e,++i),`${e}_${i}`)}return E.clear(),""}static drawLine(t,e,s=0,i=0,a){return a&&(t=R.truncate(t,a),e=R.truncate(e,a),s=R.truncate(s,a),i=R.truncate(i,a)),`M${t},${e} L${s},${i}`}static drawRect(t,e,s=0,i=0,a){return a?(t=R.truncate(s+t,a),e=R.truncate(i+e,a),s=R.truncate(s,a),i=R.truncate(i,a)):(t+=s,e+=i),`M${s},${i} ${t},${i} ${t},${e} ${s},${e} Z`}static drawCircle(t,e,s,i){return N.drawEllipse(t,e,s,s,i)}static drawEllipse(t,e,s,i,a){void 0===i&&(i=s);let n=2*s;return a?(t=R.truncate(t-s,a),e=R.truncate(e,a),s=R.truncate(s,a),i=R.truncate(i,a),n=R.truncate(n,a)):t-=s,`M${t},${e} a${s},${i},0,0,1,${n},0 a${s},${i},0,0,1,-${n},0`}static drawPolygon(t,e){return t.length?`${N.drawPolyline(t,e)} Z`:""}static drawPolyline(t,e){let s="M";if(e)for(const i of t)s+=` ${R.truncate(i.x,e)},${R.truncate(i.y,e)}`;else for(const e of t)s+=` ${e.x},${e.y}`;return s}static drawPath(t,e){let s="";for(const e of t)switch(s+=(""!==s?" ":"")+e.key,e.key.toUpperCase()){case"M":case"L":case"C":case"S":case"Q":case"T":s+=e.coordinates.join(",");break;case"H":s+=e.coordinates[0];break;case"V":s+=e.coordinates[1];break;case"A":s+=`${e.radiusX},${e.radiusY},${e.xAxisRotation},${e.largeArcFlag},${e.sweepFlag},${e.coordinates.join(",")}`}return e?R.truncateString(s,e):s}static drawRefit(t,e,s){let i;if(f.path(t)){if(i=x.getNamedItem(t,"d"),e&&e.requireRefit){const t=N.getPathCommands(i);if(t.length){const a=N.getPathPoints(t);a.length&&(e.refitPoints(a),i=N.drawPath(N.syncPathPoints(t,a),s))}}}else if(f.line(t)){const a=[{x:t.x1.baseVal.value,y:t.y1.baseVal.value},{x:t.x2.baseVal.value,y:t.y2.baseVal.value}];e&&e.requireRefit&&e.refitPoints(a),i=N.drawPolyline(a,s)}else if(f.circle(t)||f.ellipse(t)){let a,n;f.ellipse(t)?(a=t.rx.baseVal.value,n=t.ry.baseVal.value):n=a=t.r.baseVal.value;const r=[{x:t.cx.baseVal.value,y:t.cy.baseVal.value,rx:a,ry:n}];e&&e.requireRefit&&e.refitPoints(r);const o=r[0];i=N.drawEllipse(o.x,o.y,o.rx,o.ry,s)}else if(f.rect(t)){let a=t.x.baseVal.value,n=t.y.baseVal.value,r=t.width.baseVal.value,o=t.height.baseVal.value;e&&e.requireRefit&&(a=e.refitX(a),n=e.refitY(n),r=e.refitSize(r),o=e.refitSize(o)),i=N.drawRect(r,o,a,n,s)}else if(f.polygon(t)||f.polyline(t)){const a=N.clonePoints(t.points);e&&e.requireRefit&&e.refitPoints(a),i=f.polygon(t)?N.drawPolygon(a,s):N.drawPolyline(a,s)}else i="";return i}static transformRefit(t,e,s,i,a){const n=N.getPathCommands(t);if(n.length){let r=N.getPathPoints(n);if(r.length){const o=e&&e.length>0;o&&(r=N.applyTransforms(e,r,s&&u.origin(s.element))),i&&i.requireRefit&&i.refitPoints(r),t=N.drawPath(N.syncPathPoints(n,r,o),a)}}return t}static getOffsetPath(t,e="auto 0deg"){const s=b(t),i=Math.ceil(s.getTotalLength()),a=[];if(i>0){const n=[],r=[];let o=0,l=0;if(T.isAngle(e))o=T.parseAngle(e);else{const s=N.getPathCommands(t);for(const t of s)switch(t.key.toUpperCase()){case"M":case"L":case"H":case"V":case"Z":for(const e of t.value)n.push(e),r.push(!1);break;case"C":case"S":case"Q":case"T":case"A":n.push(t.end),r.push(!0)}"auto 0deg"!==e&&(l=T.parseAngle(e.split(" ").pop()))}let h,c=!1,u=0,f=0;for(let t=0;t<=i;t++){const e=s.getPointAtLength(t);if(n.length){const t=n.findIndex(t=>{const s=""+t.x,i=""+t.y;return s===e.x.toPrecision(s.length-(-1!==s.indexOf(".")?1:0))&&i===e.y.toPrecision(i.length-(-1!==i.indexOf(".")?1:0))});if(-1!==t){const s=n[t+1];s?(c=r[t+1])?(h=N.centerPoints(n[t],s),o=0):(h=void 0,o=R.truncateFraction(R.absoluteAngle(e,s))):h=void 0,f=0,n.splice(0,t+1),r.splice(0,t+1)}}let i;c?(i=h?R.truncateFraction(R.relativeAngle(h,e)):0,u>0&&u%360==0&&0===Math.floor(i)&&(f=u),i+=f):i=o,a.push({key:t,value:e,rotate:i+=l}),u=Math.ceil(i)}}return a}static getPathCommands(t){const e=[];let s;for(t=t.trim();null!==(s=w.exec(t))&&(0!==e.length||"M"===s[1].toUpperCase());){const t=N.parseCoordinates((s[2]||"").trim());let i,a,n,r,o,l,h;if(e.length){const t=e[e.length-1];i=t.key.toUpperCase(),a=t.end}switch(s[1].toUpperCase()){case"M":0===e.length&&(s[1]="M");case"L":if(t.length>=2){t.length%2!=0&&t.length--;break}continue;case"H":if(a&&t.length){t[1]="h"===s[1]?0:a.y,t.length=2;break}continue;case"V":if(a&&t.length){const e=t[0];t[0]="v"===s[1]?0:a.x,t[1]=e,t.length=2;break}continue;case"Z":if(e.length){t[0]=e[0].coordinates[0],t[1]=e[0].coordinates[1],t.length=2,s[1]="Z";break}continue;case"C":if(t.length>=6){t.length=6;break}continue;case"S":if(t.length>=4&&("C"===i||"S"===i)){t.length=4;break}continue;case"Q":if(t.length>=4){t.length=4;break}continue;case"T":if(t.length>=2&&("Q"===i||"T"===i)){t.length=2;break}continue;case"A":if(t.length>=7){n=t[0],r=t[1],o=t[2],l=t[3],h=t[4],t[0]=t[5],t[1]=t[6],t.length=2;break}continue;default:continue}if(t.length>=2){const i=s[1]===s[1].toLowerCase(),c=[];for(let e=0;e<t.length;e+=2){let s=t[e],n=t[e+1];i&&a&&(s+=a.x,n+=a.y),c.push({x:s,y:n})}e.push({key:s[1],value:c,start:c[0],end:c[c.length-1],relative:i,coordinates:t,radiusX:n,radiusY:r,xAxisRotation:o,largeArcFlag:l,sweepFlag:h})}}return e}static getPathPoints(t,e=!1){const s=[];let i=0,a=0;for(let n=0;n<t.length;n++){const r=t[n];for(let t=0;t<r.coordinates.length;t+=2){r.relative?(i+=r.coordinates[t],a+=r.coordinates[t+1]):(i=r.coordinates[t],a=r.coordinates[t+1]);const n={x:i,y:a};"A"===r.key.toUpperCase()&&(n.rx=r.radiusX,n.ry=r.radiusY,e&&(r.coordinates[t]>=0?n.y-=r.radiusY:n.y+=r.radiusY)),s.push(n)}r.relative&&(r.key=r.key.toUpperCase())}return s}static syncPathPoints(t,e,s=!1){let i;t:for(const a of t)if(a.relative){if(!i)break;if(!s||"H"!==a.key&&"V"!==a.key){for(let t=0,s=0;t<a.coordinates.length;t+=2,s++){const n=e.shift();if(!n)break t;a.coordinates[t]=n.x-i.x,a.coordinates[t+1]=n.y-i.y,"a"===a.key&&void 0!==n.rx&&void 0!==n.ry&&(a.radiusX=n.rx,a.radiusY=n.ry),a.value[s]=n}a.key=a.key.toLowerCase()}else{const t=e.shift();if(!t)break t;a.coordinates[0]=t.x,a.coordinates[1]=t.y,a.value[0]=t,a.start=t,a.end=t,a.key="L",a.relative=!1}i=a.end}else{switch(a.key.toUpperCase()){case"M":case"L":case"H":case"V":case"C":case"S":case"Q":case"T":case"Z":for(let s=0,i=0;s<a.coordinates.length;s+=2,i++){const n=e.shift();if(!n){t=[];break t}a.coordinates[s]=n.x,a.coordinates[s+1]=n.y,a.value[i]=n}break;case"A":{const s=e.shift();if(!s||void 0===s.rx||void 0===s.ry){t=[];break t}a.coordinates[0]=s.x,a.coordinates[1]=s.y,a.radiusX=s.rx,a.radiusY=s.ry,a.value[0]=s;break}}a.relative||(i=a.end)}return t}static filterTransforms(t,e){const s=[];for(const i of t)if(void 0===e||!e.includes(i.type)){switch(i.type){case SVGTransform.SVG_TRANSFORM_ROTATE:case SVGTransform.SVG_TRANSFORM_SKEWX:case SVGTransform.SVG_TRANSFORM_SKEWY:if(0===i.angle)continue;break;case SVGTransform.SVG_TRANSFORM_SCALE:if(1===i.matrix.a&&1===i.matrix.d)continue;break;case SVGTransform.SVG_TRANSFORM_TRANSLATE:if(0===i.matrix.e&&0===i.matrix.f)continue}s.push(i)}return s}static applyTransforms(t,e,s){t=t.slice(0).reverse();const i=N.clonePoints(e);for(const e of t){const t=e.matrix;let a=0,n=0,r=0,o=0;if(s)switch(e.type){case SVGTransform.SVG_TRANSFORM_SCALE:e.method.x&&(r=s.x*(1-t.a)),e.method.y&&(o=s.y*(1-t.d));break;case SVGTransform.SVG_TRANSFORM_SKEWX:e.method.y&&(n-=s.y);break;case SVGTransform.SVG_TRANSFORM_SKEWY:e.method.x&&(a-=s.x);break;case SVGTransform.SVG_TRANSFORM_ROTATE:e.method.x&&(a-=s.x,r=s.x+R.offsetAngleY(e.angle,s.x)),e.method.y&&(n-=s.y,o=s.y+R.offsetAngleY(e.angle,s.y))}for(const s of i){const i=s.x;if(s.x=c.applyX(t,i,s.y+n)+r,s.y=c.applyY(t,i+a,s.y)+o,e.type===SVGTransform.SVG_TRANSFORM_SCALE&&void 0!==s.rx&&void 0!==s.ry){const e=s.rx;s.rx=c.applyX(t,e,s.ry+n),s.ry=c.applyY(t,e+a,s.ry)}}}return i}static convertTransforms(t){const e=[];for(let s=0;s<t.numberOfItems;s++){const i=t.getItem(s);e.push(u.create(i.type,i.matrix,i.angle))}return e}static clonePoints(t){const e=[];if(Array.isArray(t))for(const s of t){const t={x:s.x,y:s.y};void 0!==s.rx&&void 0!==s.ry&&(t.rx=s.rx,t.ry=s.ry),e.push(t)}else for(let s=0;s<t.numberOfItems;s++){const i=t.getItem(s);e.push({x:i.x,y:i.y})}return e}static minMaxPoints(t){let e=t[0].x,s=t[0].x,i=t[0].y,a=t[0].y;for(let n=1;n<t.length;n++){const r=t[n];r.x<e?e=r.x:r.x>s&&(s=r.x),r.y<i?i=r.y:r.y>a&&(a=r.y)}return[e,i,s,a]}static centerPoints(...t){const e=this.minMaxPoints(t);return{x:(e[0]+e[2])/2,y:(e[1]+e[3])/2}}static convertPoints(t){const e=[];if(t.length%2==0)for(let s=0;s<t.length;s+=2)e.push({x:t[s],y:t[s+1]});return e}static parsePoints(t){const e=[];for(const s of t.trim().split(A.CHAR.SPACE)){const[t,i]=_.replaceMap(s.split(A.XML.SEPARATOR),t=>parseFloat(t));e.push({x:t,y:i})}return e}static parseCoordinates(t){const e=[];let s;for(;null!==(s=V.exec(t));){const t=parseFloat(s[0]);isNaN(t)||e.push(t)}return e}static getBoxRect(t){const e=[];for(const s of t)_.concatArray(e,N.getPathPoints(N.getPathCommands(s),!0));const s=this.minMaxPoints(e);return{top:s[1],right:s[2],bottom:s[3],left:s[0]}}}const M=squared.lib.dom;function P(t,e,s,i,a){for(const n of t)n.x+=e,n.y+=s,void 0!==n.rx&&void 0!==n.ry&&(n.rx*=i,n.ry*=a)}var F=t=>(class extends t{constructor(){super(...arguments),this._baseVal={}}setBaseValue(t,e){if(void 0!==e){if(this.verifyBaseValue(t,e))return this._baseVal[t]=e,!0}else switch(t){case"d":return this._baseVal[t]=M.getNamedItem(this.element,"d"),!0;case"points":const e=this.element[t];if(Array.isArray(e))return this._baseVal[t]=N.clonePoints(e),!0;break;default:const s=this.element[t];if(s&&s.baseVal)return this._baseVal[t]=s.baseVal.value,!0}return!1}getBaseValue(t,e){return void 0!==this._baseVal[t]||this.setBaseValue(t)?this._baseVal[t]:e}refitBaseValue(t,e,s,i=1,a=1){for(const n in this._baseVal){const r=this._baseVal[n];if("string"==typeof r){if("d"===n){const o=N.getPathCommands(r),l=N.getPathPoints(o);P(l,t,e,i,a),this._baseVal[n]=N.drawPath(N.syncPathPoints(o,l),s)}}else if("number"==typeof r)switch(n){case"cx":case"x1":case"x2":case"x":this._baseVal[n]+=t;break;case"cy":case"y1":case"y2":case"y":this._baseVal[n]+=e;break;case"r":this._baseVal[n]*=Math.min(i,a);break;case"rx":case"width":this._baseVal[n]*=i;break;case"ry":case"height":this._baseVal[n]*=a}else Array.isArray(r)&&"points"===n&&P(r,t,e,i,a)}}verifyBaseValue(t,e){switch(t){case"d":return"string"==typeof e;case"cx":case"cy":case"r":case"rx":case"ry":case"x1":case"x2":case"y1":case"y2":case"x":case"y":case"width":case"height":return"number"==typeof e;case"points":return Array.isArray(e)}}});const C=squared.lib.css,G=squared.lib.dom,O=squared.lib.util,L={MS:/-?\d+ms$/,S:/-?\d+s$/,MIN:/-?\d+min$/,H:/-?\d+(.\d+)?h$/,CLOCK:/^(?:(-?)(\d?\d):)?(?:(\d?\d):)?(\d?\d)\.?(\d?\d?\d)?$/};class ${constructor(t,e){if(this.element=null,this.animationElement=null,this.paused=!1,this.fillMode=0,this.synchronizeState=0,this._attributeName="",this._duration=-1,this._delay=0,this._to="",t&&(this.element=t),e){this.animationElement=e,this.setAttribute("attributeName"),this.setAttribute("to"),this.setAttribute("fill","freeze");const t=G.getNamedItem(e,"dur");""!==t&&"indefinite"!==t&&(this.duration=$.convertClockTime(t))}}static convertClockTime(t){let e=0,s=0;if(O.isNumber(t))e=parseInt(t);else if(L.MS.test(t))s=parseFloat(t);else if(L.S.test(t))e=parseFloat(t);else if(L.MIN.test(t))e=60*parseFloat(t);else if(L.H.test(t))e=60*parseFloat(t)*60;else{const i=L.CLOCK.exec(t);i&&(i[2]&&(e+=60*parseInt(i[2])*60),i[3]&&(e+=60*parseInt(i[3])),i[4]&&(e+=parseInt(i[4])),i[5]&&(s=parseInt(i[5])*(i[5].length<3?Math.pow(10,3-i[5].length):1)),i[1]&&(e*=-1,s*=-1))}return 1e3*e+s}setAttribute(t,e){if(this.animationElement){const s=G.getNamedItem(this.animationElement,t);""!==s&&(void 0!==e?this[t+O.capitalize(e)]=s===e:this[t]=s)}}addState(...t){for(const e of t)O.hasBit(this.synchronizeState,e)||(this.synchronizeState|=e)}removeState(...t){for(const e of t)O.hasBit(this.synchronizeState,e)&&(this.synchronizeState^=e)}hasState(...t){return t.some(t=>O.hasBit(this.synchronizeState,t))}setFillMode(t,e){const s=O.hasBit(this.fillMode,e);t?s||(this.fillMode|=e):s&&(this.fillMode^=e)}set attributeName(t){O.isString(this.baseValue)||"transform"===t||(this.element&&(this.baseValue=d(this.element,t)),!O.isString(this.baseValue)&&this.animationElement&&(this.baseValue=O.optionalAsString(this.animationElement.parentElement,`${t}.baseVal.valueAsString`),C.isLength(this.baseValue)&&(this.baseValue=""+C.parseUnit(this.baseValue,C.getFontSize(this.animationElement.parentElement))))),this._attributeName=t}get attributeName(){return this._attributeName}set delay(t){this._delay=t}get delay(){return this._delay}set duration(t){this._duration=Math.round(t)}get duration(){return this._duration}set to(t){this._to=t}get to(){return this._to}set fillBackwards(t){this.setFillMode(t,8)}get fillBackwards(){return O.hasBit(this.fillMode,8)}set fillForwards(t){this.setFillMode(t,4)}get fillForwards(){return O.hasBit(this.fillMode,4)}set fillFreeze(t){this.setFillMode(t,2)}get fillFreeze(){return O.hasBit(this.fillMode,2)}get fillReplace(){return 0===this.fillMode||8===this.fillMode}get parentContainer(){let t=this._parent;for(;t&&!N.isContainer(t);)t=t.parent;return t}set parent(t){this._parent=t}get parent(){return this._parent}set group(t){this._group=t}get group(){return this._group||{id:-1/0,name:""}}set setterType(t){}get setterType(){return!0}get instanceType(){return 8}}const B={ease:"0.25 0.1 0.25 1","ease-in":"0.42 0 1 1","ease-in-out":"0.42 0 0.58 1","ease-out":"0 0 0.58 1",linear:"0 0 1 1","step-start":"0 1 0 1","step-end":"1 0 1 0"};var q=Object.freeze({KEYSPLINE_NAME:B});const I=squared.lib.color,z=squared.lib.css,X=squared.lib.dom,W=squared.lib.regex,D=squared.lib.util,Y=t=>parseFloat((1-t).toPrecision(5));class j extends ${constructor(t,e){if(super(t,e),this.type=0,this.from="",this.additiveSum=!1,this.accumulateSum=!1,this.evaluateStart=!1,this._iterationCount=1,this._reverse=!1,this._alternate=!1,this._setterType=!1,this._repeatDuration=-1,e){const t=X.getNamedItem(e,"values"),s=-1!==this.duration?j.toFractionList(X.getNamedItem(e,"keyTimes")):[];if(""!==t)this.values=D.trimEnd(t,";").split(/\s*;\s*/),this.length>1&&s.length===this.length?(this.from=this.values[0],this.to=this.values[this.length-1],this.keyTimes=s):1===this.length&&(this.to=this.values[0],this.convertToValues());else{if(this.from=X.getNamedItem(e,"from"),""===this.to){const t=X.getNamedItem(e,"by"),s=N.parseCoordinates(t);if(s.length){""===this.from&&(this.baseValue&&(this.from=this.baseValue),this.evaluateStart=!0);const t=N.parseCoordinates(this.from);if(s.length===t.length){const e=[];for(let i=0;i<t.length;i++)e.push(t[i]+s[i]);this.to=e.join(",")}}}N.parseCoordinates(this.to).length&&this.setAttribute("additive","sum"),this.convertToValues(s)}const i=X.getNamedItem(e,"repeatDur");""!==i&&"indefinite"!==i&&(this._repeatDuration=$.convertClockTime(i));const a=X.getNamedItem(e,"repeatCount");this.iterationCount="indefinite"===a?-1:parseFloat(a),"animate"===e.tagName&&this.setCalcMode()}}static getSplitValue(t,e,s){return t+(e-t)*s}static convertStepTimingFunction(t,e,s,i,a,n){let r,o;switch(t){case"fill":case"stroke":const e=I.parseColor(i[a]),s=I.parseColor(i[a+1]);e&&s&&(r=[e],o=[s]);break;case"points":r=N.convertPoints(N.parseCoordinates(i[a])),o=N.convertPoints(N.parseCoordinates(i[a+1]));break;case"rotate":case"scale":case"translate":r=D.replaceMap(i[a].trim().split(W.CHAR.SPACE),t=>parseFloat(t)),o=D.replaceMap(i[a+1].trim().split(W.CHAR.SPACE),t=>parseFloat(t));break;default:D.isNumber(i[a])?r=[parseFloat(i[a])]:z.isLength(i[a])&&(r=[z.parseUnit(i[a],n)]),D.isNumber(i[a+1])?o=[parseFloat(i[a+1])]:z.isLength(i[a+1])&&(o=[z.parseUnit(i[a+1],n)])}if(r&&o&&r.length&&r.length===o.length){switch(e){case"step-start":e="steps(1, start)";break;case"step-end":e="steps(1, end)"}const i=/steps\((\d+)(?:, (start|end))?\)/.exec(e);if(i){const e=s[a+1]-s[a],n=parseInt(i[1]),l=100/n,h=[],c=[];for(let u=0;u<=n;u++){const f=s[a]+e*(u/n),p=l*(u+(0===u&&"start"===i[2]?1:0))/100,d=[];switch(t){case"fill":case"stroke":{const t=r[0],e=o[0],s=I.getHexCode(j.getSplitValue(t.rgba.r,e.rgba.r,p),j.getSplitValue(t.rgba.g,e.rgba.g,p),j.getSplitValue(t.rgba.b,e.rgba.b,p)),i=I.getHexCode(j.getSplitValue(t.rgba.a,e.rgba.a,p));d.push(`#${s+("FF"!==i?i:"")}`);break}case"points":for(let t=0;t<r.length;t++){const e=r[t],s=o[t];d.push(`${j.getSplitValue(e.x,s.x,p)},${j.getSplitValue(e.y,s.y,p)}`)}break;default:for(let t=0;t<r.length;t++){d.push(""+j.getSplitValue(r[t],o[t],p))}}if(!d.length)return;h.push(f),c.push(d.join(" "))}return[h,c]}}}static toFractionList(t,e=";",s=!0){let i=0;const a=D.replaceMap(t.split(e),t=>{const e=parseFloat(t);return isNaN(e)||s&&!(e>=i&&e<=1)?-1:(i=e,e)});return a.length>1&&(!s||0===a[0]&&a.some(t=>-1!==t))?a:[]}setCalcMode(t,e){if(this.animationElement)switch(void 0===e&&(e=X.getNamedItem(this.animationElement,"calcMode")||"linear"),e){case"discrete":if(2===this.keyTimes.length&&0===this.keyTimes[0]){const e=[],s=[];for(let i=0;i<this.keyTimes.length-1;i++){const a=j.convertStepTimingFunction(t||this.attributeName,"step-end",this.keyTimes,this.values,i,z.getFontSize(this.animationElement));a&&(D.concatArray(e,a[0]),D.concatArray(s,a[1]))}e.push(this.keyTimes.pop()),s.push(this.values.pop()),this.values=s,this.keyTimes=e,this._keySplines=[B["step-end"]]}break;case"paced":this._keySplines=void 0;break;case"spline":this.keySplines=D.flatMap(X.getNamedItem(this.animationElement,"keySplines").split(";"),t=>t.trim());case"linear":if(0!==this.keyTimes[0]&&1!==this.keyTimes[this.keyTimes.length-1]){const t=[],e=this.values.length;for(let s=0;s<e;s++)t.push(s/(e-1));this._keyTimes=t,this._keySplines=void 0}}}convertToValues(t){this.to&&(this.values=[this.from,this.to],this.keyTimes=t&&2===t.length&&0===this.keyTimes[0]&&this.keyTimes[1]<=1?t:[0,1],""===this.from&&(this.evaluateStart=!0))}setGroupOrdering(t){if(this.group.ordering=t,this.fillBackwards)for(let e=t.length-1,s=!1;e>=0;e--)if(s){if("backwards"===t[e].fillMode||"both"===t[e].fillMode){this.fillBackwards=!1;break}}else t[e].name===this.group.name&&(s=!0)}getIntervalEndTime(t){const e=this.getTotalDuration();if(t<e){const s=this.duration;let i=this.delay;for(;i+s<=t;)i+=s;return Math.min(i+this.keyTimes[this.keyTimes.length-1]*this.duration,e)}return e}getTotalDuration(t=!1){const e=t&&-1===this.iterationCount?1:this.iterationCount;return-1!==e?Math.min(this.delay+this.duration*e,this.end||1/0):1/0}set delay(t){super.delay=t;const e=X.getNamedItem(this.animationElement,"end");if(e){const t=D.sortNumber(D.replaceMap(e.split(";"),t=>$.convertClockTime(t)))[0];!isNaN(t)&&(-1===this.iterationCount||this.duration>0&&t<this.duration*this.iterationCount)&&(this.delay>t?(this.end=t,-1===this.iterationCount&&(this.iterationCount=Math.ceil((this.end-this.delay)/this.duration))):this.duration=-1)}}get delay(){return super.delay}set duration(t){super.duration=t}get duration(){const t=super.duration;return-1===t&&-1!==this._repeatDuration?this._repeatDuration:t}set iterationCount(t){this._iterationCount=isNaN(t)?1:t,this.fillFreeze=-1!==this.iterationCount&&"freeze"===X.getNamedItem(this.animationElement,"fill"),1!==this.iterationCount?this.setAttribute("accumulate","sum"):this.accumulateSum=!1}get iterationCount(){return this.duration>0?-1!==this._repeatDuration&&(-1===this._iterationCount||this._repeatDuration<this._iterationCount*this.duration)?this._repeatDuration/this.duration:this._iterationCount:1}set to(t){super.to=t}get to(){return this._setterType?this.valueTo||super.to:this.setterType?this.values[0]:super.to}set values(t){this._values=t,t&&this._keyTimes&&this._keyTimes.length!==t.length&&(this._keyTimes=void 0,this._keySplines=void 0)}get values(){return void 0===this._values&&(this._values=[]),this._values}get valueTo(){return this._values?this._values[this._values.length-1]:""}get valueFrom(){return this.values[0]||""}set keyTimes(t){!t.every(t=>t>=0&&t<=1)||void 0!==this._values&&this._values.length!==t.length||(this._keyTimes=t)}get keyTimes(){return void 0===this._keyTimes&&(this._keyTimes=[]),this._keyTimes}set keySplines(t){if(t&&t.length){const e=this.keyTimes.length-1;if(t.length>=e&&!t.every(t=>""===t||t===B.linear)){const s=[];for(let i=0;i<e;i++){const e=D.replaceMap(t[i].split(" "),t=>parseFloat(t));4===e.length&&!e.some(t=>isNaN(t))&&e[0]>=0&&e[0]<=1&&e[2]>=0&&e[2]<=1?s.push(e.join(" ")):s.push(B.linear)}this._keySplines=s}}else this._keySplines=void 0}get keySplines(){return this._keySplines}set timingFunction(t){this._timingFunction=t}get timingFunction(){return this._timingFunction||this.keySplines&&this.keySplines[0]}set reverse(t){if(this.length&&t!==this._reverse){this.values.reverse();const t=[];for(const e of this.keyTimes)t.push(1-e);if(t.reverse(),this.keyTimes=t,this._keySplines){const t=[];for(let e=this._keySplines.length-1;e>=0;e--){const s=D.replaceMap(this._keySplines[e].split(" "),t=>parseFloat(t));t.push(4===s.length?`${Y(s[2])} ${Y(s[3])} ${Y(s[0])} ${Y(s[1])}`:B.linear)}this._keySplines=t}}this._reverse=t}get reverse(){return this._reverse}set alternate(t){this._alternate=t}get alternate(){return this._alternate}get playable(){return!this.paused&&this.duration>0&&this.keyTimes&&this.keyTimes.length>1}get fillReplace(){return super.fillReplace||-1===this.iterationCount}get fromToType(){return 2===this.keyTimes.length&&0===this.keyTimes[0]&&1===this.keyTimes[1]}get partialType(){return this.keyTimes.length>1&&this.keyTimes[this.keyTimes.length-1]<1}set setterType(t){this._setterType=t}get setterType(){return this._setterType||null!==this.animationElement&&0===this.duration&&this.keyTimes.length>=2&&0===this.keyTimes[0]&&""!==this.values[0]}set length(t){0===t&&(this._values=void 0)}get length(){return this._values?this._values.length:0}get instanceType(){return 16392}}const U=squared.lib.dom,H=squared.lib.util;class K extends j{constructor(t,e){if(super(t,e),this.attributeName="transform",e){const t=U.getNamedItem(e,"type");this.setType(t),this.setCalcMode(t)}}static toRotateList(t){const e=[];for(const s of t)if(""===s)e.push([0,0,0]);else{const t=N.parseCoordinates(s);if(1===t.length&&(t[1]=0,t[2]=0),3!==t.length)return;e.push(t)}return e}static toScaleList(t){const e=[];for(const s of t)if(""===s)e.push([1,1,0,0]);else{const t=N.parseCoordinates(s);if(1===t.length&&(t[1]=t[0]),2===t.length&&(t[2]=0,t[3]=0),4!==t.length)return;e.push(t)}return e}static toTranslateList(t){const e=[];for(const s of t)if(""===s)e.push([0,0]);else{const t=N.parseCoordinates(s);if(1===t.length&&(t[1]=0),2!==t.length)return;e.push(t)}return e}static toSkewList(t){const e=[];for(const s of t)if(""===s)e.push([0]);else{const t=N.parseCoordinates(s);if(1!==t.length)return;e.push(t)}return e}expandToValues(){if(this.additiveSum&&-1!==this.iterationCount&&this.keyTimes.length&&this.duration>0){const t=this.duration*this.iterationCount;t:{const e=this.keyTimes,s=[],i=[],a=[];let n;for(let r=0;r<this.iterationCount;r++){r>0&&this.keySplines&&a.push("");for(let o=0;o<e.length;o++){const l=N.parseCoordinates(this.values[o]);if(!l.length)break t;{let h;switch(this.type){case SVGTransform.SVG_TRANSFORM_TRANSLATE:1===l.length?h=[l[0],0]:2===l.length&&(h=l);break;case SVGTransform.SVG_TRANSFORM_SCALE:1===l.length?h=[l[0],l[0]]:2===l.length&&(h=l);break;case SVGTransform.SVG_TRANSFORM_ROTATE:1===l.length?h=[l[0],0,0]:3===l.length&&(h=l);break;case SVGTransform.SVG_TRANSFORM_SKEWX:case SVGTransform.SVG_TRANSFORM_SKEWY:1===l.length&&(h=l)}if(!h)break t;{let l=(e[o]+r)*this.duration;if(n)for(let t=0;t<h.length;t++)h[t]+=n[t];r<this.iterationCount-1&&o===e.length-1&&(this.accumulateSum&&(n=h),l--),s.push(l/t),i.push(h.join(" ")),this.keySplines&&o<e.length-1&&a.push(this.keySplines[o])}}}}this.values=i,this.keyTimes=s,this.keySplines=a.length?a:void 0,this.duration=t,this.iterationCount=1,this.accumulateSum=!1}}}setType(t){let e;switch(t){case"translate":this.type=SVGTransform.SVG_TRANSFORM_TRANSLATE,this.animationElement&&(e=K.toTranslateList(this.values));break;case"scale":this.type=SVGTransform.SVG_TRANSFORM_SCALE,this.animationElement&&(e=K.toScaleList(this.values));break;case"rotate":this.type=SVGTransform.SVG_TRANSFORM_ROTATE,this.animationElement&&(e=K.toRotateList(this.values));break;case"skewX":this.type=SVGTransform.SVG_TRANSFORM_SKEWX,this.animationElement&&(e=K.toSkewList(this.values));break;case"skewY":this.type=SVGTransform.SVG_TRANSFORM_SKEWY,this.animationElement&&(e=K.toSkewList(this.values));break;default:return}e&&(this.values=H.replaceMap(e,t=>t.join(" "))),this.baseValue=u.typeAsValue(this.type)}get instanceType(){return 49160}}const Z=squared.lib.util;class Q{static getGroupEndTime(t){return"infinite"===t.iterationCount?1/0:t.delay+t.duration*parseInt(t.iterationCount)}static getKeyName(t){return t.attributeName+(N.isAnimateTransform(t)?`:${u.typeAsName(t.type)}`:"")}constructor(t,...e){t=(e.length?Z.filterArray(t,t=>e.includes(t.attributeName)):t.slice(0)).sort((t,e)=>t.delay===e.delay?t.group.id<e.group.id?1:-1:t.delay<e.delay?-1:1),e.length=0;for(const s of t){const t=Q.getKeyName(s);e.includes(t)||e.push(t)}this.map={};const s={},i={};function a(t,e,a,n=0,r,o=!1,l=!1,h=0,c=!1,u){a&&(void 0===s[t][e]&&(s[t][e]=[]),s[t][e].push({time:e,value:a,animation:r,start:o,end:l,endTime:n,fillMode:h,infinite:c,valueFrom:u}),i[t].add(e))}for(const r of e){this.map[r]=new Map,s[r]={},i[r]=new Set;const e=-1!==(n=r).indexOf(":")?n.split(":")[0]:n,o=t.filter(t=>t.fillBackwards&&t.attributeName===e).sort((t,e)=>t.group.id<e.group.id?1:-1)[0];o&&a(r,0,o.values[0],o.delay,o,0===o.delay,!1,8)}var n;for(const e of t){const t=Q.getKeyName(e);if(void 0===s[t][-1]&&e.baseValue&&a(t,-1,e.baseValue),e.setterType){const s=e.fillReplace&&e.duration>0;a(t,e.delay,e.to,s?e.delay+e.duration:0,e,s,!s,2),s&&a(t,e.delay+e.duration,"",0,e,!1,!0,2)}else if(N.isAnimate(e)&&e.duration>0){const s=-1===e.iterationCount,i=e.getTotalDuration();a(t,e.delay,e.valueTo,i,e,!0,!1,0,s,e.valueFrom),s||e.fillReplace||a(t,i,e.valueTo,0,e,!1,!0,e.fillForwards?4:2)}}for(const t in s)for(const e of Z.sortNumber(Array.from(i[t]))){const i=s[t][e];for(let e=0;e<i.length;e++){const s=i[e];if(""===s.value||s.start&&s.animation&&N.isAnimate(s.animation)&&s.animation.evaluateStart){let a;for(const e of this.map[t].values())for(const t of e)if(s.animation!==t.animation&&""!==t.value&&(-1===t.time||4===t.fillMode||2===t.fillMode)){a=t.value;break}a?s.value=a:""===s.value&&i.splice(e--,1)}}i.length&&(i.sort((t,e)=>t.animation&&e.animation?t.fillMode===e.fillMode?t.animation.group.id<e.animation.group.id?1:-1:t.fillMode<e.fillMode?1:-1:0),this.map[t].set(e,i))}for(const t in this.map)for(const[e,s]of this.map[t].entries())for(const i of s)if(i.animation)if(2===i.fillMode){const s=[];for(const[a,n]of this.map[t].entries())if(a<e)for(const t of n)t.start&&t.animation&&t.animation.animationElement&&s.push(t.animation);else if(a>e)for(let t=0;t<n.length;t++){const e=n[t];e.end&&s.includes(e.animation)&&n.splice(t--,1)}else for(let t=0;t<n.length;t++){const e=n[t];e.end&&e.animation&&e.animation.animationElement&&e.animation.group.id<i.animation.group.id&&n.splice(t--,1)}}else if(4===i.fillMode||i.infinite){let s=!1;if(i.animation.group.ordering){const t=i.animation.getTotalDuration();for(const e of i.animation.group.ordering)if(e.name===i.animation.group.name)s=!0;else if(Q.getGroupEndTime(e)>=t)break}const a=[];for(const[n,r]of this.map[t].entries())if(!s&&n<e)for(const t of r)t.start&&t.animation&&a.push(t.animation);else if(n>e)for(let t=0;t<r.length;t++){const e=r[t];(s||e.animation&&(e.end&&a.includes(e.animation)||null===i.animation.animationElement&&e.animation.group.id<i.animation.group.id))&&r.splice(t--,1)}else for(let t=0;t<r.length;t++){const e=r[t];e.end&&e.animation&&e.animation.group.id<i.animation.group.id&&r.splice(t--,1)}}for(const t in this.map)for(const[e,s]of Array.from(this.map[t].entries()))0===s.length&&this.map[t].delete(e)}has(t,e,s){return void 0!==e?!(!this.map[t]||!this.map[t].has(e))&&(void 0===s||-1!==this.map[t].get(e).findIndex(t=>t.animation===s)):void 0!==this.map[t]}get(t,e,s=!1){let i;if(this.map[t])for(const[a,n]of this.map[t].entries()){if(!(a<=e))break;for(const t of n)if(""!==t.value&&(-1===t.time||t.end&&(4===t.fillMode||2===t.fillMode))||s&&t.start&&e!==a){i=t.value;break}}return i}paused(t,e){let s=0;if(this.map[t])for(const[i,a]of this.map[t].entries()){if(!(i<=e))break;for(const t of a)if(t.start&&(t.infinite||0===t.fillMode&&t.endTime>e)){if(!t.animation){s=1;break}s=2}else if(t.end&&(4===t.fillMode||1===s&&2===t.fillMode)){s=0;break}}return 0===s}evaluateStart(t,e){if(t.evaluateStart){const s=this.get(t.attributeName,t.delay)||e&&""+e||t.baseValue;s&&(t.reverse?t.values[t.values.length-1]=s:t.values[0]=s),t.evaluateStart=!1}return t.values}}const J=squared.lib.math,tt=squared.lib.regex,et=squared.lib.util,st=["x1","y1","x2","y2"],it=["width","height","x","y"],at=["points"],nt=["cx","cy","r"],rt=["cx","cy","rx","ry"];function ot(t,e,s,i,a){let n,r,o,l=0;for(const[e,i]of t.entries()){if(s===e){r={key:e,value:i};break}if(s>l&&s<e&&void 0!==n){r={key:l,value:n},o={key:e,value:i};break}l=e,n=i}if(r&&o)St(t,s,yt(s,r.key,r.value,o.key,o.value),!0);else if(r)St(t,s,r.value,!0);else if(!a){let a=i.get(e,s,!0);a&&""!==(a=ht(a,!0))&&St(t,s,a)}}function lt(t){const e=t[t.length-1][0],s=new Set;for(let i=0;i<t.length;i++){let a=t[i][0]/e;if(a>0)for(let t=7;;t++){const e=parseFloat((""+a).substring(0,t));if(!s.has(e)){a=e;break}}t[i][0]=a,s.add(a)}return t}function ht(t,e=!1){return"string"==typeof t&&(et.isNumber(t)?t=parseFloat(t):0===(t=N.parsePoints(t)).length&&(t="")),e&&"string"==typeof t?"":t}function ct(t,e){let s;if(t)for(const i of t){if(!(i.time<=e))break;s=i.value}return s}function ut(t,e,s,i,a){const n=[],r=e.element.tagName;let o;switch(r){case"line":o=st;break;case"rect":o=it;break;case"polyline":case"polygon":o=at;break;case"circle":o=nt;break;case"ellipse":o=rt;break;default:return}const l=u.origin(e.element);for(let h=0;h<t.length;h++){const c=t[h][0],u=t[h][1],f=[];for(const t of o){let s=u.get(t);if(void 0===s&&(void 0===s&&(s=ct(i[t],c)),void 0===s&&(s=e.getBaseValue(t))),void 0===s)return;f.push(s)}let p;switch(r){case"line":p=ft(f);break;case"rect":p=pt(f);break;case"polygon":case"polyline":p=f[0];break;case"circle":case"ellipse":p=At(f)}if(p){let t;switch(e.transformed&&(p=N.applyTransforms(e.transformed,p,l)),s&&s.refitPoints(p),r){case"line":case"polyline":t=N.drawPolyline(p,a);break;case"rect":case"polygon":t=N.drawPolygon(p,a);break;case"circle":case"ellipse":const i=p[0];t=N.drawEllipse(i.x,i.y,i.rx,i.ry,a)}void 0!==t&&n.push({key:c,value:t})}}return n}function ft(t){return[{x:t[0],y:t[1]},{x:t[2],y:t[4]}]}function pt(t){const e=t[0],s=t[1],i=t[2],a=t[3];return[{x:i,y:a},{x:i+e,y:a},{x:i+e,y:a+s},{x:i,y:a+s}]}function dt(t,e,s){const i=new Map;for(const a of e){const e=new Map;for(const i in t){let n;void 0!==(n=t[i].has(a)?t[i].get(a):ct(s[i],a))&&e.set(i,n)}i.set(a,e)}return i}function gt(t,e,s,i){e&&(t.set(s,e),void 0!==i&&t.set(i,e))}function mt(t,e,s,i,a){switch(t.alternate&&s%2!=0&&(e=e.slice(0).reverse()),t.attributeName){case"transform":if(t.additiveSum&&"string"==typeof a){const n=et.replaceMap(a.split(tt.CHAR.SPACE),t=>parseFloat(t)),r=et.objectMap(e,t=>et.replaceMap(t.trim().split(tt.CHAR.SPACE),t=>parseFloat(t)));if(r.every(t=>n.length===t.length)){const e=r[i];t.accumulateSum||(s=0);for(let t=0;t<n.length;t++)e[t]+=n[t];for(let t=0;t<s;t++)for(let t=0;t<r.length;t++)for(let s=0;s<r[t].length;s++)e[s]+=r[t][s];return e.join(" ")}}return e[i];case"points":return N.parsePoints(e[i]);default:{let n=parseFloat(e[i]);if(isNaN(n))return a||0;if(t.additiveSum&&"number"==typeof a){n+=a,t.accumulateSum||(s=0);for(let t=0;t<s;t++)for(let t=0;t<e.length;t++)n+=parseFloat(e[t])}return n}}}function yt(t,e,s,i,a){if(t>e){if("number"==typeof s&&"number"==typeof a)return j.getSplitValue(s,a,(t-e)/(i-e));if("string"==typeof s&&"string"==typeof a){const n=et.replaceMap(s.split(" "),t=>parseFloat(t)),r=et.replaceMap(a.split(" "),t=>parseFloat(t));if(n.length===r.length){const s=[];for(let a=0;a<n.length;a++)s.push(yt(t,e,n[a],i,r[a]));return s.join(" ")}}else if(Array.isArray(s)&&Array.isArray(a)){const n=[];for(let r=0;r<Math.min(s.length,a.length);r++)n.push({x:yt(t,e,s[r].x,i,a[r].x),y:yt(t,e,s[r].y,i,a[r].y)});return n}}return s}function vt(t,e,s,i,a,n,r,o,l,h,c,u,f){r<0&&(e-=r,r=0);const p=Math.max(0,Math.min((e-(r+t.duration*o))/t.duration,1));let d,g=-1,m=-1;for(let t=0;t<i.length;t++){if(-1!==g&&p<=i[t]){m=t;break}p>=i[t]&&(g=t)}return kt(t,l=St(c,l,d=-1!==g&&-1!==m?yt(p,i[g],mt(t,a,o,g,s),i[m],mt(t,a,o,m,s)):mt(t,a,o,m=-1!==g?g+1:i.length-1,s)),n,m,h,u,f),[l,d]}function bt(t,e,s,i,a,n,r){const o=e.keyTimes.slice(0),l=e.keySplines?e.keySplines.slice(0):[].fill(""),h=s+e.duration;let c=e.getIntervalEndTime(s);for(let s=0;s<r.length;s++){const f=r[s];if(f!==e){const p=f.getTotalDuration();if(p>c){const d=Math.min(h,p),g=Tt(t,e,n);t:for(let t=Mt(c,f.delay,f.duration),s=!1;;t++)for(let i=0;i<f.keyTimes.length;i++){const r=Rt(f.delay,f.duration,f.keyTimes,t,i);if(r>=c){function u(h){let u;if(r===h)u=_t(mt(f,g,t,i,n));else{const e=(r-h)/f.duration;for(let s=1;s<f.keyTimes.length;s++)if(e>=f.keyTimes[s-1]&&e<=f.keyTimes[s]){u=_t(yt(e,f.keyTimes[s-1],mt(f,g,t,s-1,n),f.keyTimes[s],mt(f,g,t,s,n)));break}}let p=h===d?1:h%e.duration/e.duration;0===p&&i>0&&(p=1),void 0===u||p===o[o.length-1]&&u===a[a.length-1]||(h===c?p+=.001:c=h,o.push(p),a.push(u),l&&l.push(s&&f.keySplines&&f.keySplines[i]?f.keySplines[i]:""))}if(!s&&r>=c&&(u(c),s=!0,r===c))continue;if(s){if(u(Math.min(r,d)),r>=d||1===o[o.length-1])break t;c=r}}}if(p===d&&p<=i&&(f.addState(16),r.splice(s--,1)),d===h)break}else i!==1/0&&p<i&&r.splice(s--,1)}}return[o,a,l]}function St(t,e,s,i=!1){if(""!==s){let a=t.get(e),n=!1;if(void 0===a&&(a=t.get(e-1),n=!0),a!==s||i){if(!i){if("number"==typeof a&&J.isEqual(s,a))return e;for(;e>0&&t.has(e);)e++}t.set(e,s)}else n&&!t.has(e)&&(t.delete(e-1),t.set(e,s))}return e}function kt(t,e,s,i,a,n,r){if(!Vt(N.isAnimateTransform(t),a)){if(0===i)return;i--}const o=s&&s[i];o&&n.set(e,o),r&&function(t,e,s,i){N.asAnimateTransform(e)&&e.transformOrigin&&e.transformOrigin[i]&&t.set(s,e.transformOrigin[i])}(r,t,e,i)}function Tt(t,e,s){if(e.evaluateStart){const i=e.reverse?e.length-1:0;t.get(Q.getKeyName(e),e.delay)||e.values[i]||!e.additiveSum&&e.baseValue||(e.values[i]=_t(s)),e.by&&et.isNumber(e.values[i])&&(e.values[i]=""+(parseFloat(e.values[i])+e.by)),e.evaluateStart=!1}return e.values}function xt(t,e,s,i){t[t.length-1]<1&&(t.push(1),e.push(void 0!==i?_t(i):e[0]),s&&s.push(""))}const Rt=(t,e,s,i,a)=>Math.round(t+(s[a]+i)*e),At=t=>[{x:t[0],y:t[1],rx:t[2],ry:t[t.length-1]}],_t=t=>Array.isArray(t)?et.objectMap(t,t=>`${t.x},${t.y}`).join(" "):""+t,Vt=(t,e)=>et.hasBit(e,t?32:4),wt=(t,e)=>et.hasBit(e,t?16:2),Et=t=>t.playable||t.animationElement&&-1!==t.duration,Nt=t=>[t.keyTimes.slice(0),t.values.slice(0),t.keySplines?t.keySplines.slice(0):void 0],Mt=(t,e,s)=>Math.floor(Math.max(0,t-e)/s);var Pt=t=>(class extends t{getAnimateShape(t){const e=[];for(const s of this.animations)if(Et(s))switch(s.attributeName){case"r":case"cx":case"cy":if(f.circle(t)){e.push(s);break}case"rx":case"ry":f.ellipse(t)&&e.push(s);break;case"x1":case"x2":case"y1":case"y2":f.line(t)&&e.push(s);break;case"points":(f.polyline(t)||f.polygon(t))&&e.push(s);break;case"x":case"y":case"width":case"height":f.rect(t)&&e.push(s)}return e}getAnimateTransform(t){const e=[];for(const s of this.animations)N.isAnimateTransform(s)&&s.duration>0&&(e.push(s),t&&N.asAnimateMotion(s)&&(s.framesPerSecond=t.framesPerSecond));return e}getAnimateViewRect(t){void 0===t&&(t=this.animations);const e=[];for(const s of t)if(Et(s))switch(s.attributeName){case"x":case"y":e.push(s)}return e}animateSequentially(t,e,s,i){let a,n=18;i&&(i.keyTimeMode&&(n=i.keyTimeMode),a=i.precision),[t,e].forEach(t=>{const i=t===e;if(!t||0===t.length||!i&&et.hasBit(n,8)||i&&et.hasBit(n,64))return;const r=[],o={},l=new Set;let h=0;function c(t){void 0===o[t.attributeName]&&(o[t.attributeName]=[]),o[t.attributeName].push(t),h++}{const e=[];for(let s=0;s<t.length;s++){const i=t[s];if(i.setterType)c(i);else{const a=i.getTotalDuration();for(let n=0;n<t.length;n++){const r=t[n];if(s!==n&&i.attributeName===r.attributeName&&i.group.id<r.group.id&&i.fillReplace&&!r.partialType)if(r.setterType){if(i.delay===r.delay){e[s]=i;break}}else{const t=r.getTotalDuration();if(i.delay===r.delay&&(!r.fillReplace||a<=t||-1===r.iterationCount)||r.fillBackwards&&i.delay<=r.delay&&(r.fillForwards||i.fillReplace&&a<=r.delay)||i.animationElement&&null===r.animationElement&&(i.delay>=r.delay&&a<=t||r.fillForwards)){e[s]=i;break}}}}}const s=[];for(let i=0;i<t.length;i++){const a=t[i];e[i]?a.fillReplace?s.push(a):(a.setterType=!0,c(a)):a.setterType||(r.push(a),l.add(a.group.name))}this._removeAnimations(s)}if(r.length+h>1||1===r.length&&(r[0].alternate||void 0!==r[0].end)){for(const t of r)t.group.ordering&&et.spliceArray(t.group.ordering,t=>!l.has(t.name));const e={},h={};let c=0;for(const t of r){const s=t.attributeName;void 0===e[s]&&(e[s]=new Map,h[s]=[]);const i=e[s].get(t.delay)||[];i.push(t),h[s].push(t),e[s].set(t.delay,i)}for(const t in e){const s=new Map;for(const i of et.sortNumber(Array.from(e[t].keys()))){const a=e[t].get(i);for(const t of a)c=Math.max(c,t.getTotalDuration(!0));a.reverse(),s.set(i,a)}e[t]=s,h[t].reverse()}const A=new Q(t),_={},V=new Map,w=i?new Map:void 0,E={},M=new Set,P={},F=new Map,C=i?new Map:void 0,G={},O={},L=new Map;let $,B,q=-1;const I=t=>O[t]&&O[t][O[t].length-1];for(const t in e){if(_[t]=new Map,!i){let e;try{e=(s||this).getBaseValue(t)}catch(t){}et.hasValue(e)&&(G[t]=e)}const a=o[t]||[],r=[],l=[];for(const[s,i]of e[t].entries())r.push(s),l.push(i);const F=[];let C,$,B,q=-1,z=0,X=1/0;function f(e,s){if(M.add(e),e.addState(16),B=e,e.fillForwards){if(S(z,C,e.type,e),e.group.ordering){const t=e.getTotalDuration();for(const s of e.group.ordering){if(s.name===e.group.name)return!0;if(Q.getGroupEndTime(s)>=t)return!1}}}else{if(e.fillFreeze&&S(z,C,e.type,e),void 0!==s){let a=q;const n=g(z,z+1);void 0!==n&&e.fillReplace&&s>z&&0===F.length&&(a=St(_[t],a,n),i&&gt(L,e.type,a),C=n,q=a)}m()}return!1}function p(e,s,a){return void 0===s&&(s=e.delay),void 0===a&&(a=e.to),St(_[t],s,i?a:ht(a))}function d(t){t&&a.push(t),a.sort((t,e)=>t.delay===e.delay?t.group.id<e.group.id?-1:1:t.delay<e.delay?-1:1);for(let t=0;t<a.length-1;t++)a[t].delay===a[t+1].delay&&a.splice(t--,1)}function g(e,s){const n=I(t);let r=n&&n.value;return et.spliceArray(a,t=>t.delay>=e&&t.delay<s,t=>{t.animationElement&&b(),0===F.length&&(C=t.to),S(t.delay,t.to,t.type,t),t.delay===e?r=i?t.to:ht(t.to):(q=p(t),z=t.delay)}),r}function m(t,e){F.length&&et.spliceArray(F,t=>t.getTotalDuration()<=z,s=>{if(s.addState(16),s.fillForwards&&(S(s.getTotalDuration(),s.valueTo,s.type,s),void 0!==t&&void 0!==e))for(let i=t;i<r.length;i++){i!==t&&(e=-1);for(let t=e+1;t<l[i].length;t++){const e=l[i][t];s.group.id>e.group.id&&e.addState(16)}}})}function y(t){t.hasState(16,64)||(t.addState(4),F.push(t))}function v(){F.sort((t,e)=>t.animationElement&&e.animationElement&&t.delay!==e.delay?t.delay<e.delay?1:-1:t.group.id<e.group.id?1:-1)}function b(t){et.spliceArray(F,t?e=>e===t:t=>null!==t.animationElement)}function S(e,s,n=0,r){i||(s=ht(s));const o=I(t);if(""!==s&&(void 0===o||e>=o.time)&&(void 0===O[t]&&(O[t]=[]),O[t].push({key:n,value:s,time:e})),r&&N.isAnimate(r)&&!r.fillReplace)if(r.fillForwards){et.spliceArray(a,t=>t.group.id<r.group.id||t.delay<e),F.length=0;for(const t of l)for(const e of t)e.group.id<r.group.id&&e.addState(16)}else r.fillFreeze&&b()}function k(e,s,i){$&&!e&&(void 0===i&&(i=u.typeAsValue($.type)),s!==(q=St(_[t],s,i))&&gt(L,$.type,q)),$=void 0}function T(t){for(let e=0;e<r.length;e++){if(t.length)for(let s=0;s<l[e].length;s++)t.includes(l[e][s])&&l[e].splice(s--,1);0===l[e].length&&(l.splice(e,1),r.splice(e--,1))}}const W=h[t].find(t=>t.fillBackwards);if(W){C=mt(W,W.values,0,0),q=St(_[t],0,C),i&&(gt(L,W.type,0),$=W);let e=!0;for(const s of h[t])if(s.group.id>W.group.id&&s.delay<=W.delay){e=!1;break}const s=W.getTotalDuration(),n=[];for(let t=0;t<r.length;t++)for(let i=0;i<l[t].length;i++){const o=l[t][i];if(e){if(o===W&&(0!==t||0!==i)){l[t].splice(i--,1),r.unshift(W.delay),l.unshift([W]);continue}if(o.group.id<W.group.id&&(W.fillForwards||o.getTotalDuration()<=s)){o.fillForwards&&(o.setterType=!0,a.push(o)),n.push(o);continue}}o.animationElement&&o.delay<=W.delay&&(l[t].splice(i--,1),y(o))}T(n),W.addState(2)}if(!i&&(void 0===O[t]&&void 0!==G[t]&&S(0,G[t],0),void 0===C)){const e=I(t);C=e&&e.value||G[t]}d();{let e;et.spliceArray(a,t=>t.delay<=r[0],s=>{const a=N.isAnimate(s)&&s.fillForwards;if(s.delay<r[0]&&(void 0===W||a))if(W&&a)S(s.delay,s.to,s.type);else{const a=s.delay-1;if(void 0===e)if(_[t].has(0))i||p(s,a,C);else{let e;void 0!==(e=i&&N.isAnimateTransform(s)?u.typeAsValue(s.type):G[t])&&(p(s,0,e),p(s,a,e))}else p(e,a);q=p(s),z=s.delay,e=s}}),e&&p(e,r[0]-1)}t:{for(let e=0;e<r.length;e++){let s=r[e];for(let o=0;o<l[e].length;o++){const h=l[e][o];if(h.hasState(16,64))continue;const T=-1===h.iterationCount,R=h.duration,E=h.iterationCount;let N,M,O;if(T)N=s+R;else if((N=h.getTotalDuration())<=q){h.fillReplace?h.addState(64):y(h);continue}if(T?(M=Math.ceil((c-s)/R),O=0):(M=Math.ceil(E),O=E-Math.floor(E)),a.length&&z>0&&z<s&&g(z,s),-1!==q&&q<s&&(q=St(_[t],s-1,C),z=s),X=1/0,h.group.ordering&&h.group.ordering.length>1){let s=!0;for(const e of h.group.ordering){if(e.name===h.group.name){s=!1;break}if(!e.paused&&z<=e.delay&&e.attributes.includes(t))break}if(s)e:for(let t=e+1;t<r.length;t++)for(let e=0;e<l[t].length;e++){const s=l[t][e];if(s.group.ordering){X=s.delay;break e}s.getTotalDuration()<=N?(s.fillFreeze&&d(s),s.addState(16)):s.delay<N&&y(s)}}else for(let t=e+1;t<r.length;t++)if(r[t]!==1/0&&l[t].length&&!l[t].every(t=>t.hasState(16,64))){X=r[t];break}const B=z;let W,D=q+1,Y=Math.min(X,h.end||1/0);if(a.length&&h.animationElement){const t=Math.min(X,N,Y);if(W=a.find(e=>e.delay>=z&&e.delay<=t)){switch(W.delay){case z:S(z,C=W.to,W.type,W),W.group.id>h.group.id&&(i&&$&&k(h.additiveSum,Math.max(s-1,q)),q=p(W,Math.max(W.delay,q),C),Y=-1);break;case X:W.addState(32);break;default:Y=W.delay,W.addState(32)}et.spliceArray(a,t=>t!==W),h.addState(4)}}let j,U=!1;if(Y>q){i&&($&&(k(h.additiveSum,Math.max(s-1,q)),D=q+1),C=u.typeAsValue(h.type),S(z,C,h.type));let a=r[e]===1/0||(-1!==q||h.hasState(2))&&!(0===e&&0===o);U=!0;e:{const i=I(t);for(let r=Mt(z,s,R);r<M;r++){let c,u,f=Tt(A,h,C);if(h.partialType){if(h.getIntervalEndTime(z)<Y&&(F.length||o<l[e].length-1)){for(let t=o+1;t<l[e].length;t++)y(l[e][t]);l[e].length=0,v(),[c,f,u]=bt(A,h,z,Y,f,C,F)}else[c,f,u]=Nt(h);xt(c,f,u,G[t])}else c=h.keyTimes,u=h.keySplines;for(let e=0;e<c.length;e++){const o=c[e];let l=-1,p=mt(h,f,r,e,C);if(r===M-1&&O>0)if(O===o)O=-1;else if(e===c.length-1)z=l=N,p=yt(O,c[e-1],mt(h,f,r,e-1,C),o,p),O=-1;else if(O>o)for(let t=e+1;t<c.length;t++)if(O<=c[t]){z=l=N,p=yt(O,o,p,c[t],mt(h,f,r,t,C)),O=-1;break}if(-1===l){if((l=Rt(s,R,c,r,e))<0||l<q)continue;if(l===Y)U=r===M-1&&e===c.length-1,z=l;else{function x(e){[q,j]=vt(h,z,C,c,f,u,s,r,e,n,_[t],V,w)}if(s<0&&-1===q)l>0&&(z=0,x(0));else{if(l>Y){a&&q+1<Y&&x(q),z=Y,x(Y+(Y!==X||_[t].has(Y-1)?0:-1)),U=!1;break e}if(a)h.hasState(2)&&(z=B),s>=q?(l=Math.max(s,q+1),z=s):l===q?(z=l,l=q+1):(x(q),z=Math.max(l,q)),a=!1;else{if(z=l,r>0&&0===e&&h.accumulateSum){kt(h,l,u,e,n,V,w),q=l;continue}l=Math.max(l,q+1)}}}}if(l>q&&(e===c.length-1&&!h.accumulateSum&&(r<M-1||h.fillReplace&&(void 0===i||p!==i.value))&&l--,q=St(_[t],l,p),kt(h,q,u,e,n,V,w),j=p),!U||-1===O)break e}}}m(e,o)}if(void 0!==j&&(C=j,i&&(gt(L,h.type,D,q),$=h)),W&&(W.hasState(32)?(q=p(W,W.delay,j=W.to),S(z=W.delay,j,W.type,W)):h.hasState(64)&&gt(L,q,W.type),b(),U=!0),et.spliceArray(a,t=>t.delay>=B&&t.delay<=z,t=>{S(t.delay,t.to,t.type,t),t.animationElement&&b()}),T){if(!U){F.length=0,F.push(h);continue}if(void 0===W){P[t]=h;break t}}if(U){if(!T&&f(h,X))break t;for(let t=e;t<r.length;t++)if(r[t]<z){for(let e=0;e<l[t].length;e++){const s=l[t][e],i=s.getTotalDuration();i>z&&!s.hasState(4,16,64)?y(s):s.fillReplace||S(i,s.valueTo,s.type,s)}r[t]=1/0,l[t].length=0}if(F.length&&z<X){v();const t=F.find(t=>t.delay<=z);t&&(t.removeState(4,2),t.addState(8),b(t),s=t.delay,l[e]=[t],o=-1)}}else y(h)}}if(F.length){v();for(let e=0;e<F.length;e++){const s=F[e],a=s.delay,r=s.duration,o=q-a;let l=1/0;function R(){let h,c,u=Tt(A,s,C);s.partialType?(s.getIntervalEndTime(z)<l&&e<F.length-1?[h,u,c]=bt(A,s,z,l,u,C,F):[h,u,c]=Nt(s),xt(h,u,c,G[t])):(h=s.keyTimes,c=s.keySplines);const f=q+1;let p=Math.floor(o/r),d=!1;const g=e=>vt(s,z,C,h,u,c,a,p,e,n,_[t],V,w);do{for(let e=0;e<h.length;e++){let i=Rt(a,r,h,p,e);!d&&i>=q&&([q,C]=g(q),d=!0),d&&(i>=l?l>q&&([q,C]=g(l),z=l):i>q&&(z=i,e===h.length-1&&i<l&&i--,C=mt(s,u,p,e,C),q=St(_[t],i,C),kt(s,q,c,e,n,V,w)))}}while(q<l&&++p);i&&gt(L,s.type,f,q)}if(-1===s.iterationCount){o>0&&o%s.duration!=0&&(l=a+s.duration*Math.ceil(o/r),R()),P[t]=s;break t}if((l=Math.min(a+s.duration*s.iterationCount,s.end||1/0))>q&&(R(),f(s)))break t}}if(B&&B.fillReplace&&void 0===P[t]){let e,s=0;if(O[t]){const i=I(t);i&&(s=i.key,e=i.value)}else i?(s=Array.from(L.values()).pop(),e=u.typeAsValue(s)):e=G[t];void 0===e||et.isEqual(_[t].get(q),e)||(q=St(_[t],q,e),i&&gt(L,s,q))}}E[t]=q}{const t=new Set;let e=0;for(const s in _){let i=0;for(const e of _[s].keys())t.add(e),i=e;e=Math.max(e,i),O[s]&&O[s].sort((t,e)=>t.time===e.time?0:t.time<e.time?-1:1)}if(Object.keys(P).length){const s=[],i=[];for(const t in P)s.push(P[t].delay),i.push(P[t].duration);0===M.size&&1===new Set(s).size&&1===new Set(i).size&&s[0]===t.values().next().value?q=s[0]<=0?0:s[0]:i.length>1&&i.every(t=>t%250==0)?e=J.nextMultiple(i,e,s):(e-s[0])%i[0]!=0&&(e=i[0]*Math.ceil(e/i[0]))}if(-1===q)for(const s in _)if(P[s]){let a=E[s];if(a<e){const r=P[s],o=r.delay,l=a+1;let h=Array.from(_[s].values()).pop(),c=Math.floor((a-o)/r.duration);const u=Tt(A,r,h);do{let i=!1;for(let l=0;l<r.keyTimes.length;l++){let f=Rt(o,r.duration,r.keyTimes,c,l);!i&&f>=a&&([a,h]=vt(r,a,h,r.keyTimes,u,r.keySplines,o,c,a,n,_[s],V,w),t.add(a),i=!0),i&&f>a&&(l===r.keyTimes.length-1&&f<e&&f--,h=mt(r,u,c,l,h),a=St(_[s],f,h),kt(r,f,r.keySplines,l,n,V,w),t.add(a))}}while(a<e&&++c);E[s]=a,i&&gt(L,r.type,l,a)}}const a=et.sortNumber(Array.from(t));if(s||i){let t=!1;for(const e in _)if(!_[e].has(0)&&void 0!==G[e]){const s=_[e].keys().next().value-1;_[e].set(0,G[e]),_[e].set(s,G[e]),a.includes(0)||(a.push(0),t=!0),a.includes(s)||(a.push(s),t=!0)}t&&et.sortNumber(a)}if(!i)for(const t in _)for(const e of a){if(!(e<=E[t]))break;if(!_[t].has(e)){if(A.paused(t,e)){let s=A.get(t,e);if(s&&""!==(s=ht(s,!0))){_[t].set(e,s);continue}}ot(_[t],t,e,A,i)}}$=dt(_,a,O)}if(-1===q&&Object.keys(P).length){const t={},e=[],s=[],a=[];for(const t in P)a.push(P[t].duration),e.push(P[t]);const r=J.nextMultiple(a);for(const i of e){const e=i.attributeName;t[e]=new Map;let a=_[e].has(E[e])?_[e].get(E[e]):G[e];const o=Tt(A,i,a);let l=0,h=0;do{for(let c=0;c<i.keyTimes.length;c++){let u=Rt(0,i.duration,i.keyTimes,h,c);c===i.keyTimes.length-1&&u<r&&u--,a=mt(i,o,h,c,a),kt(i,l=St(t[e],u,a),i.keySplines,c,n,F,C),s.includes(l)||s.push(l)}}while(l<r&&++h)}if(e.every(t=>t.alternate)){let e=-1;for(const i in P){const a=Array.from(t[i].keys()),n=Array.from(t[i].values()).reverse();for(let o=0;o<a.length;o++)if(0!==a[o]){e=r+a[o];const l=F.get(a[o]);l&&F.set(e,l),e=St(t[i],e,n[o]),s.includes(e)||s.push(e)}}}et.sortNumber(s);for(const e in t)for(const a of s)t[e].has(a)||ot(t[e],e,a,A,i);B=dt(t,s,O)}if($||B){this._removeAnimations(r);const t=Array.from(L.entries()),e=et.joinMap(r,t=>N.isAnimateTransform(t)?u.typeAsName(t.type):t.attributeName,"-");for(const r of[$,B])if(r){const o=r===$,l=o?V:F,h=o?w:C;if(Vt(i,n)){const e=[];if(i){const s=[];if(o){const e=Array.from(r.entries());let i=t[0][1];for(let a=0,n=0,r=0;a<t.length;a++){const o=a<t.length-1?t[a+1][1]:-1;if(i!==o){const l=new Map;for(let s=r;s<e.length;s++){const o=e[s][0];if(o>=t[n][0]&&o<=t[a][0])l.set(o,new Map([[i,e[s][1].values().next().value]])),r=s;else if(o>t[a][0])break}s.push(l),i=o,n=a+1}}}else{if(!P.transform)return;{const t=Array.from(r.entries()),e=new Map;for(const s of t)e.set(s[0],new Map([[P.transform.type,s[1].values().next().value]]));s.push(e)}}let i=0;for(let t=0;t<s.length;t++){const a=Array.from(s[t].entries());let n=a[0][0];1===a.length&&a.push(t<s.length-1?[s[t+1].keys().next().value,a[0][1]]:[n+1,a[0][1]]);const r=a[a.length-1][0];let c=r-n;const u=new K;u.type=a[0][1].keys().next().value;for(let t=0;t<a.length;t++){const s=a[t];if(e.push(l.get(s[0])||""),u.type!==SVGTransform.SVG_TRANSFORM_ROTATE){const e=h.get(s[0]);e&&(void 0===u.transformOrigin&&(u.transformOrigin=[]),u.transformOrigin[t]=e)}s[0]-=n}for(const[t,e]of lt(a))u.keyTimes.push(t),u.values.push(e.values().next().value);(n-=i)>1?u.delay=n:1===n&&(c+1)%10==0&&c++,u.duration=c,u.keySplines=e,u.synchronized={key:t,value:""},i=r,this._insertAnimate(u,o)}}else{const t=Array.from(r.entries()),i=-1!==q?q:0;let n;for(const s of t)e.push(l.get(s[0])||""),s[0]-=i;if(s){const e=ut(lt(t),s,this.parent,O,a);if(!e)return;(n=new j).attributeName="d";for(const t of e)n.keyTimes.push(t.key),n.values.push(""+t.value)}else{const t=new K;t.type=SVGTransform.SVG_TRANSFORM_TRANSLATE;for(const[e,s]of r.entries()){const i=s.get("x")||0,a=s.get("y")||0;t.keyTimes.push(e),t.values.push(this.parent?`${this.parent.refitX(i)} ${this.parent.refitX(a)}`:`${i} ${a}`)}n=t}n.delay=i,n.keySplines=e,n.duration=t[t.length-1][0],this._insertAnimate(n,o)}}else if(wt(i,n)){const n=Array.from(r.entries());for(let r=0;r<n.length-1;r++){const[c,u]=n[r],[f,p]=n[r+1];let d,g=e;if(i){const e=new K;if(o)for(let s=0;s<t.length-1;s++){const i=t[s],a=t[s+1];if(i[1]===a[1]&&c>=i[0]&&f<=a[0]){e.type=i[1];break}if(f-c==1&&f===a[0]){e.type=a[1];break}}else P.transform&&(e.type=P.transform.type);if(0===e.type)continue;e.values=[u.values().next().value,p.values().next().value];const s=h.get(f);s&&(e.transformOrigin=[s]),d=e}else if(s){const t=ut([[c,u],[f,p]],s,this.parent,O,a);if(!t)continue;(d=new j).attributeName="d",d.values=et.replaceMap(t,t=>""+t.value)}else{const t=new K;t.type=SVGTransform.SVG_TRANSFORM_TRANSLATE,t.values=et.objectMap([u,p],t=>{const e=t.get("x")||0,s=t.get("y")||0;return this.parent?`${this.parent.refitX(e)} ${this.parent.refitX(s)}`:`${e} ${s}`}),g+=r,d=t}o&&(d.delay=0===r?c:0),d.duration=f-c,d.keyTimes=[0,1],d.synchronized={key:r,value:g};const m=l.get(f);m&&(d.keySplines=[m]),this._insertAnimate(d,o)}}}}}})}_removeAnimations(t){t.length&&et.spliceArray(this.animations,e=>t.includes(e))}_insertAnimate(t,e){e||(t.iterationCount=-1),t.from=t.valueFrom,t.to=t.valueTo,this.animations.push(t)}});const Ft=squared.lib.css,Ct=squared.lib.dom,Gt=squared.lib.math,Ot=squared.lib.util;class Lt extends K{constructor(t,e){if(super(t,e),this.path="",this.distance="0%",this.rotate="auto 0deg",this.motionPathElement=null,this.type=SVGTransform.SVG_TRANSFORM_TRANSLATE,this._offsetLength=0,e){this.setAttribute("path");const t=Ct.getNamedItem(this.animationElement,"rotate");switch(t){case"auto":break;case"auto-reverse":this.rotate="auto 180deg";break;default:Ot.isNumber(t)&&(this.rotate=`${Ot.convertFloat(t)}deg`)}for(let t=0;t<e.children.length;t++){const s=e.children[t];if("mpath"===s.tagName){let t=y(s);if(t&&(f.use(t)&&(t=y(t)),t&&f.shape(t))){this.motionPathElement=t;break}}}this.setCalcMode()}else if(t){const e=/path\("([^"]+)"\)/.exec(d(t,"offset-path"));e&&(this.path=e[1]);const s=d(t,"offset-distance",!1);""!==s&&(this.distance=s);const i=d(t,"offset-rotate",!1);""!==i&&"auto"!==i&&(this.rotate=i)}}setCalcMode(){if(this.animationElement){const t=Ct.getNamedItem(this.animationElement,"calcMode")||"paced";switch(t){case"paced":case"discrete":case"spline":super.setCalcMode("translate",t);break;case"linear":const e=K.toFractionList(Ct.getNamedItem(this.animationElement,"keyPoints"),";",!1);let s=super.keyTimes;0===s.length&&-1!==this.duration&&(s=K.toFractionList(Ct.getNamedItem(this.animationElement,"keyTimes")),this.length=0,super.keyTimes=s),e.length===s.length&&(this._keyPoints=e)}}}addKeyPoint(t){if(void 0===this._offsetPath){const{key:e,value:s}=t;if(e>=0&&e<=1){const i=super.keyTimes,a=this.keyPoints;if(i.length===a.length){let n=NaN;if(Ft.isPercent(s)?n=parseFloat(s)/100:Ot.isNumber(s)&&(n=parseFloat(s)/this.offsetLength),!isNaN(n)){n>1&&(n=1);const s=i.findIndex(t=>t===e);-1!==s?(i[s]=t.key,a[s]=n):(i.push(t.key),a.push(n))}}}}}setOffsetPath(){if(void 0===this._offsetPath&&this.path){const t=this.rotateData;let e=N.getOffsetPath(this.path,t?void 0:this.rotate),s=e.length;if(s>0){const i=this.duration;let a=NaN;if(i>=s){a=i/s;for(let t=1;t<s-1;t++)e[t].key*=a;e[s-1].key=i}else if(i>0){const t=[],a=s/i;for(let s=0;s<i;s++){const i=Math.floor(s*a);e[i].key=s,t[s]=e[i]}const n=e.pop();t[t.length-1].value!==n.value&&(n.key=i,t.push(n)),e=t,s=t.length}const n=this.keyPoints,r=this.framesPerSecond?1e3/this.framesPerSecond:0;if(n.length){const t=s-1,o=super.keyTimes,l=[];if(n.length>1){let s;const h=(t,e,i)=>!!s&&s.key===t&&i===s.rotate&&Ot.isEqual(s.value,e);for(let c=0;c<o.length-1;c++){const u=Gt.truncateFraction(o[c]*i),f=Gt.truncateFraction((o[c+1]-o[c])*i),p=n[c],d=n[c+1];if(0===f){const i=u,{value:a,rotate:n}=e[Math.floor(d*t)];if(h(i,a,n))continue;l.push(s={key:i,value:a,rotate:n})}else{let s=0,i=u;if(p===d){const{value:n,rotate:o}=e[Math.floor(p*t)],c=isNaN(a)?1:a;for(h(u,n,o)&&(s+=c,i+=r);s<f;s+=c){const t=u+s;t>=i&&(l.push({key:t,value:n,rotate:o}),s<f-1?i+=r:i=0)}}else{const a=Math.floor(Math.min(p,d)*t),n=Math.floor(Math.max(p,d)*t),o=[];for(let t=a;t<=n;t++)o.push(Object.assign({},e[t]));p>d&&o.reverse();const c=o.length,g=f/c;for(h(u,o[0].value,o[0].rotate)&&(s++,i+=r);s<c;s++){const t=u+s*g;t>=i&&(o[s].key=t,l.push(o[s]),s<c-1?i+=r:i=0)}}l[l.length-1].key=u+f}}}else l.push(Object.assign({},e[Math.floor(n[0]*t)])),0===o[0]&&(l[0].rotate=0);this._offsetPath=l}else if(r>0){const t=[];for(let i=0;i<s;i+=r)t.push(e[Math.floor(i)]);const i=e.pop();i!==t[t.length-1]&&t.push(i),this._offsetPath=t}else this._offsetPath=e;if(t){e=this._offsetPath;for(let s=0,a=0;s<t.length-1;s++){const n=t[s],r=t[s+1],o=[];if(n.key===r.key)o.push(e[a++]);else{const t=Math.floor(Gt.truncateFraction(r.key*i));for(;;a++){const s=e[a];if(!(s&&s.key<=t))break;o.push(s)}}const l=Ft.parseAngle(n.value.split(" ").pop()),h=Ft.parseAngle(r.value.split(" ").pop());if(n.value===r.value||l===h)if(n.value.startsWith("auto")){if(0!==l)for(const t of o)t.rotate+=l}else for(const t of o)t.rotate=l;else{const t=h-l,e=t/o.length;if(n.value.startsWith("auto")){for(let t=0;t<o.length-1;t++)o[t].rotate+=l+t*e;o[o.length-1].rotate+=l+t}else{for(let t=0;t<o.length-1;t++)o[t].rotate=l+t*e;o[o.length-1].rotate=l+t}}}}this.keySplines=void 0,this.timingFunction=B.linear}}}reverseKeyPoints(){let t,e;if(this.validKeyPoints()){(e=this._keyPoints.slice(0)).reverse(),t=[];for(const e of super.keyTimes)t.push(1-e);t.reverse()}return{keyTimes:t,keyPoints:e}}validKeyPoints(){return!!this._keyPoints&&this._keyPoints.length>0&&this._keyPoints.length===super.keyTimes.length}get offsetPath(){return this._offsetPath}get playable(){return!this.paused&&-1!==this.duration&&Ot.isString(this.path)}set keyTimes(t){this.path||(super.keyTimes=t)}get keyTimes(){if(this.setOffsetPath(),this._offsetPath){const t=this.duration;return Ot.objectMap(this._offsetPath,e=>e.key/t)}return super.keyTimes}set values(t){this.path||(super.values=t)}get values(){return this.setOffsetPath(),this._offsetPath?Ot.objectMap(this._offsetPath,t=>`${t.value.x} ${t.value.y}`):super.values}get rotateValues(){if(this.setOffsetPath(),this._offsetPath)return Ot.objectMap(this._offsetPath,t=>t.rotate)}get keyPoints(){return void 0===this._keyPoints&&(this._keyPoints=[]),this._keyPoints}set reverse(t){if(t!==super.reverse){const{keyTimes:e,keyPoints:s}=this.reverseKeyPoints();e&&s&&(this.length=0,this._keyPoints=s,super.keyTimes=e,super.reverse=t)}}get reverse(){return super.reverse}set alternate(t){const e=this.iterationCount;if(t!==super.alternate&&(-1===e||e>1)){const{keyTimes:s,keyPoints:i}=this.reverseKeyPoints();if(s&&i){const a=this.duration,n=super.keyTimes,r=this.keyPoints;if(-1===e){for(let t=0;t<n.length;t++)n[t]/=2,s[t]=.5+s[t]/2;Ot.concatArray(n,s),Ot.concatArray(r,i),this.duration=2*a}else{const t=n.slice(0),o=r.slice(0);for(let a=0;a<e;a++)if(0===a)for(let t=0;t<n.length;t++)n[t]/=e;else{const l=a*(1/e),h=a%2==0?t.slice(0):s.slice(0);for(let t=0;t<h.length;t++)h[t]=Gt.truncateFraction(l+h[t]/e);Ot.concatArray(n,h),Ot.concatArray(r,a%2==0?o:i)}this.duration=a*e,this.iterationCount=1}super.alternate=t}}}get alternate(){return super.alternate}set parent(t){super.parent=t;const e=this.parentContainer;e&&e.requireRefit&&this.path&&(this.path=N.transformRefit(this.path,void 0,void 0,e))}get parent(){return super.parent}get offsetLength(){return 0===this._offsetLength&&this.path&&(this._offsetLength=S(this.path)),this._offsetLength}get instanceType(){return 114696}}const $t=squared.lib.css,Bt=squared.lib.dom,qt=squared.lib.regex,It=squared.lib.util,zt="cubic-bezier\\(([\\d.]+), ([\\d.]+), ([\\d.]+), ([\\d.]+)\\)",Xt=RegExp(`(ease|ease-in|ease-out|ease-in-out|linear|step-(?:start|end)|steps\\(\\d+, (?:start|end)\\)|${zt}),?\\s*`,"g"),Wt=$t.getKeyframeRules(),Dt={"animation-delay":"0s","animation-duration":"0s","animation-iteration-count":"1","animation-play-state":"running","animation-direction":"normal","animation-fill-mode":"none","animation-timing-function":"ease"};function Yt(t,e,s){t.style[e]=s,t.setAttribute(e,s)}function jt(t,e){const s=d(t,e);if("animation-timing-function"===e){const t=[];let e;for(;null!==(e=Xt.exec(s));)t.push(e[1]);return t}return s.split(qt.XML.SEPARATOR)}function Ut(t){return t.sort((t,e)=>t.key!==e.key?t.key<e.key?-1:1:0)}function Ht(t){if("reverse"===t)return"auto 180deg";if(t.startsWith("reverse ")){const e=t.split(" ")[1];return $t.isAngle(e)?`auto ${180+$t.parseAngle(e)}deg`:"auto 0deg"}return t}var Kt=t=>(class extends t{getTransforms(t){return void 0===t&&(t=this.element),N.filterTransforms(u.parse(t)||N.convertTransforms(t.transform.baseVal))}getAnimations(t){void 0===t&&(t=this.element);const e=[];let s=0;const i=(t,i,a="")=>{""===a&&s++,t.delay=i,t.group={id:s,name:a},t.parent=this,e.push(t)};for(let e=0;e<t.children.length;e++){const s=t.children[e];if(s instanceof SVGAnimationElement){const e=Bt.getNamedItem(s,"begin");if(""!==e&&/^[a-zA-Z]+$/.test(e))continue;const a=e?It.sortNumber(It.replaceMap(e.split(";"),t=>$.convertClockTime(t))):[0];if(a.length)switch(s.tagName){case"set":for(const e of a)i(new $(t,s),e);break;case"animate":for(const e of a)i(new j(t,s),e);break;case"animateTransform":for(const e of a){const a=new K(t,s);N.isShape(this)&&this.path&&(a.transformFrom=N.drawRefit(t,this.parent,this.viewport&&this.viewport.precision)),i(a,e)}break;case"animateMotion":for(const e of a){const a=new Lt(t,s);a.motionPathElement&&(a.path=N.drawRefit(a.motionPathElement,this.parent,this.viewport&&this.viewport.precision)),i(a,e)}}}}const a=jt(t,"animation-name");if(a.length){const e={},r=[],o=[];for(const s in Dt){const i=jt(t,s);for(0===i.length&&i.push(Dt[s]);i.length<a.length;)It.concatArray(i,i.slice(0));i.length=a.length,e[s]=i}for(let l=0;l<a.length;l++){const h=Wt[a[l]],c=$.convertClockTime(e["animation-duration"][l]);if(h&&c>0){s++;const f={},p={},g="paused"===e["animation-play-state"][l],m=$.convertClockTime(e["animation-delay"][l]),y=e["animation-iteration-count"][l],v=e["animation-fill-mode"][l],b=`${a[l]}_${l}`,S=[];let k=!0;o.push({name:b,attributes:S,paused:g,delay:m,duration:c,iterationCount:y,fillMode:v});for(const e in h){const s=parseFloat(e)/100;for(const i in h[e]){const a=Dt[i]?p:f;void 0===a[i]&&(a[i]=[]);let n=h[e][i];n&&($t.isCalc(n)?n=$t.calculateVar(t,n,i):$t.isCustomProperty(n)&&(n=$t.parseVar(t,n)),void 0!==n&&a[i].push({key:s,value:""+n}))}}if(f.transform){function n(e){const s=f["transform-origin"]&&f["transform-origin"].find(t=>t.key===e);if(s)return u.origin(t,s.value)}for(const e of Ut(f.transform)){const s=u.parse(t,e.value);if(s){const t=n(e.key);for(const i of s){const s=i.matrix;let a,n,r;switch(i.type){case SVGTransform.SVG_TRANSFORM_TRANSLATE:a="translate",n=`${s.e} ${s.f}`;break;case SVGTransform.SVG_TRANSFORM_SCALE:a="scale",n=`${s.a} ${s.d} ${t?`${t.x} ${t.y}`:"0 0"}`,!t||0===e.key&&0===t.x&&0===t.y||(r={x:t.x*(1-s.a),y:t.y*(1-s.d)});break;case SVGTransform.SVG_TRANSFORM_ROTATE:a="rotate",n=`${i.angle} ${t?`${t.x} ${t.y}`:"0 0"}`;break;case SVGTransform.SVG_TRANSFORM_SKEWX:a="skewX",n=""+i.angle,!t||0===e.key&&0===t.y||(r={x:t.y*s.c*-1,y:0});break;case SVGTransform.SVG_TRANSFORM_SKEWY:a="skewY",n=""+i.angle,!t||0===e.key&&0===t.x||(r={x:0,y:t.x*s.b*-1});break;default:continue}void 0===f[a]&&(f[a]=[]);const o=f[a].findIndex(t=>t.key===e.key);-1!==o?(f[a][o].value=n,f[a][o].transformOrigin=r):f[a].push({key:e.key,value:n,transformOrigin:r})}}}delete f.transform,delete f["transform-origin"]}if("none"===d(t,"offset-path"))delete f["offset-distance"],delete f["offset-rotate"];else if(f["offset-rotate"]){const e=f["offset-rotate"];if(f["offset-distance"]||void 0===f.rotate){let s=d(t,"offset-rotate",!1);""!==s&&"auto"!==s||(s="auto 0deg"),Ut(e);const a=e[e.length-1];0!==e[0].key&&e.unshift({key:0,value:s}),1!==a.key&&e.push({key:1,value:s});for(let t=1;t<e.length;t++){const s=e[t-1],i=e[t];if(s.value=Ht(s.value),i.value=Ht(i.value),s.value.split(" ").pop()!==i.value.split(" ").pop()){const a=s.value.startsWith("auto"),n=i.value.startsWith("auto");if(a&&!n||!a&&n){const a=(s.key+i.key)/2;e.splice(t++,0,{key:a,value:s.value}),e.splice(t++,0,{key:a,value:i.value})}}}if(void 0===f["offset-distance"]){const s=new Lt(t);s.duration=0,s.iterationCount=1,s.fillForwards=!0,s.addKeyPoint({key:0,value:s.distance}),i(s,m,b);for(const t of e){let e=$t.parseAngle(t.value.split(" ").pop());t.value.startsWith("auto")&&(e+=90),t.value=`${e} 0 0`}f.rotate=e,delete f["offset-rotate"],k=!1}}else delete f["offset-rotate"]}for(const s in f){let a;switch(s){case"offset-rotate":continue;case"offset-distance":(a=new Lt(t)).rotateData=f["offset-rotate"];break;case"rotate":case"scale":case"skewX":case"skewY":case"translate":(a=new K(t)).setType(s);break;default:(a=new j(t)).attributeName=s}i(a,m,b);const n=f[s],o=e["animation-direction"][l],h=e["animation-timing-function"][l];if(Ut(n),"offset-distance"===s){const t=a;0!==n[0].key&&t.addKeyPoint({key:0,value:t.distance});for(const e of n)t.addKeyPoint(e);1!==n.pop().key&&t.addKeyPoint({key:1,value:t.distance}),It.isString(h)&&(t.timingFunction=h)}else{S.push(s);const e=[],i=[],r=[];for(let t=0;t<n.length;t++){if(e.push(n[t].key),i.push(n[t].value),k&&t<n.length-1){const e=p["animation-timing-function"]&&p["animation-timing-function"].find(e=>e.key===n[t].key);r.push(e?e.value:h)}const s=n[t].transformOrigin;s&&N.asAnimateTransform(a)&&(void 0===a.transformOrigin&&(a.transformOrigin=[]),a.transformOrigin[t]=s)}if(0!==e[0]&&(e.unshift(0),i.unshift(a.baseValue||""),k&&r.unshift(h),a.evaluateStart=!0),k&&!r.every(t=>"linear"===t)){const n=[],o=[],l=[];for(let a=0;a<e.length;a++){if(a<e.length-1){const h=(e[a+1]-e[a])*c;if(B[r[a]])r[a]=B[r[a]];else if(r[a].startsWith("step")){if(""!==i[a]){const u=j.convertStepTimingFunction(s,r[a],e,i,a,$t.getFontSize(t));if(u){const t=1===e[a+1]?1:0;for(let s=0;s<u[0].length-t;s++){let t=(e[a]+u[0][s]*h)/c;n.includes(t)&&(t+=.001),n.push(t),o.push(u[1][s]),l.push(B[-1!==r[a].indexOf("start")?"step-start":"step-end"])}continue}}r[a]=B.linear}else{const t=RegExp(zt).exec(r[a]);r[a]=t?`${t[1]} ${t[2]} ${t[3]} ${t[4]}`:B.ease}l.push(r[a])}n.push(e[a]),o.push(i[a])}a.values=o,a.keyTimes=n,a.keySplines=l}else a.values=i,a.keyTimes=e,k?a.keySplines=r:a.timingFunction=h}a.paused=g,a.duration=c,a.iterationCount="infinite"!==y?parseFloat(y):-1,a.fillForwards="forwards"===v||"both"===v,a.fillBackwards="backwards"===v||"both"===v,a.reverse=o.endsWith("reverse"),a.alternate=(-1===a.iterationCount||a.iterationCount>1)&&o.startsWith("alternate"),r.push(a)}}}o.reverse();for(const t of r)t.setGroupOrdering(o)}return e}set name(t){this._name=t}get name(){return void 0===this._name&&(this._name=N.setName(this.element)),this._name}get transforms(){return void 0===this._transforms&&(this._transforms=this.getTransforms()),this._transforms}get animations(){return void 0===this._animations&&(this._animations=this.getAnimations()),this._animations}set visible(t){!function(t,e){Yt(t,"display",e?"block":"none"),Yt(t,"visibility",e?"visible":"hidden")}(this.element,t)}get visible(){return function(t){const e=d(t,"visibility");return"hidden"!==e&&"collapse"!==e&&"none"!==d(t,"display")}(this.element)}set opacity(t){!function(t,e){if(It.isNumber(e)){let s=parseFloat(""+e);s<=0?s=0:s>=1&&(s=1),t.style.setProperty("opacity",""+s),t.setAttribute("opacity",""+s)}}(this.element,t)}get opacity(){return d(this.element,"opacity")||"1"}});const Zt=squared.lib.client;function Qt(t){if("svg"===t.tagName){if(Zt.isUserAgent(8))return t.parentElement instanceof HTMLElement;if(Zt.isUserAgent(4))return!(t.parentElement instanceof HTMLElement)}return!1}var Jt=t=>(class extends t{setRect(){const t=this.parent;let e=this.x,s=this.y,i=this.width,a=this.height;t&&(e=t.refitX(e),s=t.refitY(s),i=t.refitSize(i),a=t.refitSize(a)),this.setBaseValue("x",e),this.setBaseValue("y",s),this.setBaseValue("width",i),this.setBaseValue("height",a)}_getElement(){switch(this.element.tagName){case"svg":case"use":case"image":return this.element;default:return null}}set x(t){this._x=t}get x(){if(void 0!==this._x)return this._x;{const t=this._getElement();return t?t.x.baseVal.value:0}}set y(t){this._y=t}get y(){if(void 0!==this._y)return this._y;{const t=this._getElement();return t?t.y.baseVal.value:0}}set width(t){this._width=t}get width(){if(void 0!==this._width)return this._width;{const t=this._getElement();return t?Qt(t)?t.getBoundingClientRect().width:t.width.baseVal.value:0}}set height(t){this._height=t}get height(){if(void 0!==this._height)return this._height;{const t=this._getElement();return t?Qt(t)?t.getBoundingClientRect().height:t.height.baseVal.value:0}}});const te=squared.lib.util;function ee(t,e){const s=m(g(t,"fill"));if(""!==s){if(e&&e.definitions.pattern.has(s))return e.definitions.pattern.get(s);{const t=document.getElementById(s.substring(1));if(t instanceof SVGPatternElement)return t}}}class se extends squared.lib.base.Container{constructor(t){super(),this.element=t,this.aspectRatio={x:0,y:0,width:0,height:0,position:{x:0,y:0},parent:{x:0,y:0},unit:1},this._clipRegion=[]}append(t,e){return t.parent=this,t.viewport=e||this.getViewport(),super.append(t)}build(t){let e,s,i=!0;t?(e=(t=Object.assign({},t)).symbolElement||t.patternElement||t.element||this.element,s=t.precision,!1===t.initialize&&(i=!1),t.symbolElement=void 0,t.patternElement=void 0,t.element=void 0):e=this.element,this.clear();const a=this.getViewport();let n=!1;for(let s=0;s<e.children.length;s++){const r=e.children[s];let o;if(f.svg(r))o=new squared.svg.Svg(r,!1),this.setAspectRatio(o,r.viewBox.baseVal),n=!0;else if(f.g(r))o=new squared.svg.SvgG(r),this.setAspectRatio(o);else if(f.use(r)){const t=y(r);if(t)if(f.symbol(t))o=new squared.svg.SvgUseSymbol(r,t),this.setAspectRatio(o,t.viewBox.baseVal),n=!0;else if(f.image(t))o=new squared.svg.SvgImage(r,t);else if(f.shape(t)){const e=ee(r,a);e?(o=new squared.svg.SvgUsePattern(r,t,e),this.setAspectRatio(o)):o=new squared.svg.SvgUse(r,t,i)}}else if(f.image(r))o=new squared.svg.SvgImage(r);else if(f.shape(r)){const t=ee(r,a);t?(o=new squared.svg.SvgShapePattern(r,t),this.setAspectRatio(o)):o=new squared.svg.SvgShape(r,i)}o&&(this.append(o,a),o.build(t))}if(N.asSvg(this)&&this.documentRoot)(this.aspectRatio.x<0||this.aspectRatio.y<0)&&this.clipViewBox(this.aspectRatio.x,this.aspectRatio.y,this.aspectRatio.width,this.aspectRatio.height,s,!0);else if(n&&this.hasViewBox()&&(0!==this.aspectRatio.x||0!==this.aspectRatio.y)){const t=N.getBoxRect(this.getPathAll(!1)),e=this.refitX(this.aspectRatio.x),i=this.refitY(this.aspectRatio.y);(t.left<e||t.top<i)&&this.clipViewBox(t.left,t.top,this.refitSize(this.aspectRatio.width),this.refitSize(this.aspectRatio.height),s)}}hasViewBox(){return N.asSvg(this)&&!!this.element.viewBox.baseVal||N.asUseSymbol(this)&&!!this.symbolElement.viewBox.baseVal}clipViewBox(t,e,s,i,a,n=!1){n&&(s-=t,i-=e,t=t<0?-1*t:0,e=e<0?-1*e:0),this.clipRegion=N.drawRect(s,i,t,e,a)}synchronize(t){this.each(e=>e.synchronize(t))}refitX(t){return(t-this.aspectRatio.x)*this.aspectRatio.unit-this.aspectRatio.parent.x+this.aspectRatio.position.x}refitY(t){return(t-this.aspectRatio.y)*this.aspectRatio.unit-this.aspectRatio.parent.y+this.aspectRatio.position.y}refitSize(t){return t*this.aspectRatio.unit}refitPoints(t){for(const e of t)e.x=this.refitX(e.x),e.y=this.refitY(e.y),void 0!==e.rx&&void 0!==e.ry&&(e.rx*=this.aspectRatio.unit,e.ry*=this.aspectRatio.unit);return t}getPathAll(t=!0){const e=[];for(const s of t?this.cascade():this)N.isShape(s)&&s.path&&s.path.value&&e.push(s.path.value);return e}getViewport(){return this.viewport||N.asSvg(this)&&this||void 0}setAspectRatio(t,e){const s=function(t){for(;t;){if(t.hasViewBox())return t;t=t.parent}}(this);if(s){const i=t.aspectRatio;if(e&&(te.cloneObject(e,i),i.width>0&&i.height>0)){const t=i.width/i.height,e=s.aspectRatio.width||s.viewBox.width,a=s.aspectRatio.height||s.viewBox.height,n=e/a;n>t?i.position.x=(e-a*t)/2:n<t&&(i.position.y=(a-e*(1/t))/2),i.unit=Math.min(e/i.width,a/i.height)}i.parent.x=s.aspectRatio.x+s.aspectRatio.x*(s.aspectRatio.unit-1),i.position.x*=s.aspectRatio.unit,i.position.x+=s.aspectRatio.position.x-s.aspectRatio.parent.x,i.parent.y=s.aspectRatio.y+s.aspectRatio.y*(s.aspectRatio.unit-1),i.position.y*=s.aspectRatio.unit,i.position.y+=s.aspectRatio.position.y-s.aspectRatio.parent.y,i.unit*=s.aspectRatio.unit}}set clipRegion(t){""!==t?this._clipRegion.push(t):this._clipRegion.length=0}get clipRegion(){return this._clipRegion.length?this._clipRegion.join(";"):""}get requireRefit(){return 0!==this.aspectRatio.x||0!==this.aspectRatio.y||0!==this.aspectRatio.position.x||0!==this.aspectRatio.position.y||0!==this.aspectRatio.parent.x||0!==this.aspectRatio.parent.y||1!==this.aspectRatio.unit}get instanceType(){return 2}}const ie=squared.lib.color,ae=squared.lib.dom,ne=squared.lib.util;function re(t){const e=[],s=t.getElementsByTagName("stop");for(let t=0;t<s.length;t++){const i=ie.parseColor(ae.getNamedItem(s[t],"stop-color"),ae.getNamedItem(s[t],"stop-opacity"));i&&e.push({color:i,offset:parseFloat(ae.getNamedItem(s[t],"offset"))/100})}return e}function oe(t,...e){const s={};for(const i of e)t[i]&&(s[i]=t[i].baseVal.value,s[`${i}AsString`]=t[i].baseVal.valueAsString);return s}class le{constructor(t){this.element=t}build(t){}synchronize(t){}get instanceType(){return 4}}const he=squared.lib.color,ce=squared.lib.css,ue=squared.lib.regex,fe=squared.lib.util,pe={url:ue.CSS.URL,polygon:/polygon\(([^)]+)\)/,inset:RegExp(`inset\\(${ue.STRING.LENGTH_PERCENTAGE}\\s?${ue.STRING.LENGTH_PERCENTAGE}?\\s?${ue.STRING.LENGTH_PERCENTAGE}?\\s?${ue.STRING.LENGTH_PERCENTAGE}?\\)`),circle:RegExp(`circle\\(${ue.STRING.LENGTH_PERCENTAGE}(?: at ${ue.STRING.LENGTH_PERCENTAGE} ${ue.STRING.LENGTH_PERCENTAGE})?\\)`),ellipse:RegExp(`ellipse\\(${ue.STRING.LENGTH_PERCENTAGE} ${ue.STRING.LENGTH_PERCENTAGE}(?: at ${ue.STRING.LENGTH_PERCENTAGE} ${ue.STRING.LENGTH_PERCENTAGE})?\\)`)};var de=t=>(class extends t{setPaint(t,e){this.resetPaint(),this.setAttribute("color"),this.setAttribute("fill"),this.setAttribute("fill-opacity",!1),this.setAttribute("fill-rule"),this.setAttribute("stroke"),this.setAttribute("stroke-opacity",!1),this.setAttribute("stroke-width"),this.setAttribute("stroke-linecap"),this.setAttribute("stroke-linejoin"),this.setAttribute("stroke-miterlimit"),this.setAttribute("stroke-dasharray"),this.setAttribute("stroke-dashoffset"),this.setAttribute("clip-rule");const s=this.getAttribute("clip-path",!0,!1);if(""!==s)for(const i in pe){const a=pe[i].exec(s);if(a){if("url"===i)return void(this.clipPath=a[1]);if(t&&t.length){const s=N.getBoxRect(t),n=s.right-s.left,r=s.bottom-s.top,o=this.parent;switch(i){case"inset":{let t=0,i=0,l=this.convertLength(a[1],r),h=0;a[4]?(t=s.left+this.convertLength(a[4],n),i=s.right-this.convertLength(a[2],n),h=s.bottom-this.convertLength(a[3],r)):a[2]?(t=this.convertLength(a[2],n),i=s.right-t,h=s.bottom-(a[3]?this.convertLength(a[3],r):l),t+=s.left):(t=s.left+l,i=s.right-l,h=s.bottom-l);const c=[{x:t,y:l+=s.top},{x:i,y:l},{x:i,y:h},{x:t,y:h}];return o&&o.refitPoints(c),void(this.clipPath=N.drawPolygon(c,e))}case"polygon":{const t=fe.objectMap(a[1].split(ue.XML.SEPARATOR),t=>{let[e,i]=fe.replaceMap(t.trim().split(" "),(t,e)=>this.convertLength(t,0===e?n:r));return{x:e+=s.left,y:i+=s.top}});return o&&o.refitPoints(t),void(this.clipPath=N.drawPolygon(t,e))}default:if("circle"===i||"ellipse"===i){const t=n<r?n:r;let l,h;"circle"===i?h=l=this.convertLength(a[1],t):(l=this.convertLength(a[1],n),h=this.convertLength(a[2],r));let c=s.left,u=s.top;a.length>=4&&(c+=this.convertLength(a[a.length-2],t),u+=this.convertLength(a[a.length-1],t)),o&&(c=o.refitX(c),u=o.refitX(u),l=o.refitSize(l),h=o.refitSize(h)),this.clipPath=N.drawEllipse(c,u,l,h,e)}return}}}}}setAttribute(t,e=!0){let s=this.getAttribute(t,e);if(fe.isString(s)){switch(t){case"stroke-dasharray":s="none"!==s?fe.joinMap(s.split(/,\s*/),t=>""+this.convertLength(t),", "):"";break;case"stroke-dashoffset":case"stroke-width":s=""+this.convertLength(s);break;case"fill":case"stroke":const e=m(s);if(""!==e)this[`${t}Pattern`]=e;else{let e;switch(s.toLowerCase()){case"none":case"transparent":case"rgba(0, 0, 0, 0)":this[t]="none";break;case"currentcolor":e=he.parseColor(this.color||d(this.element,t));break;default:e=he.parseColor(s)}e&&(this[t]=e.value)}return}this[fe.convertCamelCase(t)]=s}}getAttribute(t,e=!0,s=!0){let i=d(this.element,t,e);if(s&&!fe.isString(i)){if(this.patternParent)switch(t){case"fill-opacity":case"stroke-opacity":break;default:return i}let s=this.useParent||this.parent;for(;s&&(i=d(s.element,t,e),!fe.isString(i));)s=s.parent}return i}convertLength(t,e){return ce.isLength(t)?ce.parseUnit(t,ce.getFontSize(this.element)):ce.isPercent(t)?Math.round(("number"==typeof e?e:this.element.getBoundingClientRect()[e||"width"])*fe.convertFloat(t)/100):fe.convertFloat(t)}resetPaint(){this.fill="black",this.fillPattern="",this.fillOpacity="1",this.fillRule="nonzero",this.stroke="",this.strokeWidth="1",this.strokePattern="",this.strokeOpacity="1",this.strokeLinecap="butt",this.strokeLinejoin="miter",this.strokeMiterlimit="4",this.strokeDasharray="",this.strokeDashoffset="0",this.color="",this.clipPath="",this.clipRule=""}});const ge=squared.lib.util;const me=squared.lib.dom,ye=squared.lib.math,ve=squared.lib.util;function be(t,e,s,i){const a=t[0],n=t[t.length-1];if(void 0!==s)switch(e){case"x":s-=a.start.x;break;case"x1":case"cx":return a.start.x=s,void(a.coordinates[0]=s);case"x2":return n.end.x=s,void(n.coordinates[0]=s)}if(void 0!==i)switch(e){case"y":i-=a.start.y;break;case"y1":case"cy":return a.start.y=i,void(a.coordinates[1]=i);case"y2":return n.end.y=i,void(n.coordinates[1]=i)}for(const e of t)for(let t=0,a=0;t<e.coordinates.length;t+=2,a++)void 0!==s&&(e.relative||(e.coordinates[t]+=s),e.value[a].x+=s),void 0!==i&&(e.relative||(e.coordinates[t+1]+=i),e.value[a].y+=i)}function Se(t,e,s){for(let i=0;i<t.length;i++){const a=t[i];if("A"===a.key.toUpperCase()){if(void 0!==e){const s=e-a.radiusX;a.radiusX=e,a.coordinates[0]=2*e*(a.coordinates[0]<0?-1:1),1===i&&(t[0].coordinates[0]-=s,t[0].end.x-=s)}void 0!==s&&(a.radiusY=s)}}}class ke extends(de(F(le))){constructor(t){super(t),this.element=t,this.name="",this.value="",this.baseValue="",this.init()}static extrapolate(t,e,s,i,a,n){const r=!!i||!!a&&!!a.parent&&a.parent.requireRefit,o=[];let l;for(let h=0;h<s.length;h++){if("d"===t)o[h]=s[h];else if("points"===t){const t=N.convertPoints(N.parseCoordinates(s[h]));t.length&&(o[h]=a&&f.polygon(a.element)?N.drawPolygon(t,n):N.drawPolyline(t,n))}else if(e){void 0===l&&(l=N.getPathCommands(e));const i=parseFloat(s[h]);if(!isNaN(i)){const e=h<s.length-1?ve.cloneArray(l,[],!0):l;switch(t){case"x":case"x1":case"x2":case"cx":be(e,t,i);break;case"y":case"y1":case"y2":case"cy":be(e,t,void 0,i);break;case"r":Se(e,i,i);break;case"rx":Se(e,i);break;case"ry":Se(e,void 0,i);break;case"width":for(const t of[1,2]){const s=e[t];switch(s.key){case"m":case"l":case"h":s.coordinates[0]=i*(s.coordinates[0]<0?-1:1);break;case"M":case"L":case"H":s.coordinates[0]=e[0].end.x+i}}break;case"height":for(const t of[2,3]){const s=e[t];switch(s.key){case"m":case"l":case"v":s.coordinates[1]=i*(s.coordinates[1]<0?-1:1);break;case"M":case"L":case"V":s.coordinates[1]=e[0].end.y+i}}break;default:o[h]="";continue}o[h]=N.drawPath(e,n)}}o[h]?r&&(o[h]=N.transformRefit(o[h],i,a,a&&a.parent,n)):o[h]=""}return o}build(t){let e;t&&t.transforms&&(e=N.filterTransforms(t.transforms,t.exclude&&t.exclude[this.element.tagName])),this.draw(e,t)}draw(t,e){let s,i;e&&(s=e.residual,i=e.precision);const a=this.element,n=this.parent,r=this.patternParent,o=!!n&&n.requireRefit,l=!!r&&2===r.patternContentUnits;let h;if(this.transformed=void 0,f.path(a)){if(h=this.getBaseValue("d"),t&&t.length||o||l){const e=N.getPathCommands(h);if(e.length){let c=N.getPathPoints(e);c.length&&(l&&r.patternRefitPoints(c),t&&t.length&&("function"==typeof s&&([this.transformResidual,t]=s.call(this,a,t)),t.length&&(c=N.applyTransforms(t,c,u.origin(this.element)),this.transformed=t)),this.baseValue=N.drawPath(N.syncPathPoints(o?ve.cloneArray(e,[],!0):e,o?ve.cloneArray(c,[],!0):c,void 0!==this.transformed),i),o?(n.refitPoints(c),h=N.drawPath(N.syncPathPoints(e,c,void 0!==this.transformed),i)):h=this.baseValue)}}""===this.baseValue&&(this.baseValue=h)}else if(f.line(a)){let e=[{x:this.getBaseValue("x1"),y:this.getBaseValue("y1")},{x:this.getBaseValue("x2"),y:this.getBaseValue("y2")}];l&&r.patternRefitPoints(e),t&&t.length&&("function"==typeof s&&([this.transformResidual,t]=s.call(this,a,t)),t.length&&(e=N.applyTransforms(t,e,u.origin(this.element)),this.transformed=t));const c=()=>N.drawPolyline(e,i);this.baseValue=c(),o?(n.refitPoints(e),h=c()):h=this.baseValue}else if(f.circle(a)||f.ellipse(a)){const e=this.getBaseValue("cx"),c=this.getBaseValue("cy");let p,d;f.ellipse(a)?(p=this.getBaseValue("rx"),d=this.getBaseValue("ry")):d=p=this.getBaseValue("r");let g=[{x:e,y:c,rx:p,ry:d}];l&&r.patternRefitPoints(g),t&&t.length&&("function"==typeof s&&([this.transformResidual,t]=s.call(this,a,t,p,d)),t.length&&(g=N.applyTransforms(t,g,u.origin(this.element)),this.transformed=t));const m=g[0],y=()=>N.drawEllipse(m.x,m.y,m.rx,m.ry,i);this.baseValue=y(),o?(n.refitPoints(g),h=y()):h=this.baseValue}else if(f.rect(a)){let e=this.getBaseValue("x"),c=this.getBaseValue("y"),f=this.getBaseValue("width"),p=this.getBaseValue("height");if(t&&t.length){let d=[{x:e,y:c},{x:e+f,y:c},{x:e+f,y:c+p},{x:e,y:c+p}];l&&r.patternRefitPoints(d),"function"==typeof s&&([this.transformResidual,t]=s.call(this,a,t)),t.length&&(d=N.applyTransforms(t,d,u.origin(this.element)),this.transformed=t);const g=()=>N.drawPolygon(d,i);this.baseValue=g(),o?(n.refitPoints(d),h=g()):h=this.baseValue}else{l&&(e=r.patternRefitX(e),c=r.patternRefitY(c),f=r.patternRefitX(f),p=r.patternRefitY(p));const t=()=>N.drawRect(f,p,e,c,i);this.baseValue=t(),o?(e=n.refitX(e),c=n.refitY(c),f=n.refitSize(f),p=n.refitSize(p),h=t()):h=this.baseValue}}else if(f.polygon(a)||f.polyline(a)){let e=this.getBaseValue("points");l&&r.patternRefitPoints(e),t&&t.length&&("function"==typeof s&&([this.transformResidual,t]=s.call(this,a,t)),t.length&&(e=N.applyTransforms(t,e,u.origin(this.element)),this.transformed=t));const c=()=>f.polygon(a)?N.drawPolygon(e,i):N.drawPolyline(e,i);this.baseValue=c(),o?(null===this.transformed&&(e=N.clonePoints(e)),n.refitPoints(e),h=c()):h=this.baseValue}else h="";return this.value=h,this.setPaint([h],i),h}extendLength(t,e){if(""!==this.value)switch(this.element.tagName){case"path":case"line":case"polyline":const s=N.getPathCommands(this.value);if(s.length){const i=s[0],a=i.start,n=s[s.length-1],r=n.end,o=n.key.toUpperCase(),l=t.leading,h=t.trailing;let c=!1;if("Z"!==o&&(a.x!==r.x||a.y!==r.y)){if(l>0){let t;if(i.value.length>1?t=i.value[1]:s.length>1&&(t=s[1].start),t)if(t.x===a.x)i.coordinates[1]=i.coordinates[1]+(a.y>t.y?l:-l),c=!0;else if(t.y===a.y)i.coordinates[0]=i.coordinates[0]+(a.x>t.x?l:-l),c=!0;else{const e=ye.relativeAngle(t,a);i.coordinates[0]=i.coordinates[0]-ye.offsetAngleX(e,l),i.coordinates[1]=i.coordinates[1]-ye.offsetAngleY(e,l),c=!0}}switch(o){case"M":case"L":if(h>0){let t;if(1===s.length?i.value.length>1&&(t=i.value[i.value.length-2]):t=n.value.length>1?n.value[n.value.length-2]:s[s.length-2].end,t)if(t.x===r.x)n.coordinates[1]=n.coordinates[1]+(r.y>t.y?h:-h),c=!0;else if(t.y===r.y)n.coordinates[0]=n.coordinates[0]+(r.x>t.x?h:-h),c=!0;else{const e=ye.relativeAngle(t,r),s=n.coordinates[0]+ye.offsetAngleX(e,h),i=n.coordinates[1]+ye.offsetAngleY(e,h);n.coordinates[0]=s,n.coordinates[1]=i,c=!0}}break;case"H":case"V":{const t="H"===o?0:1;n.coordinates[t]=n.coordinates[t]+(l+h)*(n.coordinates[t]>=0?1:-1),c=!0;break}}}if(c)return t.leading=l,t.trailing=h,t.path=N.drawPath(s,e),t}}}flattenStrokeDash(t,e,s,i,a){let n,r,o,l;i||(i=s);let h=0;const c=t=>r[t%n];if(a)({dashArray:r,dashArrayTotal:o,extendedLength:l,startIndex:h}=a),n=r.length,a.items=[],a.leading=0;else{n=t.length,r=t.slice(0);const u=ye.nextMultiple([2,n]);o=0;for(let e=0;e<u;e++){const s=t[e%n];o+=s,e>=n&&r.push(s)}if(n=u,e>0){let t=c(0);for(;e-t>=0;)e-=t,t=c(++h);h%=n}else if(e<0){for(r.reverse();e<0;)e+=c(h++);h=n-h%n,r.reverse()}a={dashArray:r,dashArrayTotal:o,items:[],leading:0,trailing:0,startIndex:h,extendedLength:l=i,lengthRatio:s/(i||s)}}let u,f=0;for(let t=0,s=0;;t+=s,h++){let i,n;s=c(h),t<e?(a.leading=e-t,i=0,n=s-a.leading):(i=t-e,n=s);const r=ye.truncateFraction(i/l);if(u=ye.truncateFraction(r+n/l),h%2==0?r<1&&(a.items.push({start:r,end:Math.min(u,1),length:s}),f+=s):f+=s,u>=1)break}for(a.trailing=ye.truncateFraction((u-1)*l);f%o!=0;){const t=c(++h);a.trailing+=t,f+=t}return 0===a.items.length?a.items.push({start:1,end:1}):(a.leadingOffset=ye.truncateFraction(a.items[0].start*l),a.leading*=a.lengthRatio,a.trailing*=a.lengthRatio),a}extractStrokeDash(t,e){const s=ve.convertInt(this.strokeWidth);let i,a="",n="";if(s>0){let f=N.parseCoordinates(this.strokeDasharray);if(f.length){const p=this.totalLength,d=this.pathLength||p,g=[];let m,y=ve.convertInt(this.strokeDashoffset),v=0;const b=(t,e,s,i=0)=>{const a=this.flattenStrokeDash(t,e,p,d);return 0===g.length&&(m=a),v=Math.max(v,a.items.length),g.push({items:a.items,delay:s,duration:i}),a.items};if(i=b(f,y,0),t){const k=t.slice(0).sort((t,e)=>{if(t.attributeName.startsWith("stroke-dash")&&e.attributeName.startsWith("stroke-dash")){if(t.delay!==e.delay)return t.delay<e.delay?-1:1;if(N.asSet(t)&&N.asAnimate(e)||void 0===t.animationElement&&e.animationElement)return-1;if(N.asAnimate(t)&&N.asSet(e)||t.animationElement&&void 0===e.animationElement)return 1}return 0}),T=new Q(k,"stroke-dasharray","stroke-dashoffset");if(k.length>1)for(let t=0;t<k.length;t++)T.has(k[t].attributeName,k[t].delay,k[t])||k.splice(t--,1);function r(t,e=!1){const s=T.get("stroke-dashoffset",t,e);return s?parseFloat(s):y}function o(t,e=!1){const s=T.get("stroke-dasharray",t,e);return s?N.parseCoordinates(s):f}const x=t=>t?`${t.start} ${t.end}`:"1 1";let R=t=>{let e=y;for(let s=t;s<k.length;s++){const t=k[s];if("stroke-dasharray"===t.attributeName){const s=T.get("stroke-dashoffset",t.delay);s&&(e=parseFloat(s));for(const s of N.asAnimate(t)?T.evaluateStart(t):[t.to])v=Math.max(v,this.flattenStrokeDash(N.parseCoordinates(s),e,p,d).items.length)}}};const A=[];let _=!1;for(let t=0;t<k.length;t++){const V=k[t];if(V.setterType){function l(t,e){b(t,e,V.delay,V.fillReplace&&V.duration>0?V.duration:0),_=!0}switch(V.attributeName){case"stroke-dasharray":l(f=N.parseCoordinates(V.to),r(V.delay));continue;case"stroke-dashoffset":y=ve.convertInt(V.to),l(o(V.delay),y);continue}}else if(N.asAnimate(V)&&V.playable)switch(T.evaluateStart(V),V.attributeName){case"stroke-dasharray":{R&&(R(t),R=void 0);const e=r(V.delay),s=this.flattenStrokeDash(o(V.delay),e,p,d).items,i=[],a=[];for(let t=0;t<v;t++){const e=new j(this.element);e.id=t,e.baseValue=x(s[t]),e.attributeName="stroke-dasharray",e.delay=V.delay,e.duration=V.duration,e.iterationCount=V.iterationCount,e.fillMode=V.fillMode,a[t]=[],i.push(e)}for(const t of V.values){const s=this.flattenStrokeDash(N.parseCoordinates(t),e,p,d).items;for(let t=0;t<v;t++)a[t].push(x(s[t]))}const n=V.keyTimes,l=V.keySplines,h=V.timingFunction;for(let t=0;t<v;t++)i[t].values=a[t],i[t].keyTimes=n,l?i[t].keySplines=l:h&&(i[t].timingFunction=h);if(V.fillReplace){const t=V.getTotalDuration(),e=this.flattenStrokeDash(o(t),r(t),p,d).items;for(let t=0;t<v;t++)i[t].replaceValue=x(e[t])}ve.concatArray(A,i),_=!0;continue}case"stroke-dashoffset":{const t=V.duration,r=parseFloat(V.values[0]),o=[],l=[];let f=0,b=0;y===r||0!==V.delay||V.fillReplace||(m=this.flattenStrokeDash(m.dashArray,r,p,d),g[0].items=i=m.items,v=Math.max(v,m.items.length),y=r);let k,x=p,R=1;if((m.leading>0||m.trailing>0)&&(this.extendLength(m,e),m.path)){const t=N.getBoxRect([this.value]);R=(x=ye.truncateFraction(S(m.path)))/p,m.extendedLength=this.pathLength,m.extendedLength>0?m.extendedLength*=R:m.extendedLength=x;const e=this.flattenStrokeDash(m.dashArray,0,p,d,m);g[0].items=i=e.items,v=Math.max(v,i.length);const r=Math.ceil(s/2);a=m.path,n=N.drawRect(t.right-t.left,t.bottom-t.top+2*r,t.left,t.top-r)}if(V.fillReplace&&-1!==V.iterationCount){const t=ve.convertFloat(T.get(V.attributeName,V.getTotalDuration()));if(t!==y){let e=Math.abs(t-y)%x/x;t>y&&(e=1-e),k=""+e}}for(let e=0;e<V.keyTimes.length;e++){const s=0===e?y:parseFloat(V.values[e-1]),i=parseFloat(V.values[e]),a=Math.abs(i-s),n=V.keyTimes[e];if(0===a){e>0&&(l.push(f=n),o.length?(o.push(o[o.length-1]),b=parseFloat(o[o.length-1])):(o.push("0"),b=0));continue}const r=i>s,p=e>0?(n-V.keyTimes[e-1])*t:0,d=a*m.lengthRatio,g=e=>e/d*p/t;function h(t,e=!1){if(k=(S-t)/x,e){const t=ye.truncateFraction(k);r?t>0&&(k=1-k):0===t&&(k=1)}}function c(){e>0&&(r?"1"===o[o.length-1]:"0"===o[o.length-1])||(l.push(0===f?0:ye.truncateFraction(f)),o.push(r?"1":"0"))}function u(){l.push(f=n);const t=ye.truncateFraction(k);o.push(""+t),b=t>0&&t<1?k:0}let v=d/x,S=d,k=0;if(0===e)S%=x,h(0),r&&(k=1-k),u();else{if(b>0){const t=r?b:1-b,e=ye.truncateFraction(t*x);if(ye.lessEqual(S,e)){h(0),r?k=b-k:k+=b,u();continue}o.push(r?"0":"1"),f+=g(e),l.push(ye.truncateFraction(f)),v=ye.truncateFraction(v-t),S=ye.truncateFraction(S-e)}if(ye.isEqual(S,x)&&(S=x),S>x){const t=(v=Math.floor(v))*x;t===S&&v--,h(t,!0)}else v=0,h(0,!0);for(;v>0;)c(),o.push(r?"0":"1"),f+=g(x),l.push(ye.truncateFraction(f)),v--;c(),u()}}V.baseValue="0",V.replaceValue=k,V.values=o,V.keyTimes=l;const A=V.timingFunction;A&&(V.keySplines=void 0,V.timingFunction=A),_=!0;break}}A.push(V)}if(_){for(let t=0;t<g.length;t++){const e=g[t].items;if(e===i)for(let t=e.length;t<v;t++)e.push({start:1,end:1});else{const s=g[t].delay,a=g[t].duration,n=g.length>2?this.flattenStrokeDash(o(s-1),r(s-1),p,d).items:i;for(let t=0;t<v;t++){const i=new $(this.element);i.id=t,i.attributeName="stroke-dasharray",i.baseValue=x(n[t]),i.delay=s,i.to=x(e[t]),i.duration=a,i.fillFreeze=0===a,A.push(i)}}}t.length=0,ve.concatArray(t,A)}}}}return[i,a,n]}init(){const t=this.element;f.path(t)?this.setBaseValue("d"):f.line(t)?(this.setBaseValue("x1"),this.setBaseValue("y1"),this.setBaseValue("x2"),this.setBaseValue("y2")):f.rect(t)?(this.setBaseValue("x"),this.setBaseValue("y"),this.setBaseValue("width"),this.setBaseValue("height")):f.circle(t)?(this.setBaseValue("cx"),this.setBaseValue("cy"),this.setBaseValue("r")):f.ellipse(t)?(this.setBaseValue("cx"),this.setBaseValue("cy"),this.setBaseValue("rx"),this.setBaseValue("ry")):(f.polygon(t)||f.polyline(t))&&this.setBaseValue("points",N.clonePoints(t.points))}get transforms(){return void 0===this._transforms&&(this._transforms=N.filterTransforms(u.parse(this.element)||N.convertTransforms(this.element.transform.baseVal))),this._transforms}get pathLength(){return ve.convertFloat(me.getNamedItem(this.element,"pathLength"))}get totalLength(){return this.element.getTotalLength()}get instanceType(){return 1028}}class Te extends(Kt(se)){constructor(t,e){super(t),this.element=t,this.patternElement=e}build(t){(t=Object.assign({},t)).patternElement=this.patternElement,t.initialize=!1,super.build(t)}get animations(){return[]}get instanceType(){return 130}}class xe extends(Pt(Kt(le))){constructor(t,e=!0){super(t),this.element=t,e&&this.setPath()}setPath(){this.path=new ke(this.element)}build(t){this.path&&(this.path.parent=this.parent,(t=Object.assign({},t)).transforms=this.transforms,this.path.build(t))}synchronize(t){if(this.path&&this.animations.length){const e=t&&t.element;this.animateSequentially(this.getAnimateShape(e||this.element),e?void 0:this.getAnimateTransform(t),this.path,t)}}set path(t){this._path=t,t&&(t.name=this.name)}get path(){return this._path}get instanceType(){return 2052}}const Re=squared.lib.css,Ae=squared.lib.dom,_e=squared.lib.util,Ve=t=>Re.isPercent(t)?parseFloat(t)/100:parseFloat(t);class we extends(de(F(Kt(se)))){constructor(t,e){super(t),this.element=t,this.patternElement=e,this.__get_transforms=!1,this.patternUnits="userSpaceOnUse"===Ae.getNamedItem(this.patternElement,"patternUnits")?1:2,this.patternContentUnits="objectBoundingBox"===Ae.getNamedItem(this.patternElement,"patternContentUnits")?2:1}build(t){const e=t&&t.element||this.element,s=new ke(e);if(s.build(t),s.value){const i=(t=Object.assign({},t))&&t.precision;this.clipRegion=s.value,s.clipPath&&(this.clipRegion=s.clipPath);const a=[s.value];this.setPaint(a,i),this.drawRegion=N.getBoxRect(a);const n=this.patternWidth,r=this.patternHeight,o=this.tileWidth,l=this.tileHeight;let h=this.offsetX%o,c=this.offsetY%l,u=0,f=0,p=this.drawRegion.right,d=this.drawRegion.bottom;2===this.patternUnits&&(p-=this.drawRegion.left,d-=this.drawRegion.top,u=this.drawRegion.left,f=this.drawRegion.top);let g=0;for(0!==h&&(h=o-h,p+=o),0!==c&&(c=l-c,d+=l);d>0;){const s=f+g*l-c;let a=p,m=0;do{const c=u+m*o-h,f=new Te(e,this.patternElement);f.build(t);for(const e of f.cascade())N.isShape(e)&&(e.setPath(),e.path&&(e.path.patternParent=this,2===this.patternContentUnits?e.path.refitBaseValue(c/n,s/r,i):e.path.refitBaseValue(c,s,i),t.transforms=e.transforms,e.path.build(t),e.path.fillOpacity=""+parseFloat(e.path.fillOpacity)*parseFloat(this.fillOpacity),e.path.clipPath=N.drawRect(o,l,c,s,i)+(""!==e.path.clipPath?`;${e.path.clipPath}`:"")));this.append(f),a-=o,m++}while(a>0);g++,d-=l}if(""!==this.stroke&&parseFloat(this.strokeWidth)>0){s.fill="",s.fillOpacity="0",s.stroke=this.stroke,s.strokeWidth=this.strokeWidth;const t=new xe(e,!1);t.path=s,this.append(t)}}}patternRefitX(t){return this.drawRegion?t*this.patternWidth:t}patternRefitY(t){return this.drawRegion?t*this.patternHeight:t}patternRefitPoints(t){if(this.drawRegion){const e=this.patternWidth,s=this.patternHeight;for(const i of t)if(i.x*=e,i.y*=s,void 0!==i.rx&&void 0!==i.ry)if(i.rx===i.ry){const t=Math.min(e,s);i.rx*=t,i.ry*=t}else i.rx*=e,i.ry*=s}return t}get patternWidth(){return this.drawRegion?this.drawRegion.right-this.drawRegion.left:0}get patternHeight(){return this.drawRegion?this.drawRegion.bottom-this.drawRegion.top:0}get transforms(){if(!this.__get_transforms){const t=N.convertTransforms(this.patternElement.patternTransform.baseVal);if(t.length){const e=u.rotateOrigin(this.patternElement,"patternTransform"),s=this.patternWidth/2,i=this.patternHeight/2;for(const a of t)switch(a.type){case SVGTransform.SVG_TRANSFORM_TRANSLATE:break;case SVGTransform.SVG_TRANSFORM_ROTATE:for(;e.length;){const t=e.shift();if(t.angle===a.angle){a.origin={x:s+t.x,y:i+t.y};break}}if(a.origin)break;default:a.origin={x:s,y:i}}_e.concatArray(super.transforms,N.filterTransforms(t))}this.__get_transforms=!0}return super.transforms}get offsetX(){let t=0;return 2===this.patternUnits&&(t=this.patternWidth*Ve(this.patternElement.x.baseVal.valueAsString)),t||this.patternElement.x.baseVal.value}get offsetY(){let t=0;return 2===this.patternUnits&&(t=this.patternHeight*Ve(this.patternElement.y.baseVal.valueAsString)),t||this.patternElement.y.baseVal.value}get tileWidth(){let t=0;return 2===this.patternUnits&&(t=this.patternWidth*Ve(this.patternElement.width.baseVal.valueAsString)),t||this.patternElement.width.baseVal.value}get tileHeight(){let t=0;return 2===this.patternUnits&&(t=this.patternHeight*Ve(this.patternElement.height.baseVal.valueAsString)),t||this.patternElement.height.baseVal.value}get instanceType(){return 258}}const Ee=squared.lib.util;const Ne=squared.lib.util;const Me={constant:q,util:k};t.Svg=class extends(Pt(Jt(F(Kt(se))))){constructor(t,e=!0){super(t),this.element=t,this.documentRoot=e,this.definitions={clipPath:new Map,pattern:new Map,gradient:new Map},this.init()}build(t){this.precision=t&&t.precision,this.setRect(),super.build(t)}synchronize(t){!this.documentRoot&&this.animations.length&&this.animateSequentially(this.getAnimateViewRect(),this.getAnimateTransform(t),void 0,t),super.synchronize(t)}init(){this.documentRoot&&(ne.cloneObject(this.element.viewBox.baseVal,this.aspectRatio),this.element.querySelectorAll("set, animate, animateTransform, animateMotion").forEach(t=>{const e=y(t,this.element);e&&(t.parentElement&&t.parentElement.removeChild(t),e.appendChild(t))})),this.setDefinitions(this.element),this.element.querySelectorAll("defs").forEach(t=>this.setDefinitions(t))}setDefinitions(t){t.querySelectorAll("clipPath, pattern, linearGradient, radialGradient").forEach(t=>{if(t.id){const e=`#${t.id}`;f.clipPath(t)?this.definitions.clipPath.set(e,t):f.pattern(t)?this.definitions.pattern.set(e,t):f.linearGradient(t)?this.definitions.gradient.set(e,Object.assign({type:"linear",element:t,spreadMethod:t.spreadMethod.baseVal,colorStops:re(t)},oe(t,"x1","x2","y1","y2"))):f.radialGradient(t)&&this.definitions.gradient.set(e,Object.assign({type:"radial",element:t,spreadMethod:t.spreadMethod.baseVal,colorStops:re(t)},oe(t,"cx","cy","r","fx","fy","fr")))}})}get viewBox(){return this.element.viewBox.baseVal||p(this.element)}get instanceType(){return 18}},t.SvgAnimate=j,t.SvgAnimateMotion=Lt,t.SvgAnimateTransform=K,t.SvgAnimation=$,t.SvgAnimationIntervalMap=Q,t.SvgBaseVal=F,t.SvgBuild=N,t.SvgContainer=se,t.SvgElement=le,t.SvgG=class extends(de(Kt(se))){constructor(t){super(t),this.element=t}build(t){super.build(t),this.setPaint(this.getPathAll(),t&&t.precision)}get instanceType(){return 34}},t.SvgImage=class extends(Jt(F(Kt(le)))){constructor(t,e){super(t),this.element=t,this.imageElement=null,this.__get_transforms=!1,this.__get_animations=!1,e&&(this.imageElement=e)}build(){this.setRect()}extract(t){const e=t?N.filterTransforms(this.transforms,t):this.transforms;let{x:s,y:i,width:a,height:n}=this;if(e.length){e.reverse();for(let t=0;t<e.length;t++){const r=e[t],o=r.matrix,l=s;switch(s=c.applyX(o,l,i),i=c.applyY(o,l,i),r.type){case SVGTransform.SVG_TRANSFORM_SCALE:a*=o.a,n*=o.d;break;case SVGTransform.SVG_TRANSFORM_ROTATE:0!==r.angle&&(o.a<0&&(s+=o.a*a),o.c<0&&(s+=o.c*a),o.b<0&&(i+=o.b*n),o.d<0&&(i+=o.d*n),this.rotateAngle?this.rotateAngle+=r.angle:this.rotateAngle=r.angle)}}this.transformed=e}this.parent&&(s=this.parent.refitX(s),i=this.parent.refitY(i),a=this.parent.refitSize(a),n=this.parent.refitSize(n)),this.translationOffset&&(s+=this.translationOffset.x,i+=this.translationOffset.y),this.setBaseValue("x",s),this.setBaseValue("y",i),this.setBaseValue("width",a),this.setBaseValue("height",n)}set x(t){super.x=t}get x(){const t=super.x;return 0===t&&this.imageElement?this.imageElement.x.baseVal.value:t}set y(t){super.y=t}get y(){const t=super.y;return 0===t&&this.imageElement?this.imageElement.y.baseVal.value:t}set width(t){super.width=t}get width(){const t=super.width;return 0===t&&this.imageElement?this.imageElement.width.baseVal.value:t}set height(t){super.height=t}get height(){const t=super.height;return 0===t&&this.imageElement?this.imageElement.height.baseVal.value:t}get href(){const t=this.imageElement||this.element;return f.image(t)?ge.resolvePath(t.href.baseVal):""}get transforms(){const t=super.transforms;return this.__get_transforms||(this.imageElement&&ge.concatArray(t,this.getTransforms(this.imageElement)),this.__get_transforms=!0),t}get animations(){const t=super.animations;return this.__get_animations||(this.imageElement&&ge.concatArray(t,this.getAnimations(this.imageElement)),this.__get_animations=!0),t}get instanceType(){return 4100}},t.SvgPaint=de,t.SvgPath=ke,t.SvgPattern=Te,t.SvgShape=xe,t.SvgShapePattern=we,t.SvgSynchronize=Pt,t.SvgUse=class extends(de(Jt(F(xe)))){constructor(t,e,s=!0){super(t,!1),this.element=t,this.shapeElement=e,this.__get_transforms=!1,this.__get_animations=!1,s&&this.setPath()}setPath(){this.path=new ke(this.shapeElement),this.path.useParent=this}build(t){super.build(t),this.setPaint(this.path?[this.path.value]:void 0,t&&t.precision)}synchronize(t){(t=Object.assign({},t)).element=this.shapeElement,this.animations.length&&this.animateSequentially(this.getAnimateViewRect(),this.getAnimateTransform(t),void 0,t),super.synchronize(t)}get transforms(){const t=super.transforms;return this.__get_transforms||(Ee.concatArray(t,this.getTransforms(this.shapeElement)),this.__get_transforms=!0),t}get animations(){const t=super.animations;return this.__get_animations||(Ee.concatArray(t,this.getAnimations(this.shapeElement)),this.__get_animations=!0),t}get instanceType(){return 10244}},t.SvgUsePattern=class extends(Pt(Jt(we))){constructor(t,e,s){super(t,s),this.element=t,this.shapeElement=e}build(t){t=Object.assign({},t,{element:this.shapeElement}),super.build(t)}synchronize(t){const e=Ne.filterArray(this.animations,t=>void 0===this.verifyBaseValue(t.attributeName,0)||"x"===t.attributeName||"y"===t.attributeName),s=this.getAnimateTransform(t);(e.length||s.length)&&this.animateSequentially(this.getAnimateViewRect(e),s,void 0,t),super.synchronize(t)}get instanceType(){return 514}},t.SvgUseSymbol=class extends(de(Pt(Jt(F(Kt(se)))))){constructor(t,e){super(t),this.element=t,this.symbolElement=e}build(t){t=Object.assign({},t,{symbolElement:this.symbolElement}),this.setRect(),super.build(t);const e=this.getBaseValue("x",0),s=this.getBaseValue("y",0);if(0!==e||0!==s){const t={x:e,y:s};for(const e of this.cascade())e.translationOffset=t}this.setPaint(this.getPathAll(),t&&t.precision)}synchronize(t){this.animations.length&&this.animateSequentially(this.getAnimateViewRect(),this.getAnimateTransform(t),void 0,t),super.synchronize(t)}get viewBox(){return this.symbolElement.viewBox.baseVal||p(this.element)}get instanceType(){return 66}},t.SvgView=Kt,t.SvgViewRect=Jt,t.lib=Me,Object.defineProperty(t,"__esModule",{value:!0})});
