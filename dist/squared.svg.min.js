!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e(((t=t||self).squared=t.squared||{},t.squared.svg={}))}(this,function(t){"use strict";const{constant:e,css:s,dom:i,math:a,regex:n,session:r,util:o}=squared.lib,l={path:1,line:2,rect:3,ellipse:4,circle:5,polyline:6,polygon:7},h=`(${n.STRING.DECIMAL})`,c={MATRIX:RegExp(`(matrix(?:3d)?)\\(${h}, ${h}, ${h}, ${h}, ${h}, ${h}(?:, ${h})?(?:, ${h})?(?:, ${h})?(?:, ${h})?(?:, ${h})?(?:, ${h})?(?:, ${h})?(?:, ${h})?(?:, ${h})?(?:, ${h})?\\)`,"g"),ROTATE:RegExp(`(rotate[XY]?)\\(${n.STRING.CSS_ANGLE}\\)`,"g"),SKEW:RegExp(`(skew[XY]?)\\(${n.STRING.CSS_ANGLE}(?:, ${n.STRING.CSS_ANGLE})?\\)`,"g"),SCALE:RegExp(`(scale[XY]?)\\(${h}(?:, ${h})?\\)`,"g"),TRANSLATE:RegExp(`(translate[XY]?)\\(${n.STRING.LENGTH_PERCENTAGE}(?:, ${n.STRING.LENGTH_PERCENTAGE})?\\)`,"g")};let u;const f={applyX:(t,e,s)=>t.a*e+t.c*s+t.e,applyY:(t,e,s)=>t.b*e+t.d*s+t.f,clone:t=>({a:t.a,b:t.b,c:t.c,d:t.d,e:t.e,f:t.f}),rotate(t){const e=a.convertRadian(t),s=Math.cos(e),i=Math.sin(e);return{a:s,b:i,c:-1*i,d:s,e:0,f:0}},skew:(t=0,e=0)=>({a:1,b:Math.tan(a.convertRadian(e)),c:Math.tan(a.convertRadian(t)),d:1,e:0,f:0}),scale:(t=1,e=1)=>({a:t,b:0,c:0,d:e,e:0,f:0}),translate:(t=0,e=0)=>({a:1,b:0,c:0,d:1,e:t,f:e})},p={create:(t,e,s=0,i=!0,a=!0)=>({type:t,matrix:e,angle:s,method:{x:i,y:a}}),parse(t,e){const i=e||t.style.getPropertyValue("transform");if(""!==i){const a=[];for(const n in c){let r;for(c[n].lastIndex=0;null!==(r=c[n].exec(i));){const i=r[1].endsWith("X"),n=r[1].endsWith("Y");if(r[1].startsWith("rotate")){const t=s.convertAngle(r[2],r[3]),e=f.rotate(t);i?(e.a=1,e.b=0,e.c=0):n&&(e.b=0,e.c=0,e.d=1),a[r.index]=p.create(SVGTransform.SVG_TRANSFORM_ROTATE,e,t,!i,!n)}else if(r[1].startsWith("skew")){const t=n?0:s.convertAngle(r[2],r[3]),e=n?s.convertAngle(r[2],r[3]):r[4]&&r[5]?s.convertAngle(r[4],r[5]):0,o=f.skew(t,e);i?a[r.index]=p.create(SVGTransform.SVG_TRANSFORM_SKEWX,o,t,!0,!1):n?a[r.index]=p.create(SVGTransform.SVG_TRANSFORM_SKEWY,o,e,!1,!0):(a[r.index]=p.create(SVGTransform.SVG_TRANSFORM_SKEWX,Object.assign({},o,{b:0}),t,!0,!1),0!==e&&(a[r.index+1]=p.create(SVGTransform.SVG_TRANSFORM_SKEWY,Object.assign({},o,{c:0}),e,!1,!0)))}else if(r[1].startsWith("scale")){const t=n?void 0:parseFloat(r[2]),e=n?parseFloat(r[2]):!i&&r[3]?parseFloat(r[3]):t,s=f.scale(t,i?void 0:e);a[r.index]=p.create(SVGTransform.SVG_TRANSFORM_SCALE,s,0,!n,!i)}else if(r[1].startsWith("translate")){const e=s.getFontSize(t),o=s.parseUnit(r[2],e),l=!i&&r[3]?s.parseUnit(r[3],e):0,h=f.translate(n?0:o,n?o:l);a[r.index]=p.create(SVGTransform.SVG_TRANSFORM_TRANSLATE,h,0)}else if(r[1].startsWith("matrix")){const s=p.matrix(t,e);s&&(a[r.index]=p.create(SVGTransform.SVG_TRANSFORM_MATRIX,s))}}}const n=[];return a.forEach(t=>{t.fromCSS=!0,n.push(t)}),n}},matrix(t,e){c.MATRIX.lastIndex=0;const i=c.MATRIX.exec(e||s.getStyle(t).transform||"");if(i)switch(i[1]){case"matrix":return{a:parseFloat(i[2]),b:parseFloat(i[3]),c:parseFloat(i[4]),d:parseFloat(i[5]),e:parseFloat(i[6]),f:parseFloat(i[7])};case"matrix3d":return{a:parseFloat(i[2]),b:parseFloat(i[3]),c:parseFloat(i[6]),d:parseFloat(i[7]),e:parseFloat(i[14]),f:parseFloat(i[15])}}},origin(t,i){void 0===i&&(i=g(t,"transform-origin"));const a={x:0,y:0};if(""!==i){const r=b(t);function n(e,i,n){s.isLength(i)?a[e]=s.parseUnit(i,s.getFontSize(t)):s.isPercent(i)&&(a[e]=parseFloat(i)/100*n)}let o=0,l=0;if(r)o=r.width,l=r.height;else{const e=t.parentElement;e instanceof SVGGraphicsElement&&e.viewportElement&&(d.svg(e.viewportElement)||d.symbol(e.viewportElement))&&(o=e.viewportElement.viewBox.baseVal.width,l=e.viewportElement.viewBox.baseVal.height)}if(!o||!l){const e=t.getBoundingClientRect();o=e.width,l=e.height}const h=i.split(" ");switch(1===h.length&&h.push(e.CSS.CENTER),h[0]){case e.CSS.PERCENT_0:case e.CSS.LEFT:break;case e.CSS.PERCENT_100:case e.CSS.RIGHT:a.x=o;break;case e.CSS.CENTER:h[0]=e.CSS.PERCENT_50;default:n("x",h[0],o)}switch(h[1]){case e.CSS.PERCENT_0:case e.CSS.TOP:break;case e.CSS.PERCENT_100:case e.CSS.BOTTOM:a.y=l;break;case e.CSS.CENTER:h[1]=e.CSS.PERCENT_50;default:n("y",h[1],l)}}return a},rotateOrigin(t,e="transform"){const s=i.getNamedItem(t,e),a=[];if(""!==s){let t;for(void 0===u?u=/rotate\((-?[\d.]+)(?:,? (-?[\d.]+))?(?:,? (-?[\d.]+))?\)/g:u.lastIndex=0;null!==(t=u.exec(s));){const e=parseFloat(t[1]);0!==e&&a.push({angle:e,x:t[2]?parseFloat(t[2]):0,y:t[3]?parseFloat(t[3]):0})}}return a},typeAsName(t){switch(t){case SVGTransform.SVG_TRANSFORM_ROTATE:return"rotate";case SVGTransform.SVG_TRANSFORM_SCALE:return"scale";case SVGTransform.SVG_TRANSFORM_SKEWX:return"skewX";case SVGTransform.SVG_TRANSFORM_SKEWY:return"skewY";case SVGTransform.SVG_TRANSFORM_TRANSLATE:return"translate";default:return""}},typeAsValue(t){switch(t){case"rotate":case SVGTransform.SVG_TRANSFORM_ROTATE:return"0 0 0";case"scale":case SVGTransform.SVG_TRANSFORM_SCALE:return"1 1 0 0";case"skewX":case"skewY":case SVGTransform.SVG_TRANSFORM_SKEWX:case SVGTransform.SVG_TRANSFORM_SKEWY:return"0";case"translate":case SVGTransform.SVG_TRANSFORM_TRANSLATE:return"0 0";default:return""}}},d={svg:t=>"svg"===t.tagName,g:t=>"g"===t.tagName,symbol:t=>"symbol"===t.tagName,path:t=>"path"===t.tagName,shape:t=>void 0!==l[t.tagName],image:t=>"image"===t.tagName,use:t=>"use"===t.tagName,line:t=>"line"===t.tagName,rect:t=>"rect"===t.tagName,circle:t=>"circle"===t.tagName,ellipse:t=>"ellipse"===t.tagName,polygon:t=>"polygon"===t.tagName,polyline:t=>"polyline"===t.tagName,clipPath:t=>"clipPath"===t.tagName,pattern:t=>"pattern"===t.tagName,linearGradient:t=>"linearGradient"===t.tagName,radialGradient:t=>"radialGradient"===t.tagName};function m(t){const e=t.getBoundingClientRect();return e.x=e.left,e.y=e.top,e}function g(t,e,a=!0){let n=i.getNamedItem(t,e);if(""===n){const i=r.getElementCache(t,"styleMap");i&&(n=i[o.convertCamelCase(e)]||""),""===n&&(a||Array.from(t.style).includes(e))&&(n=s.getStyle(t).getPropertyValue(e))}return n.trim()}function y(t,e,s=!0){let i=t,a="";for(;i&&!(i instanceof HTMLElement)&&(""===(a=g(i,e,s))||"inherit"===a);)i=i.parentElement;return a}function v(t){const e=n.CSS.URL.exec(t);return e?e[1]:""}function S(t,e){const s=i.getNamedItem(t,"href");if("#"===s.charAt(0)){const i=s.substring(1);let a;if(e)a=e;else for(a=t.parentElement;a&&a.parentElement instanceof SVGGraphicsElement;)a=a.parentElement;if(a){const t=a.querySelectorAll("*"),e=t.length;for(let s=0;s<e;s++){const e=t.item(s);if(e.id===i&&e instanceof SVGElement)return e}}else{const t=document.getElementById(i);if(t instanceof SVGElement)return t}}return null}function b(t){let e=t.parentElement;for(;e;){if((d.svg(e)||d.symbol(e))&&e.viewBox&&e.viewBox.baseVal.width>0&&e.viewBox.baseVal.height>0)return e.viewBox.baseVal;e=e.parentElement}}function T(t){const e=document.createElementNS("http://www.w3.org/2000/svg","path");return e.setAttribute("d",t),e}function k(t){return T(t).getTotalLength()}var x=Object.freeze({MATRIX:f,TRANSFORM:p,SVG:d,getDOMRect:m,getAttribute:g,getParentAttribute:y,getAttributeURL:v,getTargetElement:S,getNearestViewBox:b,createPath:T,getPathLength:k});const{css:R,dom:A,math:_,regex:E,util:V}=squared.lib,w=RegExp(E.STRING.DECIMAL,"g"),N=/([A-Za-z])([^A-Za-z]+)?/g,M=new Map;class P{static isContainer(t){return V.hasBit(t.instanceType,2)}static isElement(t){return V.hasBit(t.instanceType,4)}static isShape(t){return V.hasBit(t.instanceType,2052)}static isAnimate(t){return V.hasBit(t.instanceType,16392)}static isAnimateTransform(t){return V.hasBit(t.instanceType,49160)}static asSvg(t){return 18===t.instanceType}static asG(t){return 34===t.instanceType}static asPattern(t){return 130===t.instanceType}static asShapePattern(t){return 258===t.instanceType}static asUsePattern(t){return 514===t.instanceType}static asImage(t){return 4100===t.instanceType}static asUse(t){return 10244===t.instanceType}static asUseSymbol(t){return 66===t.instanceType}static asSet(t){return 8===t.instanceType}static asAnimate(t){return 16392===t.instanceType}static asAnimateTransform(t){return 49160===t.instanceType}static asAnimateMotion(t){return 114696===t.instanceType}static setName(t){if(t){let e,s="";if(V.isString(t.id)){const i=V.convertWord(t.id,!0);M.has(i)||(s=i),e=i}else e=t.tagName;let i=M.get(e)||0;return""!==s?(M.set(s,i),s):(M.set(e,++i),`${e}_${i}`)}return M.clear(),""}static drawLine(t,e,s=0,i=0,a){return a&&(t=_.truncate(t,a),e=_.truncate(e,a),s=_.truncate(s,a),i=_.truncate(i,a)),`M${t},${e} L${s},${i}`}static drawRect(t,e,s=0,i=0,a){return a?(t=_.truncate(s+t,a),e=_.truncate(i+e,a),s=_.truncate(s,a),i=_.truncate(i,a)):(t+=s,e+=i),`M${s},${i} ${t},${i} ${t},${e} ${s},${e} Z`}static drawCircle(t,e,s,i){return P.drawEllipse(t,e,s,s,i)}static drawEllipse(t,e,s,i,a){void 0===i&&(i=s);let n=2*s;return a?(t=_.truncate(t-s,a),e=_.truncate(e,a),s=_.truncate(s,a),i=_.truncate(i,a),n=_.truncate(n,a)):t-=s,`M${t},${e} a${s},${i},0,0,1,${n},0 a${s},${i},0,0,1,-${n},0`}static drawPolygon(t,e){return t.length?`${P.drawPolyline(t,e)} Z`:""}static drawPolyline(t,e){let s="M";if(e)for(const i of t)s+=` ${_.truncate(i.x,e)},${_.truncate(i.y,e)}`;else for(const e of t)s+=` ${e.x},${e.y}`;return s}static drawPath(t,e){let s="";for(const e of t)switch(s+=(""!==s?" ":"")+e.key,e.key.toUpperCase()){case"M":case"L":case"C":case"S":case"Q":case"T":s+=e.coordinates.join(",");break;case"H":s+=e.coordinates[0];break;case"V":s+=e.coordinates[1];break;case"A":s+=`${e.radiusX},${e.radiusY},${e.xAxisRotation},${e.largeArcFlag},${e.sweepFlag},${e.coordinates.join(",")}`}return e?_.truncateString(s,e):s}static drawRefit(t,e,s){let i;if(d.path(t)){if(i=A.getNamedItem(t,"d"),e&&e.requireRefit){const t=P.getPathCommands(i);if(t.length){const a=P.getPathPoints(t);a.length&&(e.refitPoints(a),i=P.drawPath(P.syncPathPoints(t,a),s))}}}else if(d.line(t)){const a=[{x:t.x1.baseVal.value,y:t.y1.baseVal.value},{x:t.x2.baseVal.value,y:t.y2.baseVal.value}];e&&e.requireRefit&&e.refitPoints(a),i=P.drawPolyline(a,s)}else if(d.circle(t)||d.ellipse(t)){let a,n;d.ellipse(t)?(a=t.rx.baseVal.value,n=t.ry.baseVal.value):n=a=t.r.baseVal.value;const r=[{x:t.cx.baseVal.value,y:t.cy.baseVal.value,rx:a,ry:n}];e&&e.requireRefit&&e.refitPoints(r);const o=r[0];i=P.drawEllipse(o.x,o.y,o.rx,o.ry,s)}else if(d.rect(t)){let a=t.x.baseVal.value,n=t.y.baseVal.value,r=t.width.baseVal.value,o=t.height.baseVal.value;e&&e.requireRefit&&(a=e.refitX(a),n=e.refitY(n),r=e.refitSize(r),o=e.refitSize(o)),i=P.drawRect(r,o,a,n,s)}else if(d.polygon(t)||d.polyline(t)){const a=P.clonePoints(t.points);e&&e.requireRefit&&e.refitPoints(a),i=d.polygon(t)?P.drawPolygon(a,s):P.drawPolyline(a,s)}else i="";return i}static transformRefit(t,e,s,i,a){const n=P.getPathCommands(t);if(n.length){let r=P.getPathPoints(n);if(r.length){const o=e&&e.length>0;o&&(r=P.applyTransforms(e,r,s&&p.origin(s.element))),i&&i.requireRefit&&i.refitPoints(r),t=P.drawPath(P.syncPathPoints(n,r,o),a)}}return t}static getOffsetPath(t,e="auto 0deg"){const s=T(t),i=Math.ceil(s.getTotalLength()),a=[];if(i>0){const n=[],r=[];let o=0,l=0;if(R.isAngle(e))o=R.parseAngle(e);else{const s=P.getPathCommands(t);for(const t of s)switch(t.key.toUpperCase()){case"M":case"L":case"H":case"V":case"Z":for(const e of t.value)n.push(e),r.push(!1);break;case"C":case"S":case"Q":case"T":case"A":n.push(t.end),r.push(!0)}"auto 0deg"!==e&&(l=R.parseAngle(e.split(" ").pop()))}let h,c=!1,u=0,f=0;for(let t=0;t<=i;t++){const e=s.getPointAtLength(t);if(n.length){const t=n.findIndex(t=>{const s=""+t.x,i=""+t.y;return s===e.x.toPrecision(s.length-(-1!==s.indexOf(".")?1:0))&&i===e.y.toPrecision(i.length-(-1!==i.indexOf(".")?1:0))});if(-1!==t){const s=n[t+1];s?(c=r[t+1])?(h=P.centerPoints(n[t],s),o=0):(h=void 0,o=_.truncateFraction(_.absoluteAngle(e,s))):h=void 0,f=0,n.splice(0,t+1),r.splice(0,t+1)}}let i;c?(i=h?_.truncateFraction(_.relativeAngle(h,e)):0,u>0&&u%360==0&&0===Math.floor(i)&&(f=u),i+=f):i=o,a.push({key:t,value:e,rotate:i+=l}),u=Math.ceil(i)}}return a}static getPathCommands(t){N.lastIndex=0;const e=[];let s;for(t=t.trim();null!==(s=N.exec(t))&&(0!==e.length||"M"===s[1].toUpperCase());){const t=P.parseCoordinates((s[2]||"").trim());let i,a,n,r,o,l,h;if(e.length){const t=e[e.length-1];i=t.key.toUpperCase(),a=t.end}switch(s[1].toUpperCase()){case"M":0===e.length&&(s[1]="M");case"L":if(t.length>=2){t.length%2!=0&&t.length--;break}continue;case"H":if(a&&t.length){t[1]="h"===s[1]?0:a.y,t.length=2;break}continue;case"V":if(a&&t.length){const e=t[0];t[0]="v"===s[1]?0:a.x,t[1]=e,t.length=2;break}continue;case"Z":if(e.length){t[0]=e[0].coordinates[0],t[1]=e[0].coordinates[1],t.length=2,s[1]="Z";break}continue;case"C":if(t.length>=6){t.length=6;break}continue;case"S":if(t.length>=4&&("C"===i||"S"===i)){t.length=4;break}continue;case"Q":if(t.length>=4){t.length=4;break}continue;case"T":if(t.length>=2&&("Q"===i||"T"===i)){t.length=2;break}continue;case"A":if(t.length>=7){n=t[0],r=t[1],o=t[2],l=t[3],h=t[4],t[0]=t[5],t[1]=t[6],t.length=2;break}continue;default:continue}const c=t.length;if(c>=2){const i=s[1]===s[1].toLowerCase(),u=[];for(let e=0;e<c;e+=2){let s=t[e],n=t[e+1];i&&a&&(s+=a.x,n+=a.y),u.push({x:s,y:n})}e.push({key:s[1],value:u,start:u[0],end:u[u.length-1],relative:i,coordinates:t,radiusX:n,radiusY:r,xAxisRotation:o,largeArcFlag:l,sweepFlag:h})}}return e}static getPathPoints(t,e=!1){const s=[];let i=0,a=0;for(const n of t){const t=n.coordinates,r=t.length;for(let o=0;o<r;o+=2){n.relative?(i+=t[o],a+=t[o+1]):(i=t[o],a=t[o+1]);const r={x:i,y:a};"A"===n.key.toUpperCase()&&(r.rx=n.radiusX,r.ry=n.radiusY,e&&(t[o]>=0?r.y-=n.radiusY:r.y+=n.radiusY)),s.push(r)}n.relative&&(n.key=n.key.toUpperCase())}return s}static syncPathPoints(t,e,s=!1){t:{let i;for(const a of t){const n=a.coordinates;if(a.relative){if(!i)break;if(!s||"H"!==a.key&&"V"!==a.key){const t=n.length;for(let s=0,r=0;s<t;s+=2,r++){const t=e.shift();if(!t)break t;n[s]=t.x-i.x,n[s+1]=t.y-i.y,"a"===a.key&&void 0!==t.rx&&void 0!==t.ry&&(a.radiusX=t.rx,a.radiusY=t.ry),a.value[r]=t}a.key=a.key.toLowerCase()}else{const t=e.shift();if(!t)break t;n[0]=t.x,n[1]=t.y,a.value[0]=t,a.start=t,a.end=t,a.key="L",a.relative=!1}i=a.end}else{switch(a.key.toUpperCase()){case"M":case"L":case"H":case"V":case"C":case"S":case"Q":case"T":case"Z":{const s=n.length;for(let i=0,r=0;i<s;i+=2,r++){const s=e.shift();if(!s){t=[];break t}n[i]=s.x,n[i+1]=s.y,a.value[r]=s}break}case"A":{const s=e.shift();if(!s||void 0===s.rx||void 0===s.ry){t=[];break t}n[0]=s.x,n[1]=s.y,a.radiusX=s.rx,a.radiusY=s.ry,a.value[0]=s;break}}a.relative||(i=a.end)}}}return t}static filterTransforms(t,e){const s=[];for(const i of t)if(void 0===e||!e.includes(i.type)){switch(i.type){case SVGTransform.SVG_TRANSFORM_ROTATE:case SVGTransform.SVG_TRANSFORM_SKEWX:case SVGTransform.SVG_TRANSFORM_SKEWY:if(0===i.angle)continue;break;case SVGTransform.SVG_TRANSFORM_SCALE:if(1===i.matrix.a&&1===i.matrix.d)continue;break;case SVGTransform.SVG_TRANSFORM_TRANSLATE:if(0===i.matrix.e&&0===i.matrix.f)continue}s.push(i)}return s}static applyTransforms(t,e,s){t=t.slice(0).reverse();const i=P.clonePoints(e);for(const e of t){const t=e.matrix;let a=0,n=0,r=0,o=0;if(s)switch(e.type){case SVGTransform.SVG_TRANSFORM_SCALE:e.method.x&&(r=s.x*(1-t.a)),e.method.y&&(o=s.y*(1-t.d));break;case SVGTransform.SVG_TRANSFORM_SKEWX:e.method.y&&(n-=s.y);break;case SVGTransform.SVG_TRANSFORM_SKEWY:e.method.x&&(a-=s.x);break;case SVGTransform.SVG_TRANSFORM_ROTATE:e.method.x&&(a-=s.x,r=s.x+_.offsetAngleY(e.angle,s.x)),e.method.y&&(n-=s.y,o=s.y+_.offsetAngleY(e.angle,s.y))}for(const s of i){const i=s.x;if(s.x=f.applyX(t,i,s.y+n)+r,s.y=f.applyY(t,i+a,s.y)+o,e.type===SVGTransform.SVG_TRANSFORM_SCALE&&void 0!==s.rx&&void 0!==s.ry){const e=s.rx;s.rx=f.applyX(t,e,s.ry+n),s.ry=f.applyY(t,e+a,s.ry)}}}return i}static convertTransforms(t){const e=[];for(let s=0;s<t.numberOfItems;s++){const i=t.getItem(s);e.push(p.create(i.type,i.matrix,i.angle))}return e}static clonePoints(t){const e=[];if(Array.isArray(t))for(const s of t){const t={x:s.x,y:s.y};void 0!==s.rx&&void 0!==s.ry&&(t.rx=s.rx,t.ry=s.ry),e.push(t)}else for(let s=0;s<t.numberOfItems;s++){const i=t.getItem(s);e.push({x:i.x,y:i.y})}return e}static minMaxPoints(t){let e=t[0].x,s=e,i=t[0].y,a=i;const n=t.length;for(let r=1;r<n;r++){const n=t[r];n.x<e?e=n.x:n.x>s&&(s=n.x),n.y<i?i=n.y:n.y>a&&(a=n.y)}return[e,i,s,a]}static centerPoints(...t){const e=this.minMaxPoints(t);return{x:(e[0]+e[2])/2,y:(e[1]+e[3])/2}}static convertPoints(t){const e=[],s=t.length;if(s%2==0)for(let i=0;i<s;i+=2)e.push({x:t[i],y:t[i+1]});return e}static parsePoints(t){const e=[];for(const s of t.trim().split(E.CHAR.SPACE)){const[t,i]=V.replaceMap(s.split(E.XML.SEPARATOR),t=>parseFloat(t));e.push({x:t,y:i})}return e}static parseCoordinates(t){w.lastIndex=0;const e=[];let s;for(;null!==(s=w.exec(t));){const t=parseFloat(s[0]);isNaN(t)||e.push(t)}return e}static getBoxRect(t){let e=[];for(const s of t)e=e.concat(P.getPathPoints(P.getPathCommands(s),!0));const s=this.minMaxPoints(e);return{top:s[1],right:s[2],bottom:s[3],left:s[0]}}}const C=squared.lib.dom;function F(t,e,s,i,a){for(const n of t)n.x+=e,n.y+=s,void 0!==n.rx&&void 0!==n.ry&&(n.rx*=i,n.ry*=a)}var G=t=>(class extends t{constructor(){super(...arguments),this._baseVal={}}setBaseValue(t,e){if(void 0!==e){if(this.verifyBaseValue(t,e))return this._baseVal[t]=e,!0}else switch(t){case"d":return this._baseVal[t]=C.getNamedItem(this.element,"d"),!0;case"points":const e=this.element[t];if(Array.isArray(e))return this._baseVal[t]=P.clonePoints(e),!0;break;default:const s=this.element[t];if(s&&s.baseVal)return this._baseVal[t]=s.baseVal.value,!0}return!1}getBaseValue(t,e){return void 0!==this._baseVal[t]||this.setBaseValue(t)?this._baseVal[t]:e}refitBaseValue(t,e,s,i=1,a=1){for(const n in this._baseVal){const r=this._baseVal[n];if("string"==typeof r){if("d"===n){const o=P.getPathCommands(r),l=P.getPathPoints(o);F(l,t,e,i,a),this._baseVal[n]=P.drawPath(P.syncPathPoints(o,l),s)}}else if("number"==typeof r)switch(n){case"cx":case"x1":case"x2":case"x":this._baseVal[n]+=t;break;case"cy":case"y1":case"y2":case"y":this._baseVal[n]+=e;break;case"r":this._baseVal[n]*=Math.min(i,a);break;case"rx":case"width":this._baseVal[n]*=i;break;case"ry":case"height":this._baseVal[n]*=a}else Array.isArray(r)&&"points"===n&&F(r,t,e,i,a)}}verifyBaseValue(t,e){switch(t){case"d":return"string"==typeof e;case"cx":case"cy":case"r":case"rx":case"ry":case"x1":case"x2":case"y1":case"y2":case"x":case"y":case"width":case"height":return"number"==typeof e;case"points":return Array.isArray(e)}}});const{css:O,dom:L,util:$}=squared.lib,B={MS:/-?\d+ms$/,S:/-?\d+s$/,MIN:/-?\d+min$/,H:/-?\d+(.\d+)?h$/,CLOCK:/^(?:(-?)(\d?\d):)?(?:(\d?\d):)?(\d?\d)\.?(\d?\d?\d)?$/};class I{constructor(t,e){if(this.element=null,this.animationElement=null,this.paused=!1,this.fillMode=0,this.synchronizeState=0,this._attributeName="",this._duration=-1,this._delay=0,this._to="",t&&(this.element=t),e){this.animationElement=e,this.setAttribute("attributeName"),this.setAttribute("to"),this.setAttribute("fill","freeze");const t=L.getNamedItem(e,"dur");""!==t&&"indefinite"!==t&&(this.duration=I.convertClockTime(t))}}static convertClockTime(t){let e=0,s=0;if($.isNumber(t))e=parseInt(t);else if(B.MS.test(t))s=parseFloat(t);else if(B.S.test(t))e=parseFloat(t);else if(B.MIN.test(t))e=60*parseFloat(t);else if(B.H.test(t))e=60*parseFloat(t)*60;else{const i=B.CLOCK.exec(t);i&&(i[2]&&(e+=60*parseInt(i[2])*60),i[3]&&(e+=60*parseInt(i[3])),i[4]&&(e+=parseInt(i[4])),i[5]&&(s=parseInt(i[5])*(i[5].length<3?Math.pow(10,3-i[5].length):1)),i[1]&&(e*=-1,s*=-1))}return 1e3*e+s}setAttribute(t,e){if(this.animationElement){const s=L.getNamedItem(this.animationElement,t);""!==s&&(void 0!==e?this[t+$.capitalize(e)]=s===e:this[t]=s)}}addState(...t){for(const e of t)$.hasBit(this.synchronizeState,e)||(this.synchronizeState|=e)}removeState(...t){for(const e of t)$.hasBit(this.synchronizeState,e)&&(this.synchronizeState^=e)}hasState(...t){return t.some(t=>$.hasBit(this.synchronizeState,t))}setFillMode(t,e){const s=$.hasBit(this.fillMode,e);t?s||(this.fillMode|=e):s&&(this.fillMode^=e)}set attributeName(t){if(!$.isString(this.baseValue)&&"transform"!==t){if(this.element)switch(t){case"opacity":case"stroke-opacity":case"fill-opacity":this.baseValue=g(this.element,t,!1)||"1";break;default:this.baseValue=g(this.element,t)}!$.isString(this.baseValue)&&this.animationElement&&(this.baseValue=$.optionalAsString(this.animationElement.parentElement,`${t}.baseVal.valueAsString`),O.isLength(this.baseValue)&&(this.baseValue=""+O.parseUnit(this.baseValue,O.getFontSize(this.animationElement.parentElement))))}this._attributeName=t}get attributeName(){return this._attributeName}set delay(t){this._delay=t}get delay(){return this._delay}set duration(t){this._duration=Math.round(t)}get duration(){return this._duration}set to(t){this._to=t}get to(){return this._to}set fillBackwards(t){this.setFillMode(t,8)}get fillBackwards(){return $.hasBit(this.fillMode,8)}set fillForwards(t){this.setFillMode(t,4)}get fillForwards(){return $.hasBit(this.fillMode,4)}set fillFreeze(t){this.setFillMode(t,2)}get fillFreeze(){return $.hasBit(this.fillMode,2)}get fillReplace(){return 0===this.fillMode||8===this.fillMode}get parentContainer(){let t=this._parent;for(;t&&!P.isContainer(t);)t=t.parent;return t}set parent(t){this._parent=t}get parent(){return this._parent}set group(t){this._group=t}get group(){return this._group||{id:-1/0,name:""}}set setterType(t){}get setterType(){return!0}get instanceType(){return 8}}const z={ease:"0.25 0.1 0.25 1","ease-in":"0.42 0 1 1","ease-in-out":"0.42 0 0.58 1","ease-out":"0 0 0.58 1",linear:"0 0 1 1","step-start":"0 1 0 1","step-end":"1 0 1 0"};var H=Object.freeze({KEYSPLINE_NAME:z});const{color:W,constant:X,css:q,dom:D,regex:U,util:Y}=squared.lib,j=t=>parseFloat((1-t).toPrecision(5));class K extends I{constructor(t,e){if(super(t,e),this.type=0,this.from="",this.additiveSum=!1,this.accumulateSum=!1,this.evaluateStart=!1,this._iterationCount=1,this._reverse=!1,this._alternate=!1,this._setterType=!1,this._repeatDuration=-1,e){const t=D.getNamedItem(e,"values"),s=-1!==this.duration?K.toFractionList(D.getNamedItem(e,"keyTimes")):[];if(""!==t)this.values=Y.trimEnd(t,";").split(/\s*;\s*/),this.length>1&&s.length===this.length?(this.from=this.values[0],this.to=this.values[this.length-1],this.keyTimes=s):1===this.length&&(this.to=this.values[0],this.convertToValues());else{if(this.from=D.getNamedItem(e,"from"),""===this.to){const t=D.getNamedItem(e,"by"),s=P.parseCoordinates(t);if(s.length){""===this.from&&(this.baseValue&&(this.from=this.baseValue),this.evaluateStart=!0);const t=P.parseCoordinates(this.from),e=t.length;if(s.length===e){const i=[];for(let a=0;a<e;a++)i.push(t[a]+s[a]);this.to=i.join(",")}}}P.parseCoordinates(this.to).length&&this.setAttribute("additive","sum"),this.convertToValues(s)}const i=D.getNamedItem(e,"repeatDur");""!==i&&"indefinite"!==i&&(this._repeatDuration=I.convertClockTime(i));const a=D.getNamedItem(e,"repeatCount");this.iterationCount="indefinite"===a?-1:parseFloat(a),"animate"===e.tagName&&this.setCalcMode()}}static getSplitValue(t,e,s){return t+(e-t)*s}static convertStepTimingFunction(t,e,s,i,a,n){let r,o;switch(t){case"fill":case"stroke":const e=W.parseColor(i[a]),s=W.parseColor(i[a+1]);e&&s&&(r=[e],o=[s]);break;case"points":r=P.convertPoints(P.parseCoordinates(i[a])),o=P.convertPoints(P.parseCoordinates(i[a+1]));break;case"rotate":case"scale":case"translate":r=Y.replaceMap(i[a].trim().split(U.CHAR.SPACE),t=>parseFloat(t)),o=Y.replaceMap(i[a+1].trim().split(U.CHAR.SPACE),t=>parseFloat(t));break;default:Y.isNumber(i[a])?r=[parseFloat(i[a])]:q.isLength(i[a])&&(r=[q.parseUnit(i[a],n)]),Y.isNumber(i[a+1])?o=[parseFloat(i[a+1])]:q.isLength(i[a+1])&&(o=[q.parseUnit(i[a+1],n)])}if(r&&o&&r.length&&r.length===o.length){switch(e){case"step-start":e="steps(1, start)";break;case"step-end":e="steps(1, end)"}const i=/steps\((\d+)(?:, (start|end))?\)/.exec(e);if(i){const e=s[a+1]-s[a],n=parseInt(i[1]),l=100/n,h=[],c=[];for(let u=0;u<=n;u++){const f=s[a]+e*(u/n),p=l*(u+(0===u&&i[2]===X.CSS.START?1:0))/100,d=[];switch(t){case"fill":case"stroke":{const t=r[0],e=o[0],s=W.getHexCode(K.getSplitValue(t.rgba.r,e.rgba.r,p),K.getSplitValue(t.rgba.g,e.rgba.g,p),K.getSplitValue(t.rgba.b,e.rgba.b,p)),i=W.getHexCode(K.getSplitValue(t.rgba.a,e.rgba.a,p));d.push(`#${s+("FF"!==i?i:"")}`);break}case"points":{const t=r.length;for(let e=0;e<t;e++){const t=r[e],s=o[e];d.push(`${K.getSplitValue(t.x,s.x,p)},${K.getSplitValue(t.y,s.y,p)}`)}break}default:{const t=r.length;for(let e=0;e<t;e++){d.push(""+K.getSplitValue(r[e],o[e],p))}break}}if(!d.length)return;h.push(f),c.push(d.join(" "))}return[h,c]}}}static toFractionList(t,e=";",s=!0){let i=0;const a=Y.replaceMap(t.split(e),t=>{const e=parseFloat(t);return isNaN(e)||s&&!(e>=i&&e<=1)?-1:(i=e,e)});return a.length>1&&(!s||0===a[0]&&a.some(t=>-1!==t))?a:[]}setCalcMode(t,e){if(this.animationElement)switch(void 0===e&&(e=D.getNamedItem(this.animationElement,"calcMode")||"linear"),e){case"discrete":if(2===this.keyTimes.length&&0===this.keyTimes[0]){let e=[],s=[];for(let i=0;i<this.keyTimes.length-1;i++){const a=K.convertStepTimingFunction(t||this.attributeName,"step-end",this.keyTimes,this.values,i,q.getFontSize(this.animationElement));a&&(e=e.concat(a[0]),s=s.concat(a[1]))}e.push(this.keyTimes.pop()),s.push(this.values.pop()),this._values=s,this._keyTimes=e,this._keySplines=[z["step-end"]]}break;case"paced":this._keySplines=void 0;break;case"spline":this.keySplines=Y.flatMap(D.getNamedItem(this.animationElement,"keySplines").split(";"),t=>t.trim());case"linear":if(0!==this.keyTimes[0]&&1!==this.keyTimes[this.keyTimes.length-1]){const t=[],e=this.values.length;for(let s=0;s<e;s++)t.push(s/(e-1));this._keyTimes=t,this._keySplines=void 0}}}convertToValues(t){this.to&&(this.values=[this.from,this.to],this.keyTimes=t&&2===t.length&&0===this.keyTimes[0]&&this.keyTimes[1]<=1?t:[0,1],""===this.from&&(this.evaluateStart=!0))}setGroupOrdering(t){if(this.group.ordering=t,this.fillBackwards)for(let e=t.length-1,s=!1;e>=0;e--)if(s){if("backwards"===t[e].fillMode||"both"===t[e].fillMode){this.fillBackwards=!1;break}}else t[e].name===this.group.name&&(s=!0)}getIntervalEndTime(t){const e=this.getTotalDuration();if(t<e){const s=this.duration;let i=this.delay;for(;i+s<=t;)i+=s;return Math.min(i+this.keyTimes[this.keyTimes.length-1]*this.duration,e)}return e}getTotalDuration(t=!1){const e=t&&-1===this.iterationCount?1:this.iterationCount;return-1!==e?Math.min(this.delay+this.duration*e,this.end||1/0):1/0}set delay(t){super.delay=t;const e=this.animationElement,s=e&&D.getNamedItem(e,X.CSS.END);if(s){const t=Y.sortNumber(Y.replaceMap(s.split(";"),t=>I.convertClockTime(t)))[0];!isNaN(t)&&(-1===this.iterationCount||this.duration>0&&t<this.duration*this.iterationCount)&&(this.delay>t?(this.end=t,-1===this.iterationCount&&(this.iterationCount=Math.ceil((this.end-this.delay)/this.duration))):this.duration=-1)}}get delay(){return super.delay}set duration(t){super.duration=t}get duration(){const t=super.duration;return-1===t&&-1!==this._repeatDuration?this._repeatDuration:t}set iterationCount(t){const e=this.animationElement;this._iterationCount=isNaN(t)?1:t,this.fillFreeze=-1!==this.iterationCount&&!!e&&"freeze"===D.getNamedItem(e,"fill"),1!==this.iterationCount?this.setAttribute("accumulate","sum"):this.accumulateSum=!1}get iterationCount(){return this.duration>0?-1!==this._repeatDuration&&(-1===this._iterationCount||this._repeatDuration<this._iterationCount*this.duration)?this._repeatDuration/this.duration:this._iterationCount:1}set to(t){super.to=t}get to(){return this._setterType?this.valueTo||super.to:this.setterType?this.values[0]:super.to}set values(t){this._values=t,t&&this._keyTimes&&this._keyTimes.length!==t.length&&(this._keyTimes=void 0,this._keySplines=void 0)}get values(){return void 0===this._values&&(this._values=[]),this._values}get valueTo(){return this._values?this._values[this._values.length-1]:""}get valueFrom(){return this.values[0]||""}set keyTimes(t){!t.every(t=>t>=0&&t<=1)||void 0!==this._values&&this._values.length!==t.length||(this._keyTimes=t)}get keyTimes(){return void 0===this._keyTimes&&(this._keyTimes=[]),this._keyTimes}set keySplines(t){if(t&&t.length){const e=this.keyTimes.length-1;if(t.length>=e&&!t.every(t=>""===t||t===z.linear)){const s=[];for(let i=0;i<e;i++){const e=Y.replaceMap(t[i].split(" "),t=>parseFloat(t));4===e.length&&!e.some(t=>isNaN(t))&&e[0]>=0&&e[0]<=1&&e[2]>=0&&e[2]<=1?s.push(e.join(" ")):s.push(z.linear)}this._keySplines=s}}else this._keySplines=void 0}get keySplines(){return this._keySplines}set timingFunction(t){this._timingFunction=t}get timingFunction(){return this._timingFunction||this.keySplines&&this.keySplines[0]}set reverse(t){if(this.length&&t!==this._reverse){this.values.reverse();const t=[];for(const e of this.keyTimes)t.push(1-e);if(t.reverse(),this.keyTimes=t,this._keySplines){const t=[];for(let e=this._keySplines.length-1;e>=0;e--){const s=Y.replaceMap(this._keySplines[e].split(" "),t=>parseFloat(t));t.push(4===s.length?`${j(s[2])} ${j(s[3])} ${j(s[0])} ${j(s[1])}`:z.linear)}this._keySplines=t}}this._reverse=t}get reverse(){return this._reverse}set alternate(t){this._alternate=t}get alternate(){return this._alternate}get playable(){return!this.paused&&this.duration>0&&this.keyTimes&&this.keyTimes.length>1}get fillReplace(){return super.fillReplace||-1===this.iterationCount}get fromToType(){return 2===this.keyTimes.length&&0===this.keyTimes[0]&&1===this.keyTimes[1]}get partialType(){return this.keyTimes.length>1&&this.keyTimes[this.keyTimes.length-1]<1}set setterType(t){this._setterType=t}get setterType(){return this._setterType||null!==this.animationElement&&0===this.duration&&this.keyTimes.length>=2&&0===this.keyTimes[0]&&""!==this.values[0]}set length(t){0===t&&(this._values=void 0)}get length(){return this._values?this._values.length:0}get instanceType(){return 16392}}const{dom:Z,util:Q}=squared.lib;class J extends K{constructor(t,e){if(super(t,e),this.attributeName="transform",e){const t=Z.getNamedItem(e,"type");this.setType(t),this.setCalcMode(t)}}static toRotateList(t){const e=[];for(const s of t)if(""===s)e.push([0,0,0]);else{const t=P.parseCoordinates(s);if(1===t.length&&(t[1]=0,t[2]=0),3!==t.length)return;e.push(t)}return e}static toScaleList(t){const e=[];for(const s of t)if(""===s)e.push([1,1,0,0]);else{const t=P.parseCoordinates(s);if(1===t.length&&(t[1]=t[0]),2===t.length&&(t[2]=0,t[3]=0),4!==t.length)return;e.push(t)}return e}static toTranslateList(t){const e=[];for(const s of t)if(""===s)e.push([0,0]);else{const t=P.parseCoordinates(s);if(1===t.length&&(t[1]=0),2!==t.length)return;e.push(t)}return e}static toSkewList(t){const e=[];for(const s of t)if(""===s)e.push([0]);else{const t=P.parseCoordinates(s);if(1!==t.length)return;e.push(t)}return e}expandToValues(){if(this.additiveSum&&-1!==this.iterationCount&&this.keyTimes.length&&this.duration>0){const t=this.duration*this.iterationCount;t:{const e=this.keyTimes,s=[],i=[],a=[];let n;const r=e.length;for(let o=0;o<this.iterationCount;o++){o>0&&this.keySplines&&a.push("");for(let l=0;l<r;l++){const h=P.parseCoordinates(this.values[l]),c=h.length;if(!c)break t;{let u;switch(this.type){case SVGTransform.SVG_TRANSFORM_TRANSLATE:1===c?u=[h[0],0]:2===c&&(u=h);break;case SVGTransform.SVG_TRANSFORM_SCALE:1===c?u=[h[0],h[0]]:2===c&&(u=h);break;case SVGTransform.SVG_TRANSFORM_ROTATE:1===c?u=[h[0],0,0]:3===c&&(u=h);break;case SVGTransform.SVG_TRANSFORM_SKEWX:case SVGTransform.SVG_TRANSFORM_SKEWY:1===c&&(u=h)}if(!u)break t;{let h=(e[l]+o)*this.duration;if(n){const t=u.length;for(let e=0;e<t;e++)u[e]+=n[e]}o<this.iterationCount-1&&l===r-1&&(this.accumulateSum&&(n=u),h--),s.push(h/t),i.push(u.join(" ")),this.keySplines&&l<r-1&&a.push(this.keySplines[l])}}}}this.values=i,this.keyTimes=s,this.keySplines=a.length?a:void 0,this.duration=t,this.iterationCount=1,this.accumulateSum=!1}}}setType(t){let e;switch(t){case"translate":this.type=SVGTransform.SVG_TRANSFORM_TRANSLATE,this.animationElement&&(e=J.toTranslateList(this.values));break;case"scale":this.type=SVGTransform.SVG_TRANSFORM_SCALE,this.animationElement&&(e=J.toScaleList(this.values));break;case"rotate":this.type=SVGTransform.SVG_TRANSFORM_ROTATE,this.animationElement&&(e=J.toRotateList(this.values));break;case"skewX":this.type=SVGTransform.SVG_TRANSFORM_SKEWX,this.animationElement&&(e=J.toSkewList(this.values));break;case"skewY":this.type=SVGTransform.SVG_TRANSFORM_SKEWY,this.animationElement&&(e=J.toSkewList(this.values));break;default:return}e&&(this.values=Q.replaceMap(e,t=>t.join(" "))),this.baseValue=p.typeAsValue(this.type)}get instanceType(){return 49160}}const tt=squared.lib.util;class et{static getGroupEndTime(t){return"infinite"===t.iterationCount?1/0:t.delay+t.duration*parseInt(t.iterationCount)}static getKeyName(t){return t.attributeName+(P.isAnimateTransform(t)?`:${p.typeAsName(t.type)}`:"")}constructor(t,...e){t=(e.length?tt.filterArray(t,t=>e.includes(t.attributeName)):t.slice(0)).sort((t,e)=>t.delay===e.delay?t.group.id<e.group.id?1:-1:t.delay<e.delay?-1:1),e.length=0;for(const s of t){const t=et.getKeyName(s);e.includes(t)||e.push(t)}this.map={};const s={},i={};function a(t,e,a,n=0,r,o=!1,l=!1,h=0,c=!1,u){a&&(void 0===s[t][e]&&(s[t][e]=[]),s[t][e].push({time:e,value:a,animation:r,start:o,end:l,endTime:n,fillMode:h,infinite:c,valueFrom:u}),i[t].add(e))}for(const r of e){this.map[r]=new Map,s[r]={},i[r]=new Set;const e=-1!==(n=r).indexOf(":")?n.split(":")[0]:n,o=t.filter(t=>t.fillBackwards&&t.attributeName===e).sort((t,e)=>t.group.id<e.group.id?1:-1)[0];o&&a(r,0,o.values[0],o.delay,o,0===o.delay,!1,8)}var n;for(const e of t){const t=et.getKeyName(e);if(void 0===s[t][-1]&&e.baseValue&&a(t,-1,e.baseValue),e.setterType){const s=e.fillReplace&&e.duration>0;a(t,e.delay,e.to,s?e.delay+e.duration:0,e,s,!s,2),s&&a(t,e.delay+e.duration,"",0,e,!1,!0,2)}else if(P.isAnimate(e)&&e.duration>0){const s=-1===e.iterationCount,i=e.getTotalDuration();a(t,e.delay,e.valueTo,i,e,!0,!1,0,s,e.valueFrom),s||e.fillReplace||a(t,i,e.valueTo,0,e,!1,!0,e.fillForwards?4:2)}}for(const t in s)for(const e of tt.sortNumber(Array.from(i[t]))){const i=s[t][e];for(let e=0;e<i.length;e++){const s=i[e];if(""===s.value||s.start&&s.animation&&P.isAnimate(s.animation)&&s.animation.evaluateStart){let a;for(const e of this.map[t].values())for(const t of e)if(s.animation!==t.animation&&""!==t.value&&(-1===t.time||4===t.fillMode||2===t.fillMode)){a=t.value;break}a?s.value=a:""===s.value&&i.splice(e--,1)}}i.length&&(i.sort((t,e)=>t.animation&&e.animation?t.fillMode===e.fillMode?t.animation.group.id<e.animation.group.id?1:-1:t.fillMode<e.fillMode?1:-1:0),this.map[t].set(e,i))}for(const t in this.map)for(const[e,s]of this.map[t].entries())for(const i of s)if(i.animation)if(2===i.fillMode){const s=[];for(const[a,n]of this.map[t].entries())if(a<e)for(const t of n)t.start&&t.animation&&t.animation.animationElement&&s.push(t.animation);else if(a>e)for(let t=0;t<n.length;t++){const e=n[t];e.end&&s.includes(e.animation)&&n.splice(t--,1)}else for(let t=0;t<n.length;t++){const e=n[t];e.end&&e.animation&&e.animation.animationElement&&e.animation.group.id<i.animation.group.id&&n.splice(t--,1)}}else if(4===i.fillMode||i.infinite){let s=!1;if(i.animation.group.ordering){const t=i.animation.getTotalDuration();for(const e of i.animation.group.ordering)if(e.name===i.animation.group.name)s=!0;else if(et.getGroupEndTime(e)>=t)break}const a=[];for(const[n,r]of this.map[t].entries())if(!s&&n<e)for(const t of r)t.start&&t.animation&&a.push(t.animation);else if(n>e)for(let t=0;t<r.length;t++){const e=r[t];(s||e.animation&&(e.end&&a.includes(e.animation)||null===i.animation.animationElement&&e.animation.group.id<i.animation.group.id))&&r.splice(t--,1)}else for(let t=0;t<r.length;t++){const e=r[t];e.end&&e.animation&&e.animation.group.id<i.animation.group.id&&r.splice(t--,1)}}for(const t in this.map)for(const[e,s]of Array.from(this.map[t].entries()))0===s.length&&this.map[t].delete(e)}has(t,e,s){return void 0!==e?!(!this.map[t]||!this.map[t].has(e))&&(void 0===s||-1!==this.map[t].get(e).findIndex(t=>t.animation===s)):void 0!==this.map[t]}get(t,e,s=!1){let i;if(this.map[t])for(const[a,n]of this.map[t].entries()){if(!(a<=e))break;for(const t of n)if(""!==t.value&&(-1===t.time||t.end&&(4===t.fillMode||2===t.fillMode))||s&&t.start&&e!==a){i=t.value;break}}return i}paused(t,e){let s=0;if(this.map[t])for(const[i,a]of this.map[t].entries()){if(!(i<=e))break;for(const t of a)if(t.start&&(t.infinite||0===t.fillMode&&t.endTime>e)){if(!t.animation){s=1;break}s=2}else if(t.end&&(4===t.fillMode||1===s&&2===t.fillMode)){s=0;break}}return 0===s}evaluateStart(t,e){if(t.evaluateStart){const s=this.get(t.attributeName,t.delay)||e&&""+e||t.baseValue;s&&(t.reverse?t.values[t.values.length-1]=s:t.values[0]=s),t.evaluateStart=!1}return t.values}}const{constant:st,math:it,regex:at,util:nt}=squared.lib,rt=["x1","y1","x2","y2"],ot=[st.CSS.WIDTH,st.CSS.HEIGHT,"x","y"],lt=["points"],ht=["cx","cy","r"],ct=["cx","cy","rx","ry"];function ut(t,e,s,i,a){let n,r,o,l=0;for(const[e,i]of t.entries()){if(s===e){r={key:e,value:i};break}if(s>l&&s<e&&void 0!==n){r={key:l,value:n},o={key:e,value:i};break}l=e,n=i}if(r&&o)Rt(t,s,Tt(s,r.key,r.value,o.key,o.value),!0);else if(r)Rt(t,s,r.value,!0);else if(!a){let a=i.get(e,s,!0);a&&""!==(a=pt(a,!0))&&Rt(t,s,a)}}function ft(t){const e=new Set,s=t.length,i=t[s-1][0];for(let a=0;a<s;a++){let s=t[a][0]/i;if(s>0)for(let t=7;;t++){const i=parseFloat((""+s).substring(0,t));if(!e.has(i)){s=i;break}}t[a][0]=s,e.add(s)}return t}function pt(t,e=!1){return"string"==typeof t&&(nt.isNumber(t)?t=parseFloat(t):0===(t=P.parsePoints(t)).length&&(t="")),e&&"string"==typeof t?"":t}function dt(t,e){let s;if(t)for(const i of t){if(!(i.time<=e))break;s=i.value}return s}function mt(t,e,s,i,a){const n=[],r=e.element.tagName;let o;switch(r){case"line":o=rt;break;case"rect":o=ot;break;case"polyline":case"polygon":o=lt;break;case"circle":o=ht;break;case"ellipse":o=ct;break;default:return}const l=p.origin(e.element),h=t.length;for(let c=0;c<h;c++){const h=t[c][0],u=t[c][1],f=[];for(const t of o){let s=u.get(t);if(void 0===s&&(void 0===s&&(s=dt(i[t],h)),void 0===s&&(s=e.getBaseValue(t))),void 0===s)return;f.push(s)}let p;switch(r){case"line":p=gt(f);break;case"rect":p=yt(f);break;case"polygon":case"polyline":p=f[0];break;case"circle":case"ellipse":p=wt(f)}if(p){let t;switch(e.transformed&&(p=P.applyTransforms(e.transformed,p,l)),s&&s.refitPoints(p),r){case"line":case"polyline":t=P.drawPolyline(p,a);break;case"rect":case"polygon":t=P.drawPolygon(p,a);break;case"circle":case"ellipse":const i=p[0];t=P.drawEllipse(i.x,i.y,i.rx,i.ry,a)}void 0!==t&&n.push({key:h,value:t})}}return n}function gt(t){return[{x:t[0],y:t[1]},{x:t[2],y:t[4]}]}function yt(t){const e=t[0],s=t[1],i=t[2],a=t[3];return[{x:i,y:a},{x:i+e,y:a},{x:i+e,y:a+s},{x:i,y:a+s}]}function vt(t,e,s){const i=new Map;for(const a of e){const e=new Map;for(const i in t){let n;void 0!==(n=t[i].has(a)?t[i].get(a):dt(s[i],a))&&e.set(i,n)}i.set(a,e)}return i}function St(t,e,s,i){e&&(t.set(s,e),void 0!==i&&t.set(i,e))}function bt(t,e,s,i,a){switch(t.alternate&&s%2!=0&&(e=e.slice(0).reverse()),t.attributeName){case"transform":if(t.additiveSum&&"string"==typeof a){const n=nt.replaceMap(a.split(at.CHAR.SPACE),t=>parseFloat(t)),r=nt.objectMap(e,t=>nt.replaceMap(t.trim().split(at.CHAR.SPACE),t=>parseFloat(t))),o=n.length;if(r.every(t=>t.length===o)){const e=r[i];t.accumulateSum||(s=0);for(let t=0;t<o;t++)e[t]+=n[t];const a=r.length;for(let t=0;t<s;t++)for(let t=0;t<a;t++){const s=r[t],i=s.length;for(let t=0;t<i;t++)e[t]+=s[t]}return e.join(" ")}}return e[i];case"points":return P.parsePoints(e[i]);default:{let n=parseFloat(e[i]);if(isNaN(n))return a||0;if(t.additiveSum&&"number"==typeof a){n+=a,t.accumulateSum||(s=0);const i=e.length;for(let t=0;t<s;t++)for(let t=0;t<i;t++)n+=parseFloat(e[t])}return n}}}function Tt(t,e,s,i,a){if(t>e){if("number"==typeof s&&"number"==typeof a)return K.getSplitValue(s,a,(t-e)/(i-e));if("string"==typeof s&&"string"==typeof a){const n=nt.replaceMap(s.split(" "),t=>parseFloat(t)),r=nt.replaceMap(a.split(" "),t=>parseFloat(t)),o=n.length;if(o===r.length){const s=[];for(let a=0;a<o;a++)s.push(Tt(t,e,n[a],i,r[a]));return s.join(" ")}}else if(Array.isArray(s)&&Array.isArray(a)){const n=[];for(let r=0;r<Math.min(s.length,a.length);r++)n.push({x:Tt(t,e,s[r].x,i,a[r].x),y:Tt(t,e,s[r].y,i,a[r].y)});return n}}return s}function kt(t,e,s,i,a,n,r,o,l,h,c,u,f,p){r<0&&(e-=r,r=0);const d=t.duration,m=e-(r+d*o);let g;g=0===m?0===l?0:1:it.clampRange(m/d);let y=-1,v=-1;const S=i.length;for(let t=0;t<S;t++){if(-1!==y&&g<=i[t]){v=t;break}g>=i[t]&&(y=t)}let b;return At(t,h=Rt(u,h,b=-1!==y&&-1!==v?Tt(g,i[y],bt(t,a,o,y,s),i[v],bt(t,a,o,v,s)):bt(t,a,o,v=-1!==y?y+1:i.length-1,s)),n,v,c,f,p),[h,b]}function xt(t,e,s,i,a,n,r){const o=e.keyTimes.slice(0),l=e.keySplines?e.keySplines.slice(0):Array(a.length-1).fill(""),h=s+e.duration;let c=e.getIntervalEndTime(s);for(let s=0;s<r.length;s++){const f=r[s];if(f!==e){const p=f.getTotalDuration();if(p>c){const d=Math.min(h,p),m=_t(t,e,n);t:for(let t=Gt(c,f.delay,f.duration),s=!1;;t++){const i=f.keyTimes,r=i.length;for(let h=0;h<r;h++){const p=Vt(f.delay,f.duration,i,t,h);if(p>=c){function u(u){let g;if(p===u)g=Nt(bt(f,m,t,h,n));else{const e=(p-u)/f.duration;for(let s=1;s<r;s++)if(e>=i[s-1]&&e<=i[s]){g=Nt(Tt(e,i[s-1],bt(f,m,t,s-1,n),i[s],bt(f,m,t,s,n)));break}}let y=u===d?1:u%e.duration/e.duration;0===y&&h>0&&(y=1),void 0===g||y===o[o.length-1]&&g===a[a.length-1]||(u===c?y+=.001:c=u,o.push(y),a.push(g),l&&l.push(s&&f.keySplines&&f.keySplines[h]?f.keySplines[h]:""))}if(!s&&p>=c&&(u(c),s=!0,p===c))continue;if(s){if(u(Math.min(p,d)),p>=d||1===o[o.length-1])break t;c=p}}}}if(p===d&&p<=i&&(f.addState(16),r.splice(s--,1)),d===h)break}else i!==1/0&&p<i&&r.splice(s--,1)}}return[o,a,l]}function Rt(t,e,s,i=!1){if(""!==s){let a=t.get(e),n=!1;if(void 0===a&&(a=t.get(e-1),n=!0),a!==s||i){if(!i){if("number"==typeof a&&it.isEqual(s,a))return e;for(;e>0&&t.has(e);)e++}t.set(e,s)}else n&&!t.has(e)&&(t.delete(e-1),t.set(e,s))}return e}function At(t,e,s,i,a,n,r){if(!Mt(P.isAnimateTransform(t),a)){if(0===i)return;i--}const o=s&&s[i];o&&n.set(e,o),r&&function(t,e,s,i){P.asAnimateTransform(e)&&e.transformOrigin&&e.transformOrigin[i]&&t.set(s,e.transformOrigin[i])}(r,t,e,i)}function _t(t,e,s){if(e.evaluateStart){const i=e.reverse?e.length-1:0;t.get(et.getKeyName(e),e.delay)||e.values[i]||!e.additiveSum&&e.baseValue||(e.values[i]=Nt(s)),e.by&&nt.isNumber(e.values[i])&&(e.values[i]=""+(parseFloat(e.values[i])+e.by)),e.evaluateStart=!1}return e.values}function Et(t,e,s,i){t[t.length-1]<1&&(t.push(1),e.push(void 0!==i?Nt(i):e[0]),s&&s.push(""))}const Vt=(t,e,s,i,a)=>Math.round(t+(s[a]+i)*e),wt=t=>[{x:t[0],y:t[1],rx:t[2],ry:t[t.length-1]}],Nt=t=>Array.isArray(t)?nt.objectMap(t,t=>`${t.x},${t.y}`).join(" "):""+t,Mt=(t,e)=>nt.hasBit(e,t?32:4),Pt=(t,e)=>nt.hasBit(e,t?16:2),Ct=t=>t.playable||t.animationElement&&-1!==t.duration,Ft=t=>[t.keyTimes.slice(0),t.values.slice(0),t.keySplines?t.keySplines.slice(0):void 0],Gt=(t,e,s)=>Math.floor(Math.max(0,t-e)/s);var Ot=t=>(class extends t{getAnimateShape(t){const e=[];for(const s of this.animations)if(Ct(s))switch(s.attributeName){case"r":case"cx":case"cy":if(d.circle(t)){e.push(s);break}case"rx":case"ry":d.ellipse(t)&&e.push(s);break;case"x1":case"x2":case"y1":case"y2":d.line(t)&&e.push(s);break;case"points":(d.polyline(t)||d.polygon(t))&&e.push(s);break;case"x":case"y":case"width":case"height":d.rect(t)&&e.push(s)}return e}getAnimateTransform(t){const e=[];for(const s of this.animations)P.isAnimateTransform(s)&&s.duration>0&&(e.push(s),t&&P.asAnimateMotion(s)&&(s.framesPerSecond=t.framesPerSecond));return e}getAnimateViewRect(t){void 0===t&&(t=this.animations);const e=[];for(const s of t)if(Ct(s))switch(s.attributeName){case"x":case"y":e.push(s)}return e}animateSequentially(t,e,s,i){let a,n=18;i&&(i.keyTimeMode&&(n=i.keyTimeMode),a=i.precision),[t,e].forEach(t=>{const i=t===e;if(!t||0===t.length||!i&&nt.hasBit(n,8)||i&&nt.hasBit(n,64))return;const r=[],o={},l=new Set;let h=0;function c(t){void 0===o[t.attributeName]&&(o[t.attributeName]=[]),o[t.attributeName].push(t),h++}{const e=[],s=t.length;for(let i=0;i<s;i++){const a=t[i];if(a.setterType)c(a);else{const n=a.getTotalDuration();for(let r=0;r<s;r++){const s=t[r];if(i!==r&&a.attributeName===s.attributeName&&a.group.id<s.group.id&&a.fillReplace&&!s.partialType)if(s.setterType){if(a.delay===s.delay){e[i]=a;break}}else{const t=s.getTotalDuration();if(a.delay===s.delay&&(!s.fillReplace||n<=t||-1===s.iterationCount)||s.fillBackwards&&a.delay<=s.delay&&(s.fillForwards||a.fillReplace&&n<=s.delay)||a.animationElement&&null===s.animationElement&&(a.delay>=s.delay&&n<=t||s.fillForwards)){e[i]=a;break}}}}}const i=[];for(let a=0;a<s;a++){const s=t[a];e[a]?s.fillReplace?i.push(s):(s.setterType=!0,c(s)):s.setterType||(r.push(s),l.add(s.group.name))}this._removeAnimations(i)}if(r.length+h>1||1===r.length&&(r[0].alternate||void 0!==r[0].end)){for(const t of r)t.group.ordering&&nt.spliceArray(t.group.ordering,t=>!l.has(t.name));const e={},h={};let c=0;for(const t of r){const s=t.attributeName;void 0===e[s]&&(e[s]=new Map,h[s]=[]);const i=e[s].get(t.delay)||[];i.push(t),h[s].push(t),e[s].set(t.delay,i)}for(const t in e){const s=new Map;for(const i of nt.sortNumber(Array.from(e[t].keys()))){const a=e[t].get(i);for(const t of a)c=Math.max(c,t.getTotalDuration(!0));a.reverse(),s.set(i,a)}e[t]=s,h[t].reverse()}const A=new et(t),_={},E=new Map,V=i?new Map:void 0,w={},N=new Set,M={},C=new Map,F=i?new Map:void 0,G={},O={},L=new Map;let $,B,I=-1;const z=t=>O[t]&&O[t][O[t].length-1];for(const t in e){if(_[t]=new Map,!i){let e;try{e=(s||this).getBaseValue(t)}catch(t){}nt.hasValue(e)&&(G[t]=e)}const a=o[t]||[],r=[],l=[];for(const[s,i]of e[t].entries())r.push(s),l.push(i);const C=[];let F,$,B,I=-1,H=0,W=1/0;function u(e,s){if(N.add(e),e.addState(16),B=e,e.fillForwards){if(b(H,F,e.type,e),e.group.ordering){const t=e.getTotalDuration();for(const s of e.group.ordering){if(s.name===e.group.name)return!0;if(et.getGroupEndTime(s)>=t)return!1}}}else{if(e.fillFreeze&&b(H,F,e.type,e),void 0!==s){let a=I;const n=m(H,H+1);void 0!==n&&e.fillReplace&&s>H&&0===C.length&&(a=Rt(_[t],a,n),i&&St(L,e.type,a),F=n,I=a)}g()}return!1}function f(e,s,a){return void 0===s&&(s=e.delay),void 0===a&&(a=e.to),Rt(_[t],s,i?a:pt(a))}function d(t){t&&a.push(t),a.sort((t,e)=>t.delay===e.delay?t.group.id<e.group.id?-1:1:t.delay<e.delay?-1:1);for(let t=0;t<a.length-1;t++)a[t].delay===a[t+1].delay&&a.splice(t--,1)}function m(e,s){const n=z(t);let r=n&&n.value;return nt.spliceArray(a,t=>t.delay>=e&&t.delay<s,t=>{t.animationElement&&S(),0===C.length&&(F=t.to),b(t.delay,t.to,t.type,t),t.delay===e?r=i?t.to:pt(t.to):(I=f(t),H=t.delay)}),r}function g(t,e){C.length&&nt.spliceArray(C,t=>t.getTotalDuration()<=H,s=>{if(s.addState(16),s.fillForwards&&(b(s.getTotalDuration(),s.valueTo,s.type,s),void 0!==t&&void 0!==e)){const i=r.length;for(let a=t;a<i;a++){a!==t&&(e=-1);const i=l[a],n=i.length;for(let t=e+1;t<n;t++){const e=i[t];s.group.id>e.group.id&&e.addState(16)}}}})}function y(t){if(!t.hasState(16,64)){t.addState(4);const e=C.indexOf(t);-1!==e&&C.splice(e,1),C.push(t)}}function v(){C.sort((t,e)=>t.animationElement&&e.animationElement&&t.delay!==e.delay?t.delay<e.delay?1:-1:t.group.id<e.group.id?1:-1)}function S(t){t?-1!==t.iterationCount&&nt.spliceArray(C,e=>e===t):nt.spliceArray(C,t=>null!==t.animationElement)}function b(e,s,n=0,r){i||(s=pt(s));const o=z(t);if(""!==s&&(void 0===o||e>=o.time)&&(void 0===O[t]&&(O[t]=[]),O[t].push({key:n,value:s,time:e})),r&&P.isAnimate(r)&&!r.fillReplace)if(r.fillForwards){nt.spliceArray(a,t=>t.group.id<r.group.id||t.delay<e),C.length=0;for(const t of l)for(const e of t)e.group.id<r.group.id&&e.addState(16)}else r.fillFreeze&&S()}function T(e,s,i){$&&!e&&(void 0===i&&(i=p.typeAsValue($.type)),s!==(I=Rt(_[t],s,i))&&St(L,$.type,I)),$=void 0}function k(t){for(let e=0;e<r.length;e++){if(t.length)for(let s=0;s<l[e].length;s++)t.includes(l[e][s])&&l[e].splice(s--,1);0===l[e].length&&(l.splice(e,1),r.splice(e--,1))}}const X=h[t].find(t=>t.fillBackwards);if(X){F=bt(X,X.values,0,0),I=Rt(_[t],0,F),i&&(St(L,X.type,0),$=X);let e=!0;for(const s of h[t])if(s.group.id>X.group.id&&s.delay<=X.delay){e=!1;break}const s=X.getTotalDuration(),n=[];for(let t=0;t<r.length;t++)for(let i=0;i<l[t].length;i++){const o=l[t][i];if(e){if(o===X&&(0!==t||0!==i)){l[t].splice(i--,1),r.unshift(X.delay),l.unshift([X]);continue}if(o.group.id<X.group.id&&(X.fillForwards||o.getTotalDuration()<=s)){o.fillForwards&&(o.setterType=!0,a.push(o)),n.push(o);continue}}o.animationElement&&o.delay<=X.delay&&(l[t].splice(i--,1),y(o))}k(n),X.addState(2)}if(!i&&(void 0===O[t]&&void 0!==G[t]&&b(0,G[t],0),void 0===F)){const e=z(t);F=e&&e.value||G[t]}d();{let e;nt.spliceArray(a,t=>t.delay<=r[0],s=>{const a=P.isAnimate(s)&&s.fillForwards;if(s.delay<r[0]&&(void 0===X||a))if(X&&a)b(s.delay,s.to,s.type);else{const a=s.delay-1;if(void 0===e)if(_[t].has(0))i||f(s,a,F);else{let e;void 0!==(e=i&&P.isAnimateTransform(s)?p.typeAsValue(s.type):G[t])&&(f(s,0,e),f(s,a,e))}else f(e,a);I=f(s),H=s.delay,e=s}}),e&&f(e,r[0]-1)}t:{const e=r.length;for(let s=0;s<e;s++){const o=l[s];let h=r[s];for(let k=0;k<o.length;k++){const R=o[k];if(R.hasState(16,64))continue;const w=-1===R.iterationCount,N=R.duration,P=R.iterationCount;let O,B,X;if(w)O=h+N;else if((O=R.getTotalDuration())<=I){R.fillReplace?R.addState(64):y(R);continue}w?(B=Math.ceil((c-h)/N),X=0):(B=Math.ceil(P),X=P-Math.floor(P)),a.length&&H>0&&H<h&&m(H,h),-1!==I&&I<h&&(I=Rt(_[t],h-1,F),H=h),W=1/0;const q=R.group.ordering;if(q&&q.length>1){let i=!0;for(const e of q){if(e.name===R.group.name){i=!1;break}if(!e.paused&&H<=e.delay&&e.attributes.includes(t))break}if(i)e:for(let t=s+1;t<e;t++){const e=l[t],s=e.length;for(let t=0;t<s;t++){const s=e[t];if(s.group.ordering){W=s.delay;break e}s.getTotalDuration()<=O?(s.fillFreeze&&d(s),s.addState(16)):s.delay<O&&y(s)}}}else for(let t=s+1;t<e;t++)if(r[t]!==1/0&&l[t].length&&!l[t].every(t=>t.hasState(16,64))){W=r[t];break}const D=H;let U,Y=I+1,j=Math.min(W,R.end||1/0);if(a.length&&R.animationElement){const t=Math.min(W,O,j);if(U=a.find(e=>e.delay>=H&&e.delay<=t)){switch(U.delay){case H:b(H,F=U.to,U.type,U),U.group.id>R.group.id&&(i&&$&&T(R.additiveSum,Math.max(h-1,I)),I=f(U,Math.max(U.delay,I),F),j=-1);break;case W:U.addState(32);break;default:j=U.delay,U.addState(32)}nt.spliceArray(a,t=>t!==U),R.addState(4)}}let K,Z=!1;if(j>I){i&&($&&(T(R.additiveSum,Math.max(h-1,I)),Y=I+1),F=p.typeAsValue(R.type),b(H,F,R.type));let e=h===1/0||(-1!==I||R.hasState(2))&&!(0===s&&0===k);Z=!0;e:{const i=z(t);for(let a=Gt(H,h,N);a<B;a++){let r,c,u=_t(A,R,F);if(R.partialType){if(R.getIntervalEndTime(H)<j&&(C.length||k<l[s].length-1)){for(let t=k+1;t<o.length;t++)y(o[t]);o.length=0,v(),[r,u,c]=xt(A,R,H,j,u,F,C)}else[r,u,c]=Ft(R);Et(r,u,c,G[t])}else r=R.keyTimes,c=R.keySplines;const f=r.length;for(let s=0;s<f;s++){const o=r[s];let l=-1,p=bt(R,u,a,s,F);if(a===B-1&&X>0)if(X===o)X=-1;else if(s===f-1)H=l=O,p=Tt(X,r[s-1],bt(R,u,a,s-1,F),o,p),X=-1;else if(X>o)for(let t=s+1;t<f;t++)if(X<=r[t]){H=l=O,p=Tt(X,o,p,r[t],bt(R,u,a,t,F)),X=-1;break}if(-1===l){if((l=Vt(h,N,r,a,s))<0||l<I)continue;if(l===j)Z=a===B-1&&s===f-1,H=l;else{function x(e){[I,K]=kt(R,H,F,r,u,c,h,a,s,e,n,_[t],E,V)}if(h<0&&-1===I)l>0&&(H=0,x(0));else{if(l>j){e&&I+1<j&&x(I),H=j,x(j+(j!==W||_[t].has(j-1)?0:-1)),Z=!1;break e}if(e)R.hasState(2)&&(H=D),h>=I?(l=Math.max(h,I+1),H=h):l===I?(H=l,l=I+1):(x(I),H=Math.max(l,I)),e=!1;else{if(H=l,a>0&&0===s&&R.accumulateSum){At(R,l,c,s,n,E,V),I=l;continue}l=Math.max(l,I+1)}}}}if(l>I&&(s===length-1&&!R.accumulateSum&&(a<B-1||R.fillReplace&&(void 0===i||p!==i.value))&&l--,I=Rt(_[t],l,p),At(R,I,c,s,n,E,V),K=p),!Z||-1===X)break e}}}g(s,k)}if(void 0!==K&&(F=K,i&&(St(L,R.type,Y,I),$=R)),U&&(U.hasState(32)?(I=f(U,U.delay,K=U.to),b(H=U.delay,K,U.type,U)):R.hasState(64)&&St(L,I,U.type),S(),Z=!0),nt.spliceArray(a,t=>t.delay>=D&&t.delay<=H,t=>{b(t.delay,t.to,t.type,t),t.animationElement&&S()}),w){if(!Z){C.length=0,C.push(R);continue}if(void 0===U){M[t]=R;break t}}if(Z){if(!w&&u(R,W))break t;for(let t=s;t<e;t++)if(r[t]<H){const e=l[t];for(let t=0;t<e.length;t++){const s=e[t],i=s.getTotalDuration();i>H&&!s.hasState(4,16,64)?y(s):s.fillReplace||b(i,s.valueTo,s.type,s)}r[t]=1/0,e.length=0}if(C.length&&H<W){v();const t=C.find(t=>t.delay<=H);t&&(t.removeState(4,2),t.addState(8),S(t),h=t.delay,l[s]=[t],k=-1)}}else y(R)}}if(C.length)for(v();C.length;){const e=C.shift(),s=e.delay,a=e.duration,r=I-s;let o=1/0;function R(){let l,h,c=_t(A,e,F);e.partialType?(e.getIntervalEndTime(H)<o&&C.length?[l,c,h]=xt(A,e,H,o,c,F,C):[l,c,h]=Ft(e),Et(l,c,h,G[t])):(l=e.keyTimes,h=e.keySplines);const u=I+1;let f=Math.floor(r/a),p=!1;const d=(i,a)=>kt(e,H,F,l,c,h,s,f,a,i,n,_[t],E,V);do{const i=l.length;for(let r=0;r<i;r++){let i=Vt(s,a,l,f,r);if(!p&&i>=I&&([I,F]=d(I,r),p=!0),p)if(i>=o){if(o>I){const s=e.fillReplace||-1===e.iterationCount;[I,F]=d(o-(s?1:0),r),s&&(F=bt(e,c,f,0,F),I=Rt(_[t],o,F)),H=o}}else i>I&&(H=i,r===l.length-1&&i<o&&i--,F=bt(e,c,f,r,F),I=Rt(_[t],i,F),At(e,I,h,r,n,E,V))}}while(I<o&&++f);i&&St(L,e.type,u,I)}if(-1===e.iterationCount){r>0&&r%e.duration!=0&&(o=s+e.duration*Math.ceil(r/a),R()),M[t]=e;break t}if((o=Math.min(s+e.duration*e.iterationCount,e.end||1/0))>I&&(R(),u(e)))break t}if(B&&B.fillReplace&&void 0===M[t]){let e,s=0;if(O[t]){const i=z(t);i&&(s=i.key,e=i.value)}else i?(s=Array.from(L.values()).pop(),e=p.typeAsValue(s)):e=G[t];void 0===e||nt.isEqual(_[t].get(I),e)||(I=Rt(_[t],I,e),i&&St(L,s,I))}}w[t]=I}{const t=new Set;let e=0;for(const s in _){let i=0;for(const e of _[s].keys())t.add(e),i=e;e=Math.max(e,i),O[s]&&O[s].sort((t,e)=>t.time===e.time?0:t.time<e.time?-1:1)}if(Object.keys(M).length){const s=[],i=[];for(const t in M)s.push(M[t].delay),i.push(M[t].duration);0===N.size&&1===new Set(s).size&&1===new Set(i).size&&s[0]===t.values().next().value?I=s[0]<=0?0:s[0]:i.length>1&&i.every(t=>t%250==0)?e=it.nextMultiple(i,e,s):(e-s[0])%i[0]!=0&&(e=i[0]*Math.ceil(e/i[0]))}if(-1===I)for(const s in _)if(M[s]){let a=w[s];if(a<e){const r=M[s],o=r.delay,l=a+1;let h=Array.from(_[s].values()).pop(),c=Math.floor((a-o)/r.duration);const u=_t(A,r,h),f=r.keyTimes,p=f.length;do{let i=!1;for(let l=0;l<p;l++){let d=Vt(o,r.duration,f,c,l);!i&&d>=a&&(_[s].has(a)||([a,h]=kt(r,a,h,f,u,r.keySplines,o,c,l,a,n,_[s],E,V),t.add(a)),i=!0),i&&d>a&&(l===p-1&&d<e&&d--,h=bt(r,u,c,l,h),a=Rt(_[s],d,h),At(r,d,r.keySplines,l,n,E,V),t.add(a))}}while(a<e&&++c);w[s]=a,i&&St(L,r.type,l,a)}}const a=nt.sortNumber(Array.from(t));if(s||i){let t=!1;for(const e in _)if(!_[e].has(0)&&void 0!==G[e]){const s=_[e].keys().next().value-1;_[e].set(0,G[e]),_[e].set(s,G[e]),a.includes(0)||(a.push(0),t=!0),a.includes(s)||(a.push(s),t=!0)}t&&nt.sortNumber(a)}if(!i)for(const t in _)for(const e of a){if(!(e<=w[t]))break;if(!_[t].has(e)){if(A.paused(t,e)){let s=A.get(t,e);if(s&&""!==(s=pt(s,!0))){_[t].set(e,s);continue}}ut(_[t],t,e,A,i)}}$=vt(_,a,O)}if(-1===I&&Object.keys(M).length){const t={},e=[],s=[],a=[];for(const t in M)a.push(M[t].duration),e.push(M[t]);const r=it.nextMultiple(a);for(const i of e){const e=i.attributeName;t[e]=new Map;let a=_[e].has(w[e])?_[e].get(w[e]):G[e];const o=_t(A,i,a);let l=0,h=0;const c=i.keyTimes,u=c.length;do{for(let f=0;f<u;f++){let u=Vt(0,i.duration,c,h,f);f===c.length-1&&u<r&&u--,a=bt(i,o,h,f,a),At(i,l=Rt(t[e],u,a),i.keySplines,f,n,C,F),s.includes(l)||s.push(l)}}while(l<r&&++h)}if(e.every(t=>t.alternate)){let e=-1;for(const i in M){const a=Array.from(t[i].keys()),n=Array.from(t[i].values()).reverse(),o=a.length;for(let l=0;l<o;l++)if(0!==a[l]){e=r+a[l];const o=C.get(a[l]);o&&C.set(e,o),e=Rt(t[i],e,n[l]),s.includes(e)||s.push(e)}}}nt.sortNumber(s);for(const e in t)for(const a of s)t[e].has(a)||ut(t[e],e,a,A,i);B=vt(t,s,O)}if($||B){this._removeAnimations(r);const t=Array.from(L.entries()),e=nt.joinMap(r,t=>P.isAnimateTransform(t)?p.typeAsName(t.type):t.attributeName,"-");for(const r of[$,B])if(r){const o=r===$,l=o?E:C,h=o?V:F;if(Mt(i,n)){const e=[];if(i){const s=[];if(o){const e=Array.from(r.entries());let i=t[0][1];const a=t.length,n=e.length;for(let r=0,o=0,l=0;r<a;r++){const h=r<a-1?t[r+1][1]:-1;if(i!==h){const a=new Map;for(let s=l;s<n;s++){const n=e[s][0];if(n>=t[o][0]&&n<=t[r][0])a.set(n,new Map([[i,e[s][1].values().next().value]])),l=s;else if(n>t[r][0])break}s.push(a),i=h,o=r+1}}}else{if(!M.transform)return;{const t=Array.from(r.entries()),e=new Map;for(const s of t)e.set(s[0],new Map([[M.transform.type,s[1].values().next().value]]));s.push(e)}}let i=0;const a=s.length;for(let t=0;t<a;t++){const n=Array.from(s[t].entries());let r=n[0][0];1===n.length&&n.push(t<a-1?[s[t+1].keys().next().value,n[0][1]]:[r+1,n[0][1]]);const c=n[n.length-1][0];let u=c-r;const f=new J;f.type=n[0][1].keys().next().value;const p=n.length;for(let t=0;t<p;t++){const s=n[t];if(e.push(l.get(s[0])||""),f.type!==SVGTransform.SVG_TRANSFORM_ROTATE){const e=h.get(s[0]);e&&(void 0===f.transformOrigin&&(f.transformOrigin=[]),f.transformOrigin[t]=e)}s[0]-=r}for(const[t,e]of ft(n))f.keyTimes.push(t),f.values.push(e.values().next().value);(r-=i)>1?f.delay=r:1===r&&(u+1)%10==0&&u++,f.duration=u,f.keySplines=e,f.synchronized={key:t,value:""},i=c,this._insertAnimate(f,o)}}else{const t=Array.from(r.entries()),i=-1!==I?I:0;let n;for(const s of t)e.push(l.get(s[0])||""),s[0]-=i;if(s){const e=mt(ft(t),s,this.parent,O,a);if(!e)return;(n=new K).attributeName="d";for(const t of e)n.keyTimes.push(t.key),n.values.push(""+t.value)}else{const t=new J;t.type=SVGTransform.SVG_TRANSFORM_TRANSLATE;for(const[e,s]of r.entries()){const i=s.get("x")||0,a=s.get("y")||0;t.keyTimes.push(e),t.values.push(this.parent?`${this.parent.refitX(i)} ${this.parent.refitX(a)}`:`${i} ${a}`)}n=t}n.delay=i,n.keySplines=e,n.duration=t[t.length-1][0],this._insertAnimate(n,o)}}else if(Pt(i,n)){const n=Array.from(r.entries());for(let r=0;r<n.length-1;r++){const[c,u]=n[r],[f,p]=n[r+1];let d,m=e;if(i){const e=new J;if(o)for(let s=0;s<t.length-1;s++){const i=t[s],a=t[s+1];if(i[1]===a[1]&&c>=i[0]&&f<=a[0]){e.type=i[1];break}if(f-c==1&&f===a[0]){e.type=a[1];break}}else M.transform&&(e.type=M.transform.type);if(0===e.type)continue;e.values=[u.values().next().value,p.values().next().value];const s=h.get(f);s&&(e.transformOrigin=[s]),d=e}else if(s){const t=mt([[c,u],[f,p]],s,this.parent,O,a);if(!t)continue;(d=new K).attributeName="d",d.values=nt.replaceMap(t,t=>""+t.value)}else{const t=new J;t.type=SVGTransform.SVG_TRANSFORM_TRANSLATE,t.values=nt.objectMap([u,p],t=>{const e=t.get("x")||0,s=t.get("y")||0;return this.parent?`${this.parent.refitX(e)} ${this.parent.refitX(s)}`:`${e} ${s}`}),m+=r,d=t}o&&(d.delay=0===r?c:0),d.duration=f-c,d.keyTimes=[0,1],d.synchronized={key:r,value:m};const g=l.get(f);g&&(d.keySplines=[g]),this._insertAnimate(d,o)}}}}}})}_removeAnimations(t){t.length&&nt.spliceArray(this.animations,e=>t.includes(e))}_insertAnimate(t,e){e||(t.iterationCount=-1),t.from=t.valueFrom,t.to=t.valueTo,this.animations.push(t)}});const{constant:Lt,css:$t,dom:Bt,math:It,util:zt}=squared.lib;class Ht extends J{constructor(t,e){if(super(t,e),this.path="",this.distance=Lt.CSS.PERCENT_0,this.rotate="auto 0deg",this.motionPathElement=null,this.type=SVGTransform.SVG_TRANSFORM_TRANSLATE,this._offsetLength=0,e){this.setAttribute("path");const t=Bt.getNamedItem(e,"rotate");switch(t){case"auto":break;case"auto-reverse":this.rotate="auto 180deg";break;default:zt.isNumber(t)&&(this.rotate=`${zt.convertFloat(t)}deg`)}const s=e.children,i=s.length;for(let t=0;t<i;t++){const e=s[t];if("mpath"===e.tagName){let t=S(e);if(t&&(d.use(t)&&(t=S(t)),t&&d.shape(t))){this.motionPathElement=t;break}}}this.setCalcMode()}else if(t){const e=/path\("([^"]+)"\)/.exec(g(t,"offset-path"));e&&(this.path=e[1]);const s=g(t,"offset-distance",!1);""!==s&&(this.distance=s);const i=g(t,"offset-rotate",!1);""!==i&&i!==Lt.CSS.AUTO&&(this.rotate=i)}}setCalcMode(){if(this.animationElement){const t=Bt.getNamedItem(this.animationElement,"calcMode")||"paced";switch(t){case"paced":case"discrete":case"spline":super.setCalcMode("translate",t);break;case"linear":const e=J.toFractionList(Bt.getNamedItem(this.animationElement,"keyPoints"),";",!1);let s=super.keyTimes;0===s.length&&-1!==this.duration&&(s=J.toFractionList(Bt.getNamedItem(this.animationElement,"keyTimes")),this.length=0,super.keyTimes=s),e.length===s.length&&(this._keyPoints=e)}}}addKeyPoint(t){if(void 0===this._offsetPath){const e=t.key;if(e>=0&&e<=1){const s=super.keyTimes,i=this.keyPoints;if(s.length===i.length){const a=t.value;let n=NaN;if($t.isPercent(a)?n=parseFloat(a)/100:zt.isNumber(a)&&(n=parseFloat(a)/this.offsetLength),!isNaN(n)){n>1&&(n=1);const a=s.findIndex(t=>t===e);-1!==a?(s[a]=t.key,i[a]=n):(s.push(t.key),i.push(n))}}}}}setOffsetPath(){if(void 0===this._offsetPath&&this.path){const t=this.rotateData;let e=P.getOffsetPath(this.path,t&&this.rotate),s=e.length;if(s>0){const i=this.duration;let a=NaN;if(i>=s){a=i/s;for(let t=1;t<s-1;t++)e[t].key*=a;e[s-1].key=i}else if(i>0){const t=Array(i),a=s/i;for(let s=0;s<i;s++){const i=Math.floor(s*a);e[i].key=s,t[s]=e[i]}const n=e.pop();t[t.length-1].value!==n.value&&(n.key=i,t.push(n)),e=t,s=t.length}const n=this.keyPoints,r=this.framesPerSecond?1e3/this.framesPerSecond:0;if(n.length){const t=s-1,o=super.keyTimes,l=[];if(n.length>1){let s;const h=(t,e,i)=>!!s&&s.key===t&&i===s.rotate&&zt.isEqual(s.value,e),c=o.length;for(let u=0;u<c-1;u++){const c=It.truncateFraction(o[u]*i),f=It.truncateFraction((o[u+1]-o[u])*i),p=n[u],d=n[u+1];if(0===f){const i=c,{value:a,rotate:n}=e[Math.floor(d*t)];if(h(i,a,n))continue;l.push(s={key:i,value:a,rotate:n})}else{let s=0,i=c;if(p===d){const{value:n,rotate:o}=e[Math.floor(p*t)],u=isNaN(a)?1:a;for(h(c,n,o)&&(s+=u,i+=r);s<f;s+=u){const t=c+s;t>=i&&(l.push({key:t,value:n,rotate:o}),s<f-1?i+=r:i=0)}}else{const a=Math.floor(Math.min(p,d)*t),n=Math.floor(Math.max(p,d)*t),o=[];for(let t=a;t<=n;t++)o.push(Object.assign({},e[t]));p>d&&o.reverse();const u=o.length,m=f/u;for(h(c,o[0].value,o[0].rotate)&&(s++,i+=r);s<u;s++){const t=c+s*m;t>=i&&(o[s].key=t,l.push(o[s]),s<u-1?i+=r:i=0)}}l[l.length-1].key=c+f}}}else l.push(Object.assign({},e[Math.floor(n[0]*t)])),0===o[0]&&(l[0].rotate=0);this._offsetPath=l}else if(r>0){const t=[];for(let i=0;i<s;i+=r)t.push(e[Math.floor(i)]);const i=e.pop();i!==t[t.length-1]&&t.push(i),this._offsetPath=t}else this._offsetPath=e;if(t){e=this._offsetPath;for(let s=0,a=0;s<t.length-1;s++){const n=t[s],r=t[s+1],o=[];if(n.key===r.key)o.push(e[a++]);else{const t=Math.floor(It.truncateFraction(r.key*i));for(;;a++){const s=e[a];if(!(s&&s.key<=t))break;o.push(s)}}const l=$t.parseAngle(n.value.split(" ").pop()),h=$t.parseAngle(r.value.split(" ").pop());if(n.value===r.value||l===h)if(n.value.startsWith(Lt.CSS.AUTO)){if(0!==l)for(const t of o)t.rotate+=l}else for(const t of o)t.rotate=l;else{const t=h-l,e=o.length,s=t/e;if(n.value.startsWith(Lt.CSS.AUTO)){for(let t=0;t<e-1;t++)o[t].rotate+=l+t*s;o[e-1].rotate+=l+t}else{for(let t=0;t<e-1;t++)o[t].rotate=l+t*s;o[e-1].rotate=l+t}}}}this.keySplines=void 0,this.timingFunction=z.linear}}}reverseKeyPoints(){let t,e;if(this.validKeyPoints()){(e=this._keyPoints.slice(0)).reverse(),t=[];for(const e of super.keyTimes)t.push(1-e);t.reverse()}return{keyTimes:t,keyPoints:e}}validKeyPoints(){return!!this._keyPoints&&this._keyPoints.length>0&&this._keyPoints.length===super.keyTimes.length}get offsetPath(){return this._offsetPath}get playable(){return!this.paused&&-1!==this.duration&&zt.isString(this.path)}set keyTimes(t){this.path||(super.keyTimes=t)}get keyTimes(){if(this.setOffsetPath(),this._offsetPath){const t=this.duration;return zt.objectMap(this._offsetPath,e=>e.key/t)}return super.keyTimes}set values(t){this.path||(super.values=t)}get values(){return this.setOffsetPath(),this._offsetPath?zt.objectMap(this._offsetPath,t=>`${t.value.x} ${t.value.y}`):super.values}get rotateValues(){if(this.setOffsetPath(),this._offsetPath)return zt.objectMap(this._offsetPath,t=>t.rotate)}get keyPoints(){return void 0===this._keyPoints&&(this._keyPoints=[]),this._keyPoints}set reverse(t){if(t!==super.reverse){const{keyTimes:e,keyPoints:s}=this.reverseKeyPoints();e&&s&&(this.length=0,this._keyPoints=s,super.keyTimes=e,super.reverse=t)}}get reverse(){return super.reverse}set alternate(t){const e=this.iterationCount;if(t!==super.alternate&&(-1===e||e>1)){const{keyTimes:s,keyPoints:i}=this.reverseKeyPoints();if(s&&i){const a=this.duration;let n=super.keyTimes,r=this.keyPoints;const o=n.length;if(-1===e){for(let t=0;t<o;t++)n[t]/=2,s[t]=.5+s[t]/2;n=n.concat(s),r=r.concat(i),this.duration=2*a}else{const t=n.slice(0),l=r.slice(0);for(let a=0;a<e;a++)if(0===a)for(let t=0;t<o;t++)n[t]/=e;else{const h=a*(1/e),c=a%2==0?t.slice(0):s.slice(0);for(let t=0;t<o;t++)c[t]=It.truncateFraction(h+c[t]/e);n=n.concat(c),r=r.concat(a%2==0?l:i)}this.duration=a*e,this.iterationCount=1}this._keyTimes=n,this._keyPoints=r,super.alternate=t}}}get alternate(){return super.alternate}set parent(t){super.parent=t;const e=this.parentContainer;e&&e.requireRefit&&this.path&&(this.path=P.transformRefit(this.path,void 0,void 0,e))}get parent(){return super.parent}get offsetLength(){return 0===this._offsetLength&&this.path&&(this._offsetLength=k(this.path)),this._offsetLength}get instanceType(){return 114696}}const{constant:Wt,css:Xt,dom:qt,regex:Dt,util:Ut}=squared.lib,Yt="cubic-bezier\\(([\\d.]+), ([\\d.]+), ([\\d.]+), ([\\d.]+)\\)",jt=RegExp(`(ease|ease-in|ease-out|ease-in-out|linear|step-(?:start|end)|steps\\(\\d+, (?:start|end)\\)|${Yt}),?\\s*`,"g"),Kt=Xt.getKeyframeRules(),Zt={"animation-delay":"0s","animation-duration":"0s","animation-iteration-count":"1","animation-play-state":"running","animation-direction":"normal","animation-fill-mode":Wt.CSS.NONE,"animation-timing-function":"ease"};function Qt(t,e){const s=g(t,e);if("animation-timing-function"===e){jt.lastIndex=0;const t=[];let e;for(;null!==(e=jt.exec(s));)t.push(e[1]);return t}return s.split(Dt.XML.SEPARATOR)}function Jt(t){return t.sort((t,e)=>t.key!==e.key?t.key<e.key?-1:1:0)}function te(t){if("reverse"===t)return"auto 180deg";if(t.startsWith("reverse ")){const e=t.split(" ")[1];return Xt.isAngle(e)?`auto ${180+Xt.parseAngle(e)}deg`:"auto 0deg"}return t}var ee=t=>(class extends t{getTransforms(t){return void 0===t&&(t=this.element),P.filterTransforms(p.parse(t)||P.convertTransforms(t.transform.baseVal))}getAnimations(t){void 0===t&&(t=this.element);const e=[];let s=0;const i=(t,i,a="")=>{""===a&&s++,t.delay=i,t.group={id:s,name:a},t.parent=this,e.push(t)},a=t.children;let n=a.length;for(let e=0;e<n;e++){const s=a[e];if(s instanceof SVGAnimationElement){const e=qt.getNamedItem(s,"begin");if(""!==e&&/^[a-zA-Z]+$/.test(e))continue;const a=e?Ut.sortNumber(Ut.replaceMap(e.split(";"),t=>I.convertClockTime(t))):[0];if(a.length)switch(s.tagName){case"set":for(const e of a)i(new I(t,s),e);break;case"animate":for(const e of a)i(new K(t,s),e);break;case"animateTransform":for(const e of a){const a=new J(t,s);P.isShape(this)&&this.path&&(a.transformFrom=P.drawRefit(t,this.parent,this.viewport&&this.viewport.precision)),i(a,e)}break;case"animateMotion":for(const e of a){const a=new Ht(t,s);a.motionPathElement&&(a.path=P.drawRefit(a.motionPathElement,this.parent,this.viewport&&this.viewport.precision)),i(a,e)}}}}const r=Qt(t,"animation-name");if(n=r.length){const e={},a=[],l=[];for(const s in Zt){let i=Qt(t,s);for(0===i.length&&i.push(Zt[s]);i.length<n;)i=i.concat(i.slice(0));i.length=n,e[s]=i}for(let h=0;h<n;h++){const n=Kt[r[h]],c=I.convertClockTime(e["animation-duration"][h]);if(n&&c>0){s++;const u={},f={},d="paused"===e["animation-play-state"][h],m=I.convertClockTime(e["animation-delay"][h]),y=e["animation-iteration-count"][h],v=e["animation-fill-mode"][h],S=`${r[h]}_${h}`,b=[];let T=!0;l.push({name:S,attributes:b,paused:d,delay:m,duration:c,iterationCount:y,fillMode:v});for(const e in n){const s=parseFloat(e)/100,i=n[e];for(const e in i){const a=Zt[e]?f:u;void 0===a[e]&&(a[e]=[]);let n=i[e];n&&(Xt.isCalc(n)?n=Xt.calculateVar(t,n,e):Xt.isCustomProperty(n)&&(n=Xt.parseVar(t,n)),void 0!==n&&a[e].push({key:s,value:""+n}))}}if(u.transform){function o(e){const s=u["transform-origin"]&&u["transform-origin"].find(t=>t.key===e);if(s)return p.origin(t,s.value)}for(const e of Jt(u.transform)){const s=p.parse(t,e.value);if(s){const t=o(e.key);for(const i of s){const s=i.matrix;let a,n,r;switch(i.type){case SVGTransform.SVG_TRANSFORM_TRANSLATE:a="translate",n=`${s.e} ${s.f}`;break;case SVGTransform.SVG_TRANSFORM_SCALE:a="scale",n=`${s.a} ${s.d} ${t?`${t.x} ${t.y}`:"0 0"}`,!t||0===e.key&&0===t.x&&0===t.y||(r={x:t.x*(1-s.a),y:t.y*(1-s.d)});break;case SVGTransform.SVG_TRANSFORM_ROTATE:a="rotate",n=`${i.angle} ${t?`${t.x} ${t.y}`:"0 0"}`;break;case SVGTransform.SVG_TRANSFORM_SKEWX:a="skewX",n=""+i.angle,!t||0===e.key&&0===t.y||(r={x:t.y*s.c*-1,y:0});break;case SVGTransform.SVG_TRANSFORM_SKEWY:a="skewY",n=""+i.angle,!t||0===e.key&&0===t.x||(r={x:0,y:t.x*s.b*-1});break;default:continue}void 0===u[a]&&(u[a]=[]);const o=u[a].findIndex(t=>t.key===e.key);-1!==o?(u[a][o].value=n,u[a][o].transformOrigin=r):u[a].push({key:e.key,value:n,transformOrigin:r})}}}delete u.transform,delete u["transform-origin"]}if(g(t,"offset-path")===Wt.CSS.NONE)delete u["offset-distance"],delete u["offset-rotate"];else if(u["offset-rotate"]){const e=u["offset-rotate"];if(u["offset-distance"]||void 0===u.rotate){let s=g(t,"offset-rotate",!1);""!==s&&s!==Wt.CSS.AUTO||(s="auto 0deg"),Jt(e);const a=e[e.length-1];0!==e[0].key&&e.unshift({key:0,value:s}),1!==a.key&&e.push({key:1,value:s});for(let t=1;t<e.length;t++){const s=e[t-1],i=e[t];if(s.value=te(s.value),i.value=te(i.value),s.value.split(" ").pop()!==i.value.split(" ").pop()){const a=s.value.startsWith(Wt.CSS.AUTO),n=i.value.startsWith(Wt.CSS.AUTO);if(a&&!n||!a&&n){const a=(s.key+i.key)/2;e.splice(t++,0,{key:a,value:s.value}),e.splice(t++,0,{key:a,value:i.value})}}}if(void 0===u["offset-distance"]){const s=new Ht(t);s.duration=0,s.iterationCount=1,s.fillForwards=!0,s.addKeyPoint({key:0,value:s.distance}),i(s,m,S);for(const t of e){let e=Xt.parseAngle(t.value.split(" ").pop());t.value.startsWith(Wt.CSS.AUTO)&&(e+=90),t.value=`${e} 0 0`}u.rotate=e,delete u["offset-rotate"],T=!1}}else delete u["offset-rotate"]}for(const s in u){let n;switch(s){case"offset-rotate":continue;case"offset-distance":(n=new Ht(t)).rotateData=u["offset-rotate"];break;case"rotate":case"scale":case"skewX":case"skewY":case"translate":(n=new J(t)).setType(s);break;default:(n=new K(t)).attributeName=s}i(n,m,S);const r=u[s],o=e["animation-direction"][h],l=e["animation-timing-function"][h];if(Jt(r),"offset-distance"===s){const t=n;0!==r[0].key&&t.addKeyPoint({key:0,value:t.distance});for(const e of r)t.addKeyPoint(e);1!==r.pop().key&&t.addKeyPoint({key:1,value:t.distance}),Ut.isString(l)&&(t.timingFunction=l)}else{b.push(s);const e=[],i=[],a=[],o=r.length;for(let t=0;t<o;t++){if(e.push(r[t].key),i.push(r[t].value),T&&t<o-1){const e=f["animation-timing-function"]&&f["animation-timing-function"].find(e=>e.key===r[t].key);a.push(e?e.value:l)}const s=r[t].transformOrigin;s&&P.asAnimateTransform(n)&&(void 0===n.transformOrigin&&(n.transformOrigin=[]),n.transformOrigin[t]=s)}if(0!==e[0]&&(e.unshift(0),i.unshift(n.baseValue||""),T&&a.unshift(l),n.evaluateStart=!0),T&&!a.every(t=>"linear"===t)){const r=[],o=[],l=[],h=e.length;for(let n=0;n<h;n++){if(n<h-1){const h=(e[n+1]-e[n])*c;if(z[a[n]])a[n]=z[a[n]];else if(a[n].startsWith("step")){if(""!==i[n]){const u=K.convertStepTimingFunction(s,a[n],e,i,n,Xt.getFontSize(t));if(u){const t=1===e[n+1]?1:0;for(let s=0;s<u[0].length-t;s++){let t=(e[n]+u[0][s]*h)/c;r.includes(t)&&(t+=.001),r.push(t),o.push(u[1][s]),l.push(z[-1!==a[n].indexOf(Wt.CSS.START)?"step-start":"step-end"])}continue}}a[n]=z.linear}else{const t=RegExp(Yt).exec(a[n]);a[n]=t?`${t[1]} ${t[2]} ${t[3]} ${t[4]}`:z.ease}l.push(a[n])}r.push(e[n]),o.push(i[n])}n.values=o,n.keyTimes=r,n.keySplines=l}else n.values=i,n.keyTimes=e,T?n.keySplines=a:n.timingFunction=l}n.paused=d,n.duration=c,n.iterationCount="infinite"!==y?parseFloat(y):-1,n.fillForwards="forwards"===v||"both"===v,n.fillBackwards="backwards"===v||"both"===v,n.reverse=o.endsWith("reverse"),n.alternate=(-1===n.iterationCount||n.iterationCount>1)&&o.startsWith("alternate"),a.push(n)}}}l.reverse();for(const t of a)t.setGroupOrdering(l)}return e}set name(t){this._name=t}get name(){return void 0===this._name&&(this._name=P.setName(this.element)),this._name}get transforms(){return void 0===this._transforms&&(this._transforms=this.getTransforms()),this._transforms}get animations(){return void 0===this._animations&&(this._animations=this.getAnimations()),this._animations}get visible(){return function(t){const e=g(t,"visibility");return"hidden"!==e&&"collapse"!==e&&g(t,"display")!==Wt.CSS.NONE}(this.element)}get opacity(){return g(this.element,"opacity",!1)||"1"}});const{client:se,constant:ie}=squared.lib;function ae(t){if("svg"===t.tagName){if(se.isUserAgent(8))return t.parentElement instanceof HTMLElement;if(se.isUserAgent(4))return!(t.parentElement instanceof HTMLElement)}return!1}var ne=t=>(class extends t{setRect(){const t=this.parent;let e=this.x,s=this.y,i=this.width,a=this.height;t&&(e=t.refitX(e),s=t.refitY(s),i=t.refitSize(i),a=t.refitSize(a)),this.setBaseValue("x",e),this.setBaseValue("y",s),this.setBaseValue(ie.CSS.WIDTH,i),this.setBaseValue(ie.CSS.HEIGHT,a)}_getElement(){switch(this.element.tagName){case"svg":case"use":case"image":return this.element;default:return null}}set x(t){this._x=t}get x(){if(void 0!==this._x)return this._x;{const t=this._getElement();return t?t.x.baseVal.value:0}}set y(t){this._y=t}get y(){if(void 0!==this._y)return this._y;{const t=this._getElement();return t?t.y.baseVal.value:0}}set width(t){this._width=t}get width(){if(void 0!==this._width)return this._width;{const t=this._getElement();return t?ae(t)?t.getBoundingClientRect().width:t.width.baseVal.value:0}}set height(t){this._height=t}get height(){if(void 0!==this._height)return this._height;{const t=this._getElement();return t?ae(t)?t.getBoundingClientRect().height:t.height.baseVal.value:0}}});const re=squared.lib.util;function oe(t,e){const s=v(y(t,"fill"));if(""!==s){if(e&&e.definitions.pattern.has(s))return e.definitions.pattern.get(s);{const t=document.getElementById(s.substring(1));if(t instanceof SVGPatternElement)return t}}}class le extends squared.lib.base.Container{constructor(t){super(),this.element=t,this.aspectRatio={x:0,y:0,width:0,height:0,position:{x:0,y:0},parent:{x:0,y:0},unit:1},this._clipRegion=[]}append(t,e){return t.parent=this,t.viewport=e||this.getViewport(),super.append(t)}build(t){let e,s,i=!0;t?(e=t.symbolElement||t.patternElement||t.element||this.element,s=t.precision,!1===(t=Object.assign({},t,{symbolElement:void 0,patternElement:void 0,element:void 0})).initialize&&(i=!1)):e=this.element,this.clear();const a=this.getViewport();let n=!1;const r=e.children,o=r.length;for(let e=0;e<o;e++){const s=r[e];let o;if(d.svg(s))o=new squared.svg.Svg(s,!1),this.setAspectRatio(o,s.viewBox.baseVal),n=!0;else if(d.g(s))o=new squared.svg.SvgG(s),this.setAspectRatio(o);else if(d.use(s)){const t=S(s);if(t)if(d.symbol(t))o=new squared.svg.SvgUseSymbol(s,t),this.setAspectRatio(o,t.viewBox.baseVal),n=!0;else if(d.image(t))o=new squared.svg.SvgImage(s,t);else if(d.shape(t)){const e=oe(s,a);e?(o=new squared.svg.SvgUsePattern(s,t,e),this.setAspectRatio(o)):o=new squared.svg.SvgUse(s,t,i)}}else if(d.image(s))o=new squared.svg.SvgImage(s);else if(d.shape(s)){const t=oe(s,a);t?(o=new squared.svg.SvgShapePattern(s,t),this.setAspectRatio(o)):o=new squared.svg.SvgShape(s,i)}o&&(this.append(o,a),o.build(t))}if(P.asSvg(this)&&this.documentRoot)(this.aspectRatio.x<0||this.aspectRatio.y<0)&&this.clipViewBox(this.aspectRatio.x,this.aspectRatio.y,this.aspectRatio.width,this.aspectRatio.height,s,!0);else if(n&&this.hasViewBox()&&(0!==this.aspectRatio.x||0!==this.aspectRatio.y)){const t=P.getBoxRect(this.getPathAll(!1)),e=this.refitX(this.aspectRatio.x),i=this.refitY(this.aspectRatio.y);(t.left<e||t.top<i)&&this.clipViewBox(t.left,t.top,this.refitSize(this.aspectRatio.width),this.refitSize(this.aspectRatio.height),s)}}hasViewBox(){return P.asSvg(this)&&!!this.element.viewBox.baseVal||P.asUseSymbol(this)&&!!this.symbolElement.viewBox.baseVal}clipViewBox(t,e,s,i,a,n=!1){n&&(s-=t,i-=e,t=t<0?-1*t:0,e=e<0?-1*e:0),this.clipRegion=P.drawRect(s,i,t,e,a)}synchronize(t){this.each(e=>e.synchronize(t))}refitX(t){return(t-this.aspectRatio.x)*this.aspectRatio.unit-this.aspectRatio.parent.x+this.aspectRatio.position.x}refitY(t){return(t-this.aspectRatio.y)*this.aspectRatio.unit-this.aspectRatio.parent.y+this.aspectRatio.position.y}refitSize(t){return t*this.aspectRatio.unit}refitPoints(t){for(const e of t)e.x=this.refitX(e.x),e.y=this.refitY(e.y),void 0!==e.rx&&void 0!==e.ry&&(e.rx*=this.aspectRatio.unit,e.ry*=this.aspectRatio.unit);return t}getPathAll(t=!0){const e=[];for(const s of t?this.cascade():this)P.isShape(s)&&s.path&&s.path.value&&e.push(s.path.value);return e}getViewport(){return this.viewport||P.asSvg(this)&&this||void 0}setAspectRatio(t,e){const s=function(t){for(;t;){if(t.hasViewBox())return t;t=t.parent}}(this);if(s){const i=t.aspectRatio;if(e&&(re.cloneObject(e,i),i.width>0&&i.height>0)){const t=i.width/i.height,e=s.aspectRatio.width||s.viewBox.width,a=s.aspectRatio.height||s.viewBox.height,n=e/a;n>t?i.position.x=(e-a*t)/2:n<t&&(i.position.y=(a-e*(1/t))/2),i.unit=Math.min(e/i.width,a/i.height)}i.parent.x=s.aspectRatio.x+s.aspectRatio.x*(s.aspectRatio.unit-1),i.position.x*=s.aspectRatio.unit,i.position.x+=s.aspectRatio.position.x-s.aspectRatio.parent.x,i.parent.y=s.aspectRatio.y+s.aspectRatio.y*(s.aspectRatio.unit-1),i.position.y*=s.aspectRatio.unit,i.position.y+=s.aspectRatio.position.y-s.aspectRatio.parent.y,i.unit*=s.aspectRatio.unit}}set clipRegion(t){""!==t?this._clipRegion.push(t):this._clipRegion.length=0}get clipRegion(){return this._clipRegion.length?this._clipRegion.join(";"):""}get requireRefit(){return 0!==this.aspectRatio.x||0!==this.aspectRatio.y||0!==this.aspectRatio.position.x||0!==this.aspectRatio.position.y||0!==this.aspectRatio.parent.x||0!==this.aspectRatio.parent.y||1!==this.aspectRatio.unit}get instanceType(){return 2}}const{color:he,dom:ce,util:ue}=squared.lib;function fe(t){const e=[],s=t.getElementsByTagName("stop"),i=s.length;for(let t=0;t<i;t++){const i=s[t],a=he.parseColor(ce.getNamedItem(i,"stop-color"),ce.getNamedItem(i,"stop-opacity"));a&&e.push({color:a,offset:parseFloat(ce.getNamedItem(i,"offset"))/100})}return e}function pe(t,...e){const s={};for(const i of e)t[i]&&(s[i]=t[i].baseVal.value,s[`${i}AsString`]=t[i].baseVal.valueAsString);return s}class de{constructor(t){this.element=t}build(t){}synchronize(t){}get instanceType(){return 4}}const{color:me,constant:ge,css:ye,regex:ve,util:Se}=squared.lib,be={url:ve.CSS.URL};var Te=t=>(class extends t{setPaint(t,e){this.resetPaint(),this.setAttribute("color"),this.setAttribute("fill"),this.setAttribute("fill-opacity",!1),this.setAttribute("fill-rule"),this.setAttribute("stroke"),this.setAttribute("stroke-opacity",!1),this.setAttribute("stroke-width"),this.setAttribute("stroke-linecap"),this.setAttribute("stroke-linejoin"),this.setAttribute("stroke-miterlimit"),this.setAttribute("stroke-dasharray"),this.setAttribute("stroke-dashoffset"),this.setAttribute("clip-rule");const s=this.getAttribute("clip-path",!0,!1);if(""!==s&&"none"!==s){void 0===be.polygon&&(be.polygon=/polygon\(([^)]+)\)/,be.inset=RegExp(`inset\\(${ve.STRING.LENGTH_PERCENTAGE}\\s?${ve.STRING.LENGTH_PERCENTAGE}?\\s?${ve.STRING.LENGTH_PERCENTAGE}?\\s?${ve.STRING.LENGTH_PERCENTAGE}?\\)`),be.circle=RegExp(`circle\\(${ve.STRING.LENGTH_PERCENTAGE}(?: at ${ve.STRING.LENGTH_PERCENTAGE} ${ve.STRING.LENGTH_PERCENTAGE})?\\)`),be.ellipse=RegExp(`ellipse\\(${ve.STRING.LENGTH_PERCENTAGE} ${ve.STRING.LENGTH_PERCENTAGE}(?: at ${ve.STRING.LENGTH_PERCENTAGE} ${ve.STRING.LENGTH_PERCENTAGE})?\\)`));for(const i in be){const a=be[i].exec(s);if(a){if("url"===i)return void(this.clipPath=a[1]);if(t&&t.length){const s=P.getBoxRect(t),n=s.right-s.left,r=s.bottom-s.top,o=this.parent;switch(i){case"inset":{let t=0,i=0,l=this.convertLength(a[1],r),h=0;a[4]?(t=s.left+this.convertLength(a[4],n),i=s.right-this.convertLength(a[2],n),h=s.bottom-this.convertLength(a[3],r)):a[2]?(t=this.convertLength(a[2],n),i=s.right-t,h=s.bottom-(a[3]?this.convertLength(a[3],r):l),t+=s.left):(t=s.left+l,i=s.right-l,h=s.bottom-l);const c=[{x:t,y:l+=s.top},{x:i,y:l},{x:i,y:h},{x:t,y:h}];return o&&o.refitPoints(c),void(this.clipPath=P.drawPolygon(c,e))}case"polygon":{const t=Se.objectMap(a[1].split(ve.XML.SEPARATOR),t=>{let[e,i]=Se.replaceMap(t.trim().split(" "),(t,e)=>this.convertLength(t,0===e?n:r));return{x:e+=s.left,y:i+=s.top}});return o&&o.refitPoints(t),void(this.clipPath=P.drawPolygon(t,e))}default:if("circle"===i||"ellipse"===i){const t=n<r?n:r;let l,h;"circle"===i?h=l=this.convertLength(a[1],t):(l=this.convertLength(a[1],n),h=this.convertLength(a[2],r));let c=s.left,u=s.top;a.length>=4&&(c+=this.convertLength(a[a.length-2],t),u+=this.convertLength(a[a.length-1],t)),o&&(c=o.refitX(c),u=o.refitX(u),l=o.refitSize(l),h=o.refitSize(h)),this.clipPath=P.drawEllipse(c,u,l,h,e)}return}}}}}}setAttribute(t,e=!0,s=!0){let i=this.getAttribute(t,e,s);if(Se.isString(i)){if(ye.isCustomProperty(i)){const e=ye.calculateVar(this.element,i,t);void 0!==e&&(i=""+e)}switch(t){case"stroke-dasharray":i=i!==ge.CSS.NONE?Se.joinMap(i.split(/,\s*/),t=>""+this.convertLength(t),", "):"";break;case"stroke-dashoffset":case"stroke-width":i=""+this.convertLength(i);break;case"fill":case"stroke":const e=v(i);if(""!==e)this[`${t}Pattern`]=e;else{let e;switch(i.toLowerCase()){case"none":case"transparent":case"rgba(0, 0, 0, 0)":this[t]=ge.CSS.NONE;break;case"currentcolor":e=me.parseColor(this.color||g(this.element,t));break;default:e=me.parseColor(i)}e&&(this[t]=e.value)}return}this[Se.convertCamelCase(t)]=i}}getAttribute(t,e=!0,s=!0){let i=g(this.element,t,e);if(s&&!Se.isString(i)){if(this.patternParent)switch(t){case"fill-opacity":case"stroke-opacity":break;default:return i}let s=this.useParent||this.parent;for(;s&&(i=g(s.element,t,e),!Se.isString(i));)s=s.parent}return i}convertLength(t,e){if(!Se.isNumber(t)){if(ye.isLength(t))return ye.parseUnit(t,ye.getFontSize(this.element));if(ye.isPercent(t))return Math.round(("number"==typeof e?e:this.element.getBoundingClientRect()[e||ge.CSS.WIDTH])*Se.convertFloat(t)/100)}return Se.convertFloat(t)}resetPaint(){this.fill="black",this.fillPattern="",this.fillOpacity="1",this.fillRule="nonzero",this.stroke="",this.strokeWidth="1",this.strokePattern="",this.strokeOpacity="1",this.strokeLinecap="butt",this.strokeLinejoin="miter",this.strokeMiterlimit="4",this.strokeDasharray="",this.strokeDashoffset="0",this.color="",this.clipPath="",this.clipRule=""}});const{constant:ke,util:xe}=squared.lib;const{constant:Re,dom:Ae,math:_e,util:Ee}=squared.lib;function Ve(t,e,s,i){const a=t[0],n=t[t.length-1];if(void 0!==s)switch(e){case"x":s-=a.start.x;break;case"x1":case"cx":return a.start.x=s,void(a.coordinates[0]=s);case"x2":return n.end.x=s,void(n.coordinates[0]=s)}if(void 0!==i)switch(e){case"y":i-=a.start.y;break;case"y1":case"cy":return a.start.y=i,void(a.coordinates[1]=i);case"y2":return n.end.y=i,void(n.coordinates[1]=i)}for(const e of t){const t=e.value,a=e.coordinates,n=a.length;for(let r=0,o=0;r<n;r+=2,o++)void 0!==s&&(e.relative||(a[r]+=s),t[o].x+=s),void 0!==i&&(e.relative||(a[r+1]+=i),t[o].y+=i)}}function we(t,e,s){const i=t.length;for(let a=0;a<i;a++){const i=t[a];if("A"===i.key.toUpperCase()){if(void 0!==e){const s=e-i.radiusX;i.radiusX=e,i.coordinates[0]=2*e*(i.coordinates[0]<0?-1:1),1===a&&(t[0].coordinates[0]-=s,t[0].end.x-=s)}void 0!==s&&(i.radiusY=s)}}}class Ne extends(Te(G(de))){constructor(t){super(t),this.element=t,this.name="",this.value="",this.baseValue="",this.init()}static extrapolate(t,e,s,i,a,n){const r=!!i||!!a&&!!a.parent&&a.parent.requireRefit,o=[];let l;const h=s.length;for(let c=0;c<h;c++){if("d"===t)o[c]=s[c];else if("points"===t){const t=P.convertPoints(P.parseCoordinates(s[c]));t.length&&(o[c]=a&&d.polygon(a.element)?P.drawPolygon(t,n):P.drawPolyline(t,n))}else if(e){void 0===l&&(l=P.getPathCommands(e));const i=parseFloat(s[c]);if(!isNaN(i)){const e=c<h-1?Ee.cloneArray(l,[],!0):l;switch(t){case"x":case"x1":case"x2":case"cx":Ve(e,t,i);break;case"y":case"y1":case"y2":case"cy":Ve(e,t,void 0,i);break;case"r":we(e,i,i);break;case"rx":we(e,i);break;case"ry":we(e,void 0,i);break;case"width":for(const t of[1,2]){const s=e[t];switch(s.key){case"m":case"l":case"h":s.coordinates[0]=i*(s.coordinates[0]<0?-1:1);break;case"M":case"L":case"H":s.coordinates[0]=e[0].end.x+i}}break;case"height":for(const t of[2,3]){const s=e[t];switch(s.key){case"m":case"l":case"v":s.coordinates[1]=i*(s.coordinates[1]<0?-1:1);break;case"M":case"L":case"V":s.coordinates[1]=e[0].end.y+i}}break;default:o[c]="";continue}o[c]=P.drawPath(e,n)}}o[c]?r&&(o[c]=P.transformRefit(o[c],i,a,a&&a.parent,n)):o[c]=""}return o}build(t){let e;t&&t.transforms&&(e=P.filterTransforms(t.transforms,t.exclude&&t.exclude[this.element.tagName])),this.draw(e,t)}draw(t,e){let s,i;e&&(s=e.residual,i=e.precision);const a=this.element,n=this.parent,r=this.patternParent,o=!!n&&n.requireRefit,l=!!r&&2===r.patternContentUnits;let h;if(this.transformed=void 0,d.path(a)){if(h=this.getBaseValue("d"),t&&t.length||o||l){const e=P.getPathCommands(h);if(e.length){let c=P.getPathPoints(e);c.length&&(l&&r.patternRefitPoints(c),t&&t.length&&("function"==typeof s&&([this.transformResidual,t]=s.call(this,a,t)),t.length&&(c=P.applyTransforms(t,c,p.origin(this.element)),this.transformed=t)),this.baseValue=P.drawPath(P.syncPathPoints(o?Ee.cloneArray(e,[],!0):e,o?Ee.cloneArray(c,[],!0):c,void 0!==this.transformed),i),o?(n.refitPoints(c),h=P.drawPath(P.syncPathPoints(e,c,void 0!==this.transformed),i)):h=this.baseValue)}}""===this.baseValue&&(this.baseValue=h)}else if(d.line(a)){let e=[{x:this.getBaseValue("x1"),y:this.getBaseValue("y1")},{x:this.getBaseValue("x2"),y:this.getBaseValue("y2")}];l&&r.patternRefitPoints(e),t&&t.length&&("function"==typeof s&&([this.transformResidual,t]=s.call(this,a,t)),t.length&&(e=P.applyTransforms(t,e,p.origin(this.element)),this.transformed=t));const c=()=>P.drawPolyline(e,i);this.baseValue=c(),o?(n.refitPoints(e),h=c()):h=this.baseValue}else if(d.circle(a)||d.ellipse(a)){const e=this.getBaseValue("cx"),c=this.getBaseValue("cy");let u,f;d.ellipse(a)?(u=this.getBaseValue("rx"),f=this.getBaseValue("ry")):f=u=this.getBaseValue("r");let m=[{x:e,y:c,rx:u,ry:f}];l&&r.patternRefitPoints(m),t&&t.length&&("function"==typeof s&&([this.transformResidual,t]=s.call(this,a,t,u,f)),t.length&&(m=P.applyTransforms(t,m,p.origin(this.element)),this.transformed=t));const g=m[0],y=()=>P.drawEllipse(g.x,g.y,g.rx,g.ry,i);this.baseValue=y(),o?(n.refitPoints(m),h=y()):h=this.baseValue}else if(d.rect(a)){let e=this.getBaseValue("x"),c=this.getBaseValue("y"),u=this.getBaseValue(Re.CSS.WIDTH),f=this.getBaseValue(Re.CSS.HEIGHT);if(t&&t.length){let d=[{x:e,y:c},{x:e+u,y:c},{x:e+u,y:c+f},{x:e,y:c+f}];l&&r.patternRefitPoints(d),"function"==typeof s&&([this.transformResidual,t]=s.call(this,a,t)),t.length&&(d=P.applyTransforms(t,d,p.origin(this.element)),this.transformed=t);const m=()=>P.drawPolygon(d,i);this.baseValue=m(),o?(n.refitPoints(d),h=m()):h=this.baseValue}else{l&&(e=r.patternRefitX(e),c=r.patternRefitY(c),u=r.patternRefitX(u),f=r.patternRefitY(f));const t=()=>P.drawRect(u,f,e,c,i);this.baseValue=t(),o?(e=n.refitX(e),c=n.refitY(c),u=n.refitSize(u),f=n.refitSize(f),h=t()):h=this.baseValue}}else if(d.polygon(a)||d.polyline(a)){let e=this.getBaseValue("points");l&&r.patternRefitPoints(e),t&&t.length&&("function"==typeof s&&([this.transformResidual,t]=s.call(this,a,t)),t.length&&(e=P.applyTransforms(t,e,p.origin(this.element)),this.transformed=t));const c=()=>d.polygon(a)?P.drawPolygon(e,i):P.drawPolyline(e,i);this.baseValue=c(),o?(null===this.transformed&&(e=P.clonePoints(e)),n.refitPoints(e),h=c()):h=this.baseValue}else h="";return this.value=h,this.setPaint([h],i),h}extendLength(t,e){if(""!==this.value)switch(this.element.tagName){case"path":case"line":case"polyline":const s=P.getPathCommands(this.value);if(s.length){const i=s[0],a=i.start,n=s[s.length-1],r=n.end,o=n.key.toUpperCase(),l=t.leading,h=t.trailing;let c=!1;if("Z"!==o&&(a.x!==r.x||a.y!==r.y)){if(l>0){let t;if(i.value.length>1?t=i.value[1]:s.length>1&&(t=s[1].start),t)if(t.x===a.x)i.coordinates[1]=i.coordinates[1]+(a.y>t.y?l:-l),c=!0;else if(t.y===a.y)i.coordinates[0]=i.coordinates[0]+(a.x>t.x?l:-l),c=!0;else{const e=_e.relativeAngle(t,a);i.coordinates[0]=i.coordinates[0]-_e.offsetAngleX(e,l),i.coordinates[1]=i.coordinates[1]-_e.offsetAngleY(e,l),c=!0}}switch(o){case"M":case"L":if(h>0){let t;if(1===s.length?i.value.length>1&&(t=i.value[i.value.length-2]):t=n.value.length>1?n.value[n.value.length-2]:s[s.length-2].end,t)if(t.x===r.x)n.coordinates[1]=n.coordinates[1]+(r.y>t.y?h:-h),c=!0;else if(t.y===r.y)n.coordinates[0]=n.coordinates[0]+(r.x>t.x?h:-h),c=!0;else{const e=_e.relativeAngle(t,r),s=n.coordinates[0]+_e.offsetAngleX(e,h),i=n.coordinates[1]+_e.offsetAngleY(e,h);n.coordinates[0]=s,n.coordinates[1]=i,c=!0}}break;case"H":case"V":{const t="H"===o?0:1;n.coordinates[t]=n.coordinates[t]+(l+h)*(n.coordinates[t]>=0?1:-1),c=!0;break}}}if(c)return t.leading=l,t.trailing=h,t.path=P.drawPath(s,e),t}}}flattenStrokeDash(t,e,s,i,a){let n,r,o,l;i||(i=s);let h=0;const c=t=>r[t%n];if(a)({dashArray:r,dashArrayTotal:o,extendedLength:l,startIndex:h}=a),n=r.length,a.items=[],a.leading=0;else{n=t.length,r=t.slice(0);const u=_e.nextMultiple([2,n]);o=0;for(let e=0;e<u;e++){const s=t[e%n];o+=s,e>=n&&r.push(s)}if(n=u,e>0){let t=c(0);for(;e-t>=0;)e-=t,t=c(++h);h%=n}else if(e<0){for(r.reverse();e<0;)e+=c(h++);h=n-h%n,r.reverse()}a={dashArray:r,dashArrayTotal:o,items:[],leading:0,trailing:0,startIndex:h,extendedLength:l=i,lengthRatio:s/(i||s)}}let u,f=0;for(let t=0,s=0;;t+=s,h++){let i,n;s=c(h),t<e?(a.leading=e-t,i=0,n=s-a.leading):(i=t-e,n=s);const r=_e.truncateFraction(i/l);if(u=_e.truncateFraction(r+n/l),h%2==0?r<1&&(a.items.push({start:r,end:Math.min(u,1),length:s}),f+=s):f+=s,u>=1)break}for(a.trailing=_e.truncateFraction((u-1)*l);f%o!=0;){const t=c(++h);a.trailing+=t,f+=t}return 0===a.items.length?a.items.push({start:1,end:1}):(a.leadingOffset=_e.truncateFraction(a.items[0].start*l),a.leading*=a.lengthRatio,a.trailing*=a.lengthRatio),a}extractStrokeDash(t,e){const s=Ee.convertInt(this.strokeWidth);let i,a="",n="";if(s>0){let f=P.parseCoordinates(this.strokeDasharray);if(f.length){const p=this.totalLength,d=this.pathLength||p,m=[];let g,y=Ee.convertInt(this.strokeDashoffset),v=0;const S=(t,e,s,i=0)=>{const a=this.flattenStrokeDash(t,e,p,d);return 0===m.length&&(g=a),v=Math.max(v,a.items.length),m.push({items:a.items,delay:s,duration:i}),a.items};if(i=S(f,y,0),t){const b=t.slice(0).sort((t,e)=>{if(t.attributeName.startsWith("stroke-dash")&&e.attributeName.startsWith("stroke-dash")){if(t.delay!==e.delay)return t.delay<e.delay?-1:1;if(P.asSet(t)&&P.asAnimate(e)||void 0===t.animationElement&&e.animationElement)return-1;if(P.asAnimate(t)&&P.asSet(e)||t.animationElement&&void 0===e.animationElement)return 1}return 0}),T=new et(b,"stroke-dasharray","stroke-dashoffset");if(b.length>1)for(let t=0;t<b.length;t++)T.has(b[t].attributeName,b[t].delay,b[t])||b.splice(t--,1);function r(t,e=!1){const s=T.get("stroke-dashoffset",t,e);return s?parseFloat(s):y}function o(t,e=!1){const s=T.get("stroke-dasharray",t,e);return s?P.parseCoordinates(s):f}const x=t=>t?`${t.start} ${t.end}`:"1 1";let R=t=>{let e=y;const s=b.length;for(let i=t;i<s;i++){const t=b[i];if("stroke-dasharray"===t.attributeName){const s=T.get("stroke-dashoffset",t.delay);s&&(e=parseFloat(s));for(const s of P.asAnimate(t)?T.evaluateStart(t):[t.to])v=Math.max(v,this.flattenStrokeDash(P.parseCoordinates(s),e,p,d).items.length)}}},A=[],_=!1;for(let t=0;t<b.length;t++){const E=b[t];if(E.setterType){function l(t,e){S(t,e,E.delay,E.fillReplace&&E.duration>0?E.duration:0),_=!0}switch(E.attributeName){case"stroke-dasharray":l(f=P.parseCoordinates(E.to),r(E.delay));continue;case"stroke-dashoffset":y=Ee.convertInt(E.to),l(o(E.delay),y);continue}}else if(P.asAnimate(E)&&E.playable)switch(T.evaluateStart(E),E.attributeName){case"stroke-dasharray":{R&&(R(t),R=void 0);const e=r(E.delay),s=this.flattenStrokeDash(o(E.delay),e,p,d).items,i=[],a=[];for(let t=0;t<v;t++){const e=new K(this.element);e.id=t,e.baseValue=x(s[t]),e.attributeName="stroke-dasharray",e.delay=E.delay,e.duration=E.duration,e.iterationCount=E.iterationCount,e.fillMode=E.fillMode,a[t]=[],i.push(e)}for(const t of E.values){const s=this.flattenStrokeDash(P.parseCoordinates(t),e,p,d).items;for(let t=0;t<v;t++)a[t].push(x(s[t]))}const n=E.keyTimes,l=E.keySplines,h=E.timingFunction;for(let t=0;t<v;t++)i[t].values=a[t],i[t].keyTimes=n,l?i[t].keySplines=l:h&&(i[t].timingFunction=h);if(E.fillReplace){const t=E.getTotalDuration(),e=this.flattenStrokeDash(o(t),r(t),p,d).items;for(let t=0;t<v;t++)i[t].replaceValue=x(e[t])}A=A.concat(i),_=!0;continue}case"stroke-dashoffset":{const t=E.duration,r=parseFloat(E.values[0]),o=[],l=[];let f=0,S=0;y===r||0!==E.delay||E.fillReplace||(g=this.flattenStrokeDash(g.dashArray,r,p,d),m[0].items=i=g.items,v=Math.max(v,g.items.length),y=r);let b,x=p,R=1;if((g.leading>0||g.trailing>0)&&(this.extendLength(g,e),g.path)){const t=P.getBoxRect([this.value]);R=(x=_e.truncateFraction(k(g.path)))/p,g.extendedLength=this.pathLength,g.extendedLength>0?g.extendedLength*=R:g.extendedLength=x;const e=this.flattenStrokeDash(g.dashArray,0,p,d,g);m[0].items=i=e.items,v=Math.max(v,i.length);const r=Math.ceil(s/2);a=g.path,n=P.drawRect(t.right-t.left,t.bottom-t.top+2*r,t.left,t.top-r)}if(E.fillReplace&&-1!==E.iterationCount){const t=Ee.convertFloat(T.get(E.attributeName,E.getTotalDuration()));if(t!==y){let e=Math.abs(t-y)%x/x;t>y&&(e=1-e),b=""+e}}const A=E.keyTimes,V=E.values,w=A.length;for(let e=0;e<w;e++){const s=0===e?y:parseFloat(V[e-1]),i=parseFloat(V[e]),a=Math.abs(i-s),n=A[e];if(0===a){e>0&&(l.push(f=n),o.length?(o.push(o[o.length-1]),S=parseFloat(o[o.length-1])):(o.push("0"),S=0));continue}const r=i>s,p=e>0?(n-A[e-1])*t:0,d=a*g.lengthRatio,m=e=>e/d*p/t;function h(t,e=!1){if(T=(b-t)/x,e){const t=_e.truncateFraction(T);r?t>0&&(T=1-T):0===t&&(T=1)}}function c(){e>0&&(r?"1"===o[o.length-1]:"0"===o[o.length-1])||(l.push(0===f?0:_e.truncateFraction(f)),o.push(r?"1":"0"))}function u(){l.push(f=n);const t=_e.truncateFraction(T);o.push(""+t),S=t>0&&t<1?T:0}let v=d/x,b=d,T=0;if(0===e)b%=x,h(0),r&&(T=1-T),u();else{if(S>0){const t=r?S:1-S,e=_e.truncateFraction(t*x);if(_e.lessEqual(b,e)){h(0),r?T=S-T:T+=S,u();continue}o.push(r?"0":"1"),f+=m(e),l.push(_e.truncateFraction(f)),v=_e.truncateFraction(v-t),b=_e.truncateFraction(b-e)}if(_e.isEqual(b,x)&&(b=x),b>x){const t=(v=Math.floor(v))*x;t===b&&v--,h(t,!0)}else v=0,h(0,!0);for(;v>0;)c(),o.push(r?"0":"1"),f+=m(x),l.push(_e.truncateFraction(f)),v--;c(),u()}}E.baseValue="0",E.replaceValue=b,E.values=o,E.keyTimes=l;const N=E.timingFunction;N&&(E.keySplines=void 0,E.timingFunction=N),_=!0;break}}A.push(E)}if(_){const e=m.length;for(let t=0;t<e;t++){const s=m[t].items;if(s===i)for(let t=s.length;t<v;t++)s.push({start:1,end:1});else{const a=m[t].delay,n=m[t].duration,l=e>2?this.flattenStrokeDash(o(a-1),r(a-1),p,d).items:i;for(let t=0;t<v;t++){const e=new I(this.element);e.id=t,e.attributeName="stroke-dasharray",e.baseValue=x(l[t]),e.delay=a,e.to=x(s[t]),e.duration=n,e.fillFreeze=0===n,A.push(e)}}}t=A}}}}return[t,i,a,n]}init(){const t=this.element;d.path(t)?this.setBaseValue("d"):d.line(t)?(this.setBaseValue("x1"),this.setBaseValue("y1"),this.setBaseValue("x2"),this.setBaseValue("y2")):d.rect(t)?(this.setBaseValue("x"),this.setBaseValue("y"),this.setBaseValue(Re.CSS.WIDTH),this.setBaseValue(Re.CSS.HEIGHT)):d.circle(t)?(this.setBaseValue("cx"),this.setBaseValue("cy"),this.setBaseValue("r")):d.ellipse(t)?(this.setBaseValue("cx"),this.setBaseValue("cy"),this.setBaseValue("rx"),this.setBaseValue("ry")):(d.polygon(t)||d.polyline(t))&&this.setBaseValue("points",P.clonePoints(t.points))}get transforms(){return void 0===this._transforms&&(this._transforms=P.filterTransforms(p.parse(this.element)||P.convertTransforms(this.element.transform.baseVal))),this._transforms}get pathLength(){return Ee.convertFloat(Ae.getNamedItem(this.element,"pathLength"))}get totalLength(){return this.element.getTotalLength()}get instanceType(){return 1028}}class Me extends(ee(le)){constructor(t,e){super(t),this.element=t,this.patternElement=e}build(t){t=Object.assign({},t,{patternElement:this.patternElement,initialize:!1}),super.build(t)}get animations(){return[]}get instanceType(){return 130}}class Pe extends(Ot(ee(de))){constructor(t,e=!0){super(t),this.element=t,e&&this.setPath()}setPath(){this.path=new Ne(this.element)}build(t){this.path&&(this.path.parent=this.parent,t=Object.assign({},t,{transforms:this.transforms}),this.path.build(t))}synchronize(t){if(this.path&&this.animations.length){const e=t&&t.element;this.animateSequentially(this.getAnimateShape(e||this.element),e?void 0:this.getAnimateTransform(t),this.path,t)}}set path(t){this._path=t,t&&(t.name=this.name)}get path(){return this._path}get instanceType(){return 2052}}const{css:Ce,dom:Fe}=squared.lib,Ge=t=>Ce.isPercent(t)?parseFloat(t)/100:parseFloat(t);class Oe extends(Te(G(ee(le)))){constructor(t,e){super(t),this.element=t,this.patternElement=e,this.__get_transforms=!1,this.patternUnits="userSpaceOnUse"===Fe.getNamedItem(this.patternElement,"patternUnits")?1:2,this.patternContentUnits="objectBoundingBox"===Fe.getNamedItem(this.patternElement,"patternContentUnits")?2:1}build(t){const e=t&&t.element||this.element,s=new Ne(e);if(s.build(t),s.value){const i=t&&t.precision;t=Object.assign({},t),this.clipRegion=s.value,s.clipPath&&(this.clipRegion=s.clipPath);const a=[s.value];this.setPaint(a,i),this.drawRegion=P.getBoxRect(a);const n=this.patternWidth,r=this.patternHeight,o=this.tileWidth,l=this.tileHeight;let h=this.offsetX%o,c=this.offsetY%l,u=0,f=0,p=this.drawRegion.right,d=this.drawRegion.bottom;2===this.patternUnits&&(p-=this.drawRegion.left,d-=this.drawRegion.top,u=this.drawRegion.left,f=this.drawRegion.top);let m=0;for(0!==h&&(h=o-h,p+=o),0!==c&&(c=l-c,d+=l);d>0;){const s=f+m*l-c;let a=p,g=0;do{const c=u+g*o-h,f=new Me(e,this.patternElement);f.build(t);for(const e of f.cascade())P.isShape(e)&&(e.setPath(),e.path&&(e.path.patternParent=this,2===this.patternContentUnits?e.path.refitBaseValue(c/n,s/r,i):e.path.refitBaseValue(c,s,i),t.transforms=e.transforms,e.path.build(t),e.path.fillOpacity=""+parseFloat(e.path.fillOpacity)*parseFloat(this.fillOpacity),e.path.clipPath=P.drawRect(o,l,c,s,i)+(""!==e.path.clipPath?`;${e.path.clipPath}`:"")));this.append(f),a-=o,g++}while(a>0);m++,d-=l}if(""!==this.stroke&&parseFloat(this.strokeWidth)>0){s.fill="",s.fillOpacity="0",s.stroke=this.stroke,s.strokeWidth=this.strokeWidth;const t=new Pe(e,!1);t.path=s,this.append(t)}}}patternRefitX(t){return this.drawRegion?t*this.patternWidth:t}patternRefitY(t){return this.drawRegion?t*this.patternHeight:t}patternRefitPoints(t){if(this.drawRegion){const e=this.patternWidth,s=this.patternHeight;for(const i of t)if(i.x*=e,i.y*=s,void 0!==i.rx&&void 0!==i.ry)if(i.rx===i.ry){const t=Math.min(e,s);i.rx*=t,i.ry*=t}else i.rx*=e,i.ry*=s}return t}get patternWidth(){return this.drawRegion?this.drawRegion.right-this.drawRegion.left:0}get patternHeight(){return this.drawRegion?this.drawRegion.bottom-this.drawRegion.top:0}get transforms(){if(!this.__get_transforms){const t=P.convertTransforms(this.patternElement.patternTransform.baseVal);if(t.length){const e=p.rotateOrigin(this.patternElement,"patternTransform"),s=this.patternWidth/2,i=this.patternHeight/2;for(const a of t)switch(a.type){case SVGTransform.SVG_TRANSFORM_TRANSLATE:break;case SVGTransform.SVG_TRANSFORM_ROTATE:for(;e.length;){const t=e.shift();if(t.angle===a.angle){a.origin={x:s+t.x,y:i+t.y};break}}if(a.origin)break;default:a.origin={x:s,y:i}}this._transforms=super.transforms.concat(P.filterTransforms(t))}this.__get_transforms=!0}return super.transforms}get offsetX(){let t=0;return 2===this.patternUnits&&(t=this.patternWidth*Ge(this.patternElement.x.baseVal.valueAsString)),t||this.patternElement.x.baseVal.value}get offsetY(){let t=0;return 2===this.patternUnits&&(t=this.patternHeight*Ge(this.patternElement.y.baseVal.valueAsString)),t||this.patternElement.y.baseVal.value}get tileWidth(){let t=0;return 2===this.patternUnits&&(t=this.patternWidth*Ge(this.patternElement.width.baseVal.valueAsString)),t||this.patternElement.width.baseVal.value}get tileHeight(){let t=0;return 2===this.patternUnits&&(t=this.patternHeight*Ge(this.patternElement.height.baseVal.valueAsString)),t||this.patternElement.height.baseVal.value}get instanceType(){return 258}}const Le=squared.lib.util;const $e={constant:H,util:x};t.Svg=class extends(Ot(ne(G(ee(le))))){constructor(t,e=!0){super(t),this.element=t,this.documentRoot=e,this.definitions={clipPath:new Map,pattern:new Map,gradient:new Map},this.init()}build(t){this.precision=t&&t.precision,this.setRect(),super.build(t)}synchronize(t){!this.documentRoot&&this.animations.length&&this.animateSequentially(this.getAnimateViewRect(),this.getAnimateTransform(t),void 0,t),super.synchronize(t)}init(){this.documentRoot&&(ue.cloneObject(this.element.viewBox.baseVal,this.aspectRatio),this.element.querySelectorAll("set, animate, animateTransform, animateMotion").forEach(t=>{const e=S(t,this.element);e&&(t.parentElement&&t.parentElement.removeChild(t),e.appendChild(t))})),this.setDefinitions(this.element),this.element.querySelectorAll("defs").forEach(t=>this.setDefinitions(t))}setDefinitions(t){t.querySelectorAll("clipPath, pattern, linearGradient, radialGradient").forEach(t=>{if(t.id){const e=`#${t.id}`;d.clipPath(t)?this.definitions.clipPath.set(e,t):d.pattern(t)?this.definitions.pattern.set(e,t):d.linearGradient(t)?this.definitions.gradient.set(e,Object.assign({type:"linear",element:t,spreadMethod:t.spreadMethod.baseVal,colorStops:fe(t)},pe(t,"x1","x2","y1","y2"))):d.radialGradient(t)&&this.definitions.gradient.set(e,Object.assign({type:"radial",element:t,spreadMethod:t.spreadMethod.baseVal,colorStops:fe(t)},pe(t,"cx","cy","r","fx","fy","fr")))}})}get viewBox(){return this.element.viewBox.baseVal||m(this.element)}get instanceType(){return 18}},t.SvgAnimate=K,t.SvgAnimateMotion=Ht,t.SvgAnimateTransform=J,t.SvgAnimation=I,t.SvgAnimationIntervalMap=et,t.SvgBaseVal=G,t.SvgBuild=P,t.SvgContainer=le,t.SvgElement=de,t.SvgG=class extends(Te(ee(le))){constructor(t){super(t),this.element=t}build(t){super.build(t),this.setPaint(this.getPathAll(),t&&t.precision)}get instanceType(){return 34}},t.SvgImage=class extends(ne(G(ee(de)))){constructor(t,e){super(t),this.element=t,this.imageElement=null,this.__get_transforms=!1,this.__get_animations=!1,e&&(this.imageElement=e)}build(){this.setRect()}extract(t){const e=t?P.filterTransforms(this.transforms,t):this.transforms;let s=this.x,i=this.y,a=this.width,n=this.height;if(e.length){e.reverse();for(const t of e){const e=t.matrix,r=s;switch(s=f.applyX(e,r,i),i=f.applyY(e,r,i),t.type){case SVGTransform.SVG_TRANSFORM_SCALE:a*=e.a,n*=e.d;break;case SVGTransform.SVG_TRANSFORM_ROTATE:0!==t.angle&&(e.a<0&&(s+=e.a*a),e.c<0&&(s+=e.c*a),e.b<0&&(i+=e.b*n),e.d<0&&(i+=e.d*n),this.rotateAngle?this.rotateAngle+=t.angle:this.rotateAngle=t.angle)}}this.transformed=e}this.parent&&(s=this.parent.refitX(s),i=this.parent.refitY(i),a=this.parent.refitSize(a),n=this.parent.refitSize(n)),this.translationOffset&&(s+=this.translationOffset.x,i+=this.translationOffset.y),this.setBaseValue("x",s),this.setBaseValue("y",i),this.setBaseValue(ke.CSS.WIDTH,a),this.setBaseValue(ke.CSS.HEIGHT,n)}set x(t){super.x=t}get x(){const t=super.x;return 0===t&&this.imageElement?this.imageElement.x.baseVal.value:t}set y(t){super.y=t}get y(){const t=super.y;return 0===t&&this.imageElement?this.imageElement.y.baseVal.value:t}set width(t){super.width=t}get width(){const t=super.width;return 0===t&&this.imageElement?this.imageElement.width.baseVal.value:t}set height(t){super.height=t}get height(){const t=super.height;return 0===t&&this.imageElement?this.imageElement.height.baseVal.value:t}get href(){const t=this.imageElement||this.element;return d.image(t)?xe.resolvePath(t.href.baseVal):""}get transforms(){let t=super.transforms;return this.__get_transforms||(this.imageElement&&(t=t.concat(this.getTransforms(this.imageElement)),this._transforms=t),this.__get_transforms=!0),t}get animations(){let t=super.animations;return this.__get_animations||(this.imageElement&&(t=t.concat(this.getAnimations(this.imageElement)),this._animations=t),this.__get_animations=!0),t}get instanceType(){return 4100}},t.SvgPaint=Te,t.SvgPath=Ne,t.SvgPattern=Me,t.SvgShape=Pe,t.SvgShapePattern=Oe,t.SvgSynchronize=Ot,t.SvgUse=class extends(Te(ne(G(Pe)))){constructor(t,e,s=!0){super(t,!1),this.element=t,this.shapeElement=e,this.__get_transforms=!1,this.__get_animations=!1,s&&this.setPath()}setPath(){this.path=new Ne(this.shapeElement),this.path.useParent=this}build(t){super.build(t),this.setPaint(this.path?[this.path.value]:void 0,t&&t.precision)}synchronize(t){t=Object.assign({},t,{element:this.shapeElement}),this.animations.length&&this.animateSequentially(this.getAnimateViewRect(),this.getAnimateTransform(t),void 0,t),super.synchronize(t)}get transforms(){let t=super.transforms;return this.__get_transforms||(t=t.concat(this.getTransforms(this.shapeElement)),this._transforms=t,this.__get_transforms=!0),t}get animations(){let t=super.animations;return this.__get_animations||(t=t.concat(this.getAnimations(this.shapeElement)),this._animations=t,this.__get_animations=!0),t}get instanceType(){return 10244}},t.SvgUsePattern=class extends(Ot(ne(Oe))){constructor(t,e,s){super(t,s),this.element=t,this.shapeElement=e}build(t){t=Object.assign({},t,{element:this.shapeElement}),super.build(t)}synchronize(t){const e=Le.filterArray(this.animations,t=>void 0===this.verifyBaseValue(t.attributeName,0)||"x"===t.attributeName||"y"===t.attributeName),s=this.getAnimateTransform(t);(e.length||s.length)&&this.animateSequentially(this.getAnimateViewRect(e),s,void 0,t),super.synchronize(t)}get instanceType(){return 514}},t.SvgUseSymbol=class extends(Te(Ot(ne(G(ee(le)))))){constructor(t,e){super(t),this.element=t,this.symbolElement=e}build(t){t=Object.assign({},t,{symbolElement:this.symbolElement}),this.setRect(),super.build(t);const e=this.getBaseValue("x",0),s=this.getBaseValue("y",0);if(0!==e||0!==s){const t={x:e,y:s};for(const e of this.cascade())e.translationOffset=t}this.setPaint(this.getPathAll(),t&&t.precision)}synchronize(t){this.animations.length&&this.animateSequentially(this.getAnimateViewRect(),this.getAnimateTransform(t),void 0,t),super.synchronize(t)}get viewBox(){return this.symbolElement.viewBox.baseVal||m(this.element)}get instanceType(){return 66}},t.SvgView=ee,t.SvgViewRect=ne,t.lib=$e,Object.defineProperty(t,"__esModule",{value:!0})});
