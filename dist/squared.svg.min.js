!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e(((t=t||self).squared=t.squared||{},t.squared.svg={}))}(this,function(t){"use strict";const e=squared.lib.css,s=squared.lib.dom,i=squared.lib.math,a=squared.lib.regex,n=`(${a.STRING.DECIMAL})`,r={MATRIX:RegExp(`(matrix(?:3d)?)\\(${n}, ${n}, ${n}, ${n}, ${n}, ${n}(?:, ${n})?(?:, ${n})?(?:, ${n})?(?:, ${n})?(?:, ${n})?(?:, ${n})?(?:, ${n})?(?:, ${n})?(?:, ${n})?(?:, ${n})?\\)`,"g"),ROTATE:RegExp(`(rotate[XY]?)\\(${a.STRING.CSS_ANGLE}\\)`,"g"),SKEW:RegExp(`(skew[XY]?)\\(${a.STRING.CSS_ANGLE}(?:, ${a.STRING.CSS_ANGLE})?\\)`,"g"),SCALE:RegExp(`(scale[XY]?)\\(${n}(?:, ${n})?\\)`,"g"),TRANSLATE:RegExp(`(translate[XY]?)\\(${a.STRING.LENGTH_PERCENTAGE}(?:, ${a.STRING.LENGTH_PERCENTAGE})?\\)`,"g")},o={path:1,line:2,rect:3,ellipse:4,circle:5,polyline:6,polygon:7},l={applyX:(t,e,s)=>t.a*e+t.c*s+t.e,applyY:(t,e,s)=>t.b*e+t.d*s+t.f,clone:t=>({a:t.a,b:t.b,c:t.c,d:t.d,e:t.e,f:t.f}),rotate(t){const e=i.convertRadian(t),s=Math.cos(e),a=Math.sin(e);return{a:s,b:a,c:-1*a,d:s,e:0,f:0}},skew:(t=0,e=0)=>({a:1,b:Math.tan(i.convertRadian(e)),c:Math.tan(i.convertRadian(t)),d:1,e:0,f:0}),scale:(t=1,e=1)=>({a:t,b:0,c:0,d:e,e:0,f:0}),translate:(t=0,e=0)=>({a:1,b:0,c:0,d:1,e:t,f:e})},h={create:(t,e,s=0,i=!0,a=!0)=>({type:t,matrix:e,angle:s,method:{x:i,y:a}}),parse(t,s){const i=s||t.style.getPropertyValue("transform");if(""!==i){const a=[];for(const n in r){let o;for(;null!==(o=r[n].exec(i));){const i=o[1].endsWith("X"),n=o[1].endsWith("Y");if(o[1].startsWith("rotate")){const t=e.convertAngle(o[2],o[3]),s=l.rotate(t);i?(s.a=1,s.b=0,s.c=0):n&&(s.b=0,s.c=0,s.d=1),a[o.index]=h.create(SVGTransform.SVG_TRANSFORM_ROTATE,s,t,!i,!n)}else if(o[1].startsWith("skew")){const t=n?0:e.convertAngle(o[2],o[3]),s=n?e.convertAngle(o[2],o[3]):o[4]&&o[5]?e.convertAngle(o[4],o[5]):0,r=l.skew(t,s);i?a[o.index]=h.create(SVGTransform.SVG_TRANSFORM_SKEWX,r,t,!0,!1):n?a[o.index]=h.create(SVGTransform.SVG_TRANSFORM_SKEWY,r,s,!1,!0):(a[o.index]=h.create(SVGTransform.SVG_TRANSFORM_SKEWX,Object.assign({},r,{b:0}),t,!0,!1),0!==s&&(a[o.index+1]=h.create(SVGTransform.SVG_TRANSFORM_SKEWY,Object.assign({},r,{c:0}),s,!1,!0)))}else if(o[1].startsWith("scale")){const t=n?void 0:parseFloat(o[2]),e=n?parseFloat(o[2]):!i&&o[3]?parseFloat(o[3]):t,s=l.scale(t,i?void 0:e);a[o.index]=h.create(SVGTransform.SVG_TRANSFORM_SCALE,s,0,!n,!i)}else if(o[1].startsWith("translate")){const s=e.getFontSize(t),r=e.parseUnit(o[2],s),c=!i&&o[3]?e.parseUnit(o[3],s):0,u=l.translate(n?0:r,n?r:c);a[o.index]=h.create(SVGTransform.SVG_TRANSFORM_TRANSLATE,u,0)}else if(o[1].startsWith("matrix")){const e=h.matrix(t,s);e&&(a[o.index]=h.create(SVGTransform.SVG_TRANSFORM_MATRIX,e))}}}const n=[];return a.forEach(t=>{t.fromCSS=!0,n.push(t)}),n}},matrix(t,s){const i=RegExp(r.MATRIX).exec(s||e.getStyle(t).transform||"");if(i)switch(i[1]){case"matrix":return{a:parseFloat(i[2]),b:parseFloat(i[3]),c:parseFloat(i[4]),d:parseFloat(i[5]),e:parseFloat(i[6]),f:parseFloat(i[7])};case"matrix3d":return{a:parseFloat(i[2]),b:parseFloat(i[3]),c:parseFloat(i[6]),d:parseFloat(i[7]),e:parseFloat(i[14]),f:parseFloat(i[15])}}},origin(t,s){void 0===s&&(s=f(t,"transform-origin"));const i={x:0,y:0};if(""!==s){const n=g(t);function a(s,a,n){e.isLength(a)?i[s]=e.parseUnit(a,e.getFontSize(t)):e.isPercent(a)&&(i[s]=parseFloat(a)/100*n)}let r=0,o=0;if(n)r=n.width,o=n.height;else{const e=t.parentElement;e instanceof SVGGraphicsElement&&e.viewportElement&&(c.svg(e.viewportElement)||c.symbol(e.viewportElement))&&(r=e.viewportElement.viewBox.baseVal.width,o=e.viewportElement.viewBox.baseVal.height)}if(!r||!o){const e=t.getBoundingClientRect();r=e.width,o=e.height}const l=s.split(" ");switch(1===l.length&&l.push("center"),l[0]){case"0%":case"left":break;case"100%":case"right":i.x=r;break;case"center":l[0]="50%";default:a("x",l[0],r)}switch(l[1]){case"0%":case"top":break;case"100%":case"bottom":i.y=o;break;case"center":l[1]="50%";default:a("y",l[1],o)}}return i},rotateOrigin(t,e="transform"){const i=s.getNamedItem(t,e),a=[];if(""!==i){const t=/rotate\((-?[\d.]+)(?:,? (-?[\d.]+))?(?:,? (-?[\d.]+))?\)/g;let e;for(;null!==(e=t.exec(i));){const t=parseFloat(e[1]);0!==t&&a.push({angle:t,x:e[2]?parseFloat(e[2]):0,y:e[3]?parseFloat(e[3]):0})}}return a},typeAsName(t){switch(t){case SVGTransform.SVG_TRANSFORM_ROTATE:return"rotate";case SVGTransform.SVG_TRANSFORM_SCALE:return"scale";case SVGTransform.SVG_TRANSFORM_SKEWX:return"skewX";case SVGTransform.SVG_TRANSFORM_SKEWY:return"skewY";case SVGTransform.SVG_TRANSFORM_TRANSLATE:return"translate";default:return""}},typeAsValue(t){switch(t){case"rotate":case SVGTransform.SVG_TRANSFORM_ROTATE:return"0 0 0";case"scale":case SVGTransform.SVG_TRANSFORM_SCALE:return"1 1 0 0";case"skewX":case"skewY":case SVGTransform.SVG_TRANSFORM_SKEWX:case SVGTransform.SVG_TRANSFORM_SKEWY:return"0";case"translate":case SVGTransform.SVG_TRANSFORM_TRANSLATE:return"0 0";default:return""}}},c={svg:t=>"svg"===t.tagName,g:t=>"g"===t.tagName,symbol:t=>"symbol"===t.tagName,path:t=>"path"===t.tagName,shape:t=>void 0!==o[t.tagName],image:t=>"image"===t.tagName,use:t=>"use"===t.tagName,line:t=>"line"===t.tagName,rect:t=>"rect"===t.tagName,circle:t=>"circle"===t.tagName,ellipse:t=>"ellipse"===t.tagName,polygon:t=>"polygon"===t.tagName,polyline:t=>"polyline"===t.tagName,clipPath:t=>"clipPath"===t.tagName,pattern:t=>"pattern"===t.tagName,linearGradient:t=>"linearGradient"===t.tagName,radialGradient:t=>"radialGradient"===t.tagName};function u(t){const e=t.getBoundingClientRect();return e.x=e.left,e.y=e.top,e}function f(t,i,a=!0){return s.getNamedItem(t,i)||a&&e.getStyle(t).getPropertyValue(i)||""}function p(t,e){let s=t,i="";for(;s&&(""===(i=f(s,e))||"inherit"===i);)s=s.parentElement;return i}function d(t){const e=/url\("?(#.+?)"?\)/.exec(t);return e?e[1]:""}function m(t,e){const i=s.getNamedItem(t,"href");if("#"===i.charAt(0)){const s=i.substring(1);let a;if(void 0===e)for(a=t.parentElement;a&&a.parentElement instanceof SVGGraphicsElement;)a=a.parentElement;else a=e;if(a){const t=a.querySelectorAll("*");for(let e=0;e<t.length;e++){const i=t[e];if(i.id===s&&i instanceof SVGElement)return i}}else{const t=document.getElementById(s);if(t instanceof SVGElement)return t}}return null}function g(t){let e=t.parentElement;for(;e;){if((c.svg(e)||c.symbol(e))&&e.viewBox&&e.viewBox.baseVal.width>0&&e.viewBox.baseVal.height>0)return e.viewBox.baseVal;e=e.parentElement}}function y(t){const e=document.createElementNS("http://www.w3.org/2000/svg","path");return e.setAttribute("d",t),e.getTotalLength()}var v=Object.freeze({MATRIX:l,TRANSFORM:h,SVG:c,getDOMRect:u,getAttribute:f,getParentAttribute:p,parseAttributeURL:d,getTargetElement:m,getNearestViewBox:g,getPathLength:y});const b=squared.lib.dom,S=squared.lib.math,T=squared.lib.regex,k=squared.lib.util,x=new Map;class R{static isContainer(t){return k.hasBit(t.instanceType,2)}static isElement(t){return k.hasBit(t.instanceType,4)}static isShape(t){return k.hasBit(t.instanceType,2052)}static isAnimate(t){return k.hasBit(t.instanceType,16392)}static asSvg(t){return 18===t.instanceType}static asG(t){return 34===t.instanceType}static asPattern(t){return 130===t.instanceType}static asShapePattern(t){return 258===t.instanceType}static asUsePattern(t){return 514===t.instanceType}static asImage(t){return 4100===t.instanceType}static asUse(t){return 10244===t.instanceType}static asUseSymbol(t){return 66===t.instanceType}static asSet(t){return 8===t.instanceType}static asAnimate(t){return 16392===t.instanceType}static asAnimateTransform(t){return 81928===t.instanceType}static asAnimateMotion(t){return 49160===t.instanceType}static setName(t){if(t){let e,s="";if(k.isString(t.id)){const i=k.convertWord(t.id,!0);x.has(i)||(s=i),e=i}else e=t.tagName;let i=x.get(e)||0;return""!==s?(x.set(s,i),s):(x.set(e,++i),`${e}_${i}`)}return x.clear(),""}static drawLine(t,e,s=0,i=0,a){const n=`M${t},${e} L${s},${i}`;return a?S.truncateString(n,a):n}static drawRect(t,e,s=0,i=0,a){const n=`M${s},${i} ${s+t},${i} ${s+t},${i+e} ${s},${i+e} Z`;return a?S.truncateString(n,a):n}static drawCircle(t,e,s,i){return R.drawEllipse(t,e,s,s,i)}static drawEllipse(t,e,s,i,a){void 0===i&&(i=s);const n=`M${t-s},${e} a${s},${i},0,0,1,${2*s},0 a${s},${i},0,0,1,-${2*s},0`;return a?S.truncateString(n,a):n}static drawPolygon(t,e){return t.length?`${R.drawPolyline(t,e)} Z`:""}static drawPolyline(t,e){let s="M";for(const e of t)s+=`${e.x},${e.y} `;return s=s.substring(0,s.length-1),e?S.truncateString(s,e):s}static drawPath(t,e){let s="";for(const e of t)switch(s+=(""!==s?" ":"")+e.key,e.key.toUpperCase()){case"M":case"L":case"C":case"S":case"Q":case"T":s+=e.coordinates.join(",");break;case"H":s+=e.coordinates[0];break;case"V":s+=e.coordinates[1];break;case"A":s+=`${e.radiusX},${e.radiusY},${e.xAxisRotation},${e.largeArcFlag},${e.sweepFlag},${e.coordinates.join(",")}`}return e?S.truncateString(s,e):s}static drawRefit(t,e,s){let i;if(c.path(t)){if(i=b.getNamedItem(t,"d"),e&&e.requireRefit()){const t=R.getPathCommands(i);if(t.length){const a=R.extractPathPoints(t);a.length&&(e.refitPoints(a),i=R.drawPath(R.rebindPathPoints(t,a),s))}}}else if(c.line(t)){const a=[{x:t.x1.baseVal.value,y:t.y1.baseVal.value},{x:t.x2.baseVal.value,y:t.y2.baseVal.value}];e&&e.requireRefit()&&e.refitPoints(a),i=R.drawPolyline(a,s)}else if(c.circle(t)||c.ellipse(t)){let a,n;c.ellipse(t)?(a=t.rx.baseVal.value,n=t.ry.baseVal.value):n=a=t.r.baseVal.value;const r=[{x:t.cx.baseVal.value,y:t.cy.baseVal.value,rx:a,ry:n}];e&&e.requireRefit()&&e.refitPoints(r);const o=r[0];i=R.drawEllipse(o.x,o.y,o.rx,o.ry,s)}else if(c.rect(t)){let a=t.x.baseVal.value,n=t.y.baseVal.value,r=t.width.baseVal.value,o=t.height.baseVal.value;e&&e.requireRefit()&&(a=e.refitX(a),n=e.refitY(n),r=e.refitSize(r),o=e.refitSize(o)),i=R.drawRect(r,o,a,n,s)}else if(c.polygon(t)||c.polyline(t)){const a=R.clonePoints(t.points);e&&e.requireRefit()&&e.refitPoints(a),i=c.polygon(t)?R.drawPolygon(a,s):R.drawPolyline(a,s)}else i="";return i}static transformRefit(t,e,s,i){const a=R.getPathCommands(t);if(a.length){let n=R.extractPathPoints(a);if(n.length){const r=e&&e.length>0;r&&(n=R.applyTransforms(e,n,s&&h.origin(s.element))),s&&s.parent&&s.parent.requireRefit()&&s.parent.refitPoints(n),t=R.drawPath(R.rebindPathPoints(a,n,r),i)}}return t}static getPathCommands(t){const e=[],s=/([A-Za-z])([^A-Za-z]+)?/g;let i;for(t=t.trim();null!==(i=s.exec(t))&&(0!==e.length||"M"===i[1].toUpperCase());){const t=R.parseCoordinates((i[2]||"").trim());let s,a,n,r,o,l,h;if(e.length){const t=e[e.length-1];s=t.key.toUpperCase(),a=t.end}switch(i[1].toUpperCase()){case"M":0===e.length&&(i[1]="M");case"L":if(t.length>=2){t.length%2!=0&&t.length--;break}continue;case"H":if(a&&t.length){t[1]="h"===i[1]?0:a.y,t.length=2;break}continue;case"V":if(a&&t.length){const e=t[0];t[0]="v"===i[1]?0:a.x,t[1]=e,t.length=2;break}continue;case"Z":if(e.length){t[0]=e[0].coordinates[0],t[1]=e[0].coordinates[1],t.length=2,i[1]="Z";break}continue;case"C":if(t.length>=6){t.length=6;break}continue;case"S":if(t.length>=4&&("C"===s||"S"===s)){t.length=4;break}continue;case"Q":if(t.length>=4){t.length=4;break}continue;case"T":if(t.length>=2&&("Q"===s||"T"===s)){t.length=2;break}continue;case"A":if(t.length>=7){[n,r,o,l,h]=t.splice(0,5),t.length=2;break}continue;default:continue}if(t.length>=2){const s=i[1]===i[1].toLowerCase(),c=[];for(let e=0;e<t.length;e+=2){let i=t[e],n=t[e+1];s&&a&&(i+=a.x,n+=a.y),c.push({x:i,y:n})}e.push({key:i[1],value:c,start:c[0],end:c[c.length-1],relative:s,coordinates:t,radiusX:n,radiusY:r,xAxisRotation:o,largeArcFlag:l,sweepFlag:h})}}return e}static extractPathPoints(t,e=!1){const s=[];let i=0,a=0;for(let n=0;n<t.length;n++){const r=t[n];for(let t=0;t<r.coordinates.length;t+=2){r.relative?(i+=r.coordinates[t],a+=r.coordinates[t+1]):(i=r.coordinates[t],a=r.coordinates[t+1]);const n={x:i,y:a};"A"===r.key.toUpperCase()&&(n.rx=r.radiusX,n.ry=r.radiusY,e&&(r.coordinates[t]>=0?n.y-=r.radiusY:n.y+=r.radiusY)),s.push(n)}r.relative&&(r.key=r.key.toUpperCase())}return s}static rebindPathPoints(t,e,s=!1){let i;t:for(const a of t)if(a.relative){if(!i)break;if(!s||"H"!==a.key&&"V"!==a.key){for(let t=0,s=0;t<a.coordinates.length;t+=2,s++){const n=e.shift();if(!n)break t;a.coordinates[t]=n.x-i.x,a.coordinates[t+1]=n.y-i.y,"a"===a.key&&void 0!==n.rx&&void 0!==n.ry&&(a.radiusX=n.rx,a.radiusY=n.ry),a.value[s]=n}a.key=a.key.toLowerCase()}else{const t=e.shift();if(!t)break t;a.coordinates[0]=t.x,a.coordinates[1]=t.y,a.value[0]=t,a.start=t,a.end=t,a.key="L",a.relative=!1}i=a.end}else{switch(a.key.toUpperCase()){case"M":case"L":case"H":case"V":case"C":case"S":case"Q":case"T":case"Z":for(let s=0,i=0;s<a.coordinates.length;s+=2,i++){const n=e.shift();if(!n){t=[];break t}a.coordinates[s]=n.x,a.coordinates[s+1]=n.y,a.value[i]=n}break;case"A":{const s=e.shift();if(!s||void 0===s.rx||void 0===s.ry){t=[];break t}a.coordinates[0]=s.x,a.coordinates[1]=s.y,a.radiusX=s.rx,a.radiusY=s.ry,a.value[0]=s;break}}a.relative||(i=a.end)}return t}static filterTransforms(t,e){const s=[];for(const i of t)if(void 0===e||!e.includes(i.type)){switch(i.type){case SVGTransform.SVG_TRANSFORM_ROTATE:case SVGTransform.SVG_TRANSFORM_SKEWX:case SVGTransform.SVG_TRANSFORM_SKEWY:if(0===i.angle)continue;break;case SVGTransform.SVG_TRANSFORM_SCALE:if(1===i.matrix.a&&1===i.matrix.d)continue;break;case SVGTransform.SVG_TRANSFORM_TRANSLATE:if(0===i.matrix.e&&0===i.matrix.f)continue}s.push(i)}return s}static applyTransforms(t,e,s){t=t.slice(0).reverse();const i=R.clonePoints(e);for(const e of t){const t=e.matrix;let a=0,n=0,r=0,o=0;if(s)switch(e.type){case SVGTransform.SVG_TRANSFORM_SCALE:e.method.x&&(r=s.x*(1-t.a)),e.method.y&&(o=s.y*(1-t.d));break;case SVGTransform.SVG_TRANSFORM_SKEWX:e.method.y&&(n-=s.y);break;case SVGTransform.SVG_TRANSFORM_SKEWY:e.method.x&&(a-=s.x);break;case SVGTransform.SVG_TRANSFORM_ROTATE:e.method.x&&(a-=s.x,r=s.x+S.offsetAngleY(e.angle,s.x)),e.method.y&&(n-=s.y,o=s.y+S.offsetAngleY(e.angle,s.y))}for(const s of i){const i=s.x;if(s.x=l.applyX(t,i,s.y+n)+r,s.y=l.applyY(t,i+a,s.y)+o,e.type===SVGTransform.SVG_TRANSFORM_SCALE&&void 0!==s.rx&&void 0!==s.ry){const e=s.rx;s.rx=l.applyX(t,e,s.ry+n),s.ry=l.applyY(t,e+a,s.ry)}}}return i}static convertTransforms(t){const e=[];for(let s=0;s<t.numberOfItems;s++){const i=t.getItem(s);e.push(h.create(i.type,i.matrix,i.angle))}return e}static clonePoints(t){const e=[];if(Array.isArray(t))for(const s of t){const t={x:s.x,y:s.y};void 0!==s.rx&&void 0!==s.ry&&(t.rx=s.rx,t.ry=s.ry),e.push(t)}else for(let s=0;s<t.numberOfItems;s++){const i=t.getItem(s);e.push({x:i.x,y:i.y})}return e}static minMaxPoints(t){let e=t[0].x,s=t[0].x,i=t[0].y,a=t[0].y;for(let n=1;n<t.length;n++){const r=t[n];r.x<e?e=r.x:r.x>s&&(s=r.x),r.y<i?i=r.y:r.y>a&&(a=r.y)}return[e,i,s,a]}static centerPoints(t){const e=this.minMaxPoints(t);return{x:(e[0]+e[2])/2,y:(e[1]+e[3])/2}}static convertPoints(t){const e=[];if(t.length%2==0)for(let s=0;s<t.length;s+=2)e.push({x:t[s],y:t[s+1]});return e}static parsePoints(t){const e=[];for(const s of t.trim().split(T.CHAR.SPACE)){const[t,i]=k.replaceMap(s.split(T.XML.SEPARATOR),t=>parseFloat(t));e.push({x:t,y:i})}return e}static parseCoordinates(t){const e=[],s=/-?[\d.]+/g;let i;for(;null!==(i=s.exec(t));){const t=parseFloat(i[0]);isNaN(t)||e.push(t)}return e}static parseBoxRect(t){const e=[];for(const s of t)k.concatArray(e,R.extractPathPoints(R.getPathCommands(s),!0));const s=this.minMaxPoints(e);return{top:s[1],right:s[2],bottom:s[3],left:s[0]}}}const A=squared.lib.dom;function w(t,e,s,i,a){for(const n of t)n.x+=e,n.y+=s,void 0!==n.rx&&void 0!==n.ry&&(n.rx*=i,n.ry*=a)}var V=t=>(class extends t{constructor(){super(...arguments),this._baseVal={}}setBaseValue(t,e){if(void 0!==e){if(this.verifyBaseValue(t,e))return this._baseVal[t]=e,!0}else switch(t){case"d":return this._baseVal[t]=A.getNamedItem(this.element,"d"),!0;case"points":const e=this.element[t];if(Array.isArray(e))return this._baseVal[t]=R.clonePoints(e),!0;break;default:const s=this.element[t];if(s&&s.baseVal)return this._baseVal[t]=s.baseVal.value,!0}return!1}getBaseValue(t,e){return void 0!==this._baseVal[t]||this.setBaseValue(t)?this._baseVal[t]:e}refitBaseValue(t,e,s,i=1,a=1){for(const n in this._baseVal){const r=this._baseVal[n];if("string"==typeof r){if("d"===n){const o=R.getPathCommands(r),l=R.extractPathPoints(o);w(l,t,e,i,a),this._baseVal[n]=R.drawPath(R.rebindPathPoints(o,l),s)}}else if("number"==typeof r)switch(n){case"cx":case"x1":case"x2":case"x":this._baseVal[n]+=t;break;case"cy":case"y1":case"y2":case"y":this._baseVal[n]+=e;break;case"r":this._baseVal[n]*=Math.min(i,a);break;case"rx":case"width":this._baseVal[n]*=i;break;case"ry":case"height":this._baseVal[n]*=a}else Array.isArray(r)&&"points"===n&&w(r,t,e,i,a)}}verifyBaseValue(t,e){switch(t){case"d":return"string"==typeof e;case"cx":case"cy":case"r":case"rx":case"ry":case"x1":case"x2":case"y1":case"y2":case"x":case"y":case"width":case"height":return"number"==typeof e;case"points":return Array.isArray(e)}}});const _=squared.lib.css,E=squared.lib.dom,N=squared.lib.util,M={MS:/-?\d+ms$/,S:/-?\d+s$/,MIN:/-?\d+min$/,H:/-?\d+(.\d+)?h$/,CLOCK:/^(?:(-?)(\d?\d):)?(?:(\d?\d):)?(\d?\d)\.?(\d?\d?\d)?$/};class F{constructor(t,e){if(this.element=null,this.animationElement=null,this.paused=!1,this.fillMode=0,this.synchronizeState=0,this._attributeName="",this._duration=-1,this._delay=0,this._to="",t&&(this.element=t),e){this.animationElement=e,this.setAttribute("attributeName"),this.setAttribute("to"),this.setAttribute("fill","freeze");const t=E.getNamedItem(e,"dur");""!==t&&"indefinite"!==t&&(this.duration=F.convertClockTime(t))}}static convertClockTime(t){let e=0,s=0;if(N.isNumber(t))e=parseInt(t);else if(M.MS.test(t))s=parseFloat(t);else if(M.S.test(t))e=parseFloat(t);else if(M.MIN.test(t))e=60*parseFloat(t);else if(M.H.test(t))e=60*parseFloat(t)*60;else{const i=M.CLOCK.exec(t);i&&(i[2]&&(e+=60*parseInt(i[2])*60),i[3]&&(e+=60*parseInt(i[3])),i[4]&&(e+=parseInt(i[4])),i[5]&&(s=parseInt(i[5])*(i[5].length<3?Math.pow(10,3-i[5].length):1)),i[1]&&(e*=-1,s*=-1))}return 1e3*e+s}setAttribute(t,e){if(this.animationElement){const s=E.getNamedItem(this.animationElement,t);""!==s&&(void 0!==e?this[t+N.capitalize(e)]=s===e:this[t]=s)}}addState(...t){for(const e of t)N.hasBit(this.synchronizeState,e)||(this.synchronizeState|=e)}removeState(...t){for(const e of t)N.hasBit(this.synchronizeState,e)&&(this.synchronizeState^=e)}hasState(...t){return t.some(t=>N.hasBit(this.synchronizeState,t))}setFillMode(t,e){const s=N.hasBit(this.fillMode,e);t?s||(this.fillMode|=e):s&&(this.fillMode^=e)}set attributeName(t){if("transform"!==t&&!N.isString(this.baseValue)&&(this.baseValue=p(this.element,t),!N.isString(this.baseValue))){const e=this.animationElement&&this.animationElement.parentElement;this.baseValue=N.optionalAsString(e,`${t}.baseVal.valueAsString`),_.isLength(this.baseValue)&&(this.baseValue=""+_.parseUnit(this.baseValue,_.getFontSize(e)))}this._attributeName=t}get attributeName(){return this._attributeName}set delay(t){this._delay=t}get delay(){return this._delay}set duration(t){this._duration=Math.round(t)}get duration(){return this._duration}set to(t){this._to=t}get to(){return this._to}set fillBackwards(t){this.setFillMode(t,8)}get fillBackwards(){return N.hasBit(this.fillMode,8)}set fillForwards(t){this.setFillMode(t,4)}get fillForwards(){return N.hasBit(this.fillMode,4)}set fillFreeze(t){this.setFillMode(t,2)}get fillFreeze(){return N.hasBit(this.fillMode,2)}get fillReplace(){return 0===this.fillMode||8===this.fillMode}set group(t){this._group=t}get group(){return this._group||{id:-1/0,name:""}}set setterType(t){}get setterType(){return!0}get instanceType(){return 8}}const P={ease:"0.25 0.1 0.25 1","ease-in":"0.42 0 1 1","ease-in-out":"0.42 0 0.58 1","ease-out":"0 0 0.58 1",linear:"0 0 1 1","step-start":"0 1 0 1","step-end":"1 0 1 0"};var G=Object.freeze({KEYSPLINE_NAME:P});const C=squared.lib.color,O=squared.lib.css,B=squared.lib.dom,$=squared.lib.regex,L=squared.lib.util,I=t=>parseFloat((1-t).toPrecision(5));class q extends F{constructor(t,e){if(super(t,e),this.type=0,this.from="",this.alternate=!1,this.additiveSum=!1,this.accumulateSum=!1,this.evaluateStart=!1,this._iterationCount=1,this._reverse=!1,this._setterType=!1,this._repeatDuration=-1,e){const t=B.getNamedItem(e,"values"),s=-1!==this.duration?q.toFractionList(B.getNamedItem(e,"keyTimes")):[];if(""!==t)this.values=L.trimEnd(t,";").split(/\s*;\s*/),this.length>1&&s.length===this.length?(this.from=this.values[0],this.to=this.values[this.length-1],this.keyTimes=s):1===this.length&&(this.to=this.values[0],this.convertToValues());else{if(this.from=B.getNamedItem(e,"from"),""===this.to){const t=B.getNamedItem(e,"by");L.isNumber(t)&&(""===this.from&&(this.baseValue&&(this.from=this.baseValue),this.evaluateStart=!0),L.isNumber(this.from)&&(this.to=""+(parseFloat(this.from)+parseFloat(t))))}L.isNumber(this.to)&&this.setAttribute("additive","sum"),this.convertToValues(s)}const i=B.getNamedItem(e,"repeatDur");""!==i&&"indefinite"!==i&&(this._repeatDuration=F.convertClockTime(i));const a=B.getNamedItem(e,"repeatCount");this.iterationCount="indefinite"===a?-1:parseFloat(a),"animate"===e.tagName&&this.setCalcMode(this.attributeName)}}static getSplitValue(t,e,s){return t+(e-t)*s}static convertStepTimingFunction(t,e,s,i,a,n){let r,o;switch(t){case"fill":case"stroke":const e=C.parseColor(i[a]),s=C.parseColor(i[a+1]);e&&s&&(r=[e],o=[s]);break;case"points":r=R.convertPoints(R.parseCoordinates(i[a])),o=R.convertPoints(R.parseCoordinates(i[a+1]));break;case"rotate":case"scale":case"translate":r=L.replaceMap(i[a].trim().split($.CHAR.SPACE),t=>parseFloat(t)),o=L.replaceMap(i[a+1].trim().split($.CHAR.SPACE),t=>parseFloat(t));break;default:L.isNumber(i[a])?r=[parseFloat(i[a])]:O.isLength(i[a])&&(r=[O.parseUnit(i[a],n)]),L.isNumber(i[a+1])?o=[parseFloat(i[a+1])]:O.isLength(i[a+1])&&(o=[O.parseUnit(i[a+1],n)])}if(r&&o&&r.length&&r.length===o.length){switch(e){case"step-start":e="steps(1, start)";break;case"step-end":e="steps(1, end)"}const i=/steps\((\d+)(?:, (start|end))?\)/.exec(e);if(i){const e=s[a+1]-s[a],n=parseInt(i[1]),l=100/n,h=[],c=[];for(let u=0;u<=n;u++){const f=s[a]+e*(u/n),p=l*(u+(0===u&&"start"===i[2]?1:0))/100,d=[];switch(t){case"fill":case"stroke":{const t=r[0],e=o[0],s=C.getHexCode(q.getSplitValue(t.rgba.r,e.rgba.r,p),q.getSplitValue(t.rgba.g,e.rgba.g,p),q.getSplitValue(t.rgba.b,e.rgba.b,p)),i=C.getHexCode(q.getSplitValue(t.rgba.a,e.rgba.a,p));d.push(`#${s+("FF"!==i?i:"")}`);break}case"points":for(let t=0;t<r.length;t++){const e=r[t],s=o[t];d.push(`${q.getSplitValue(e.x,s.x,p)},${q.getSplitValue(e.y,s.y,p)}`)}break;default:for(let t=0;t<r.length;t++){d.push(""+q.getSplitValue(r[t],o[t],p))}}if(!d.length)return;h.push(f),c.push(d.join(" "))}return[h,c]}}}static toFractionList(t,e=";"){let s=0;const i=L.replaceMap(t.split(e),t=>{const e=parseFloat(t);return!isNaN(e)&&e>=s&&e<=1?(s=e,e):-1});return i.length>1&&0===i[0]&&i.some(t=>-1!==t)?i:[]}setCalcMode(t){switch(B.getNamedItem(this.animationElement,"calcMode")){case"discrete":if(2===this.keyTimes.length&&0===this.keyTimes[0]){const e=[],s=[];for(let i=0;i<this.keyTimes.length-1;i++){const a=q.convertStepTimingFunction(t,"step-end",this.keyTimes,this.values,i,O.getFontSize(this.animationElement));a&&(L.concatArray(e,a[0]),L.concatArray(s,a[1]))}e.push(this.keyTimes.pop()),s.push(this.values.pop()),this.values=s,this.keyTimes=e,this._keySplines=[P["step-end"]]}break;case"spline":this.keySplines=L.flatMap(B.getNamedItem(this.animationElement,"keySplines").split(";"),t=>t.trim());case"linear":if(0!==this.keyTimes[0]&&1!==this.keyTimes[this.keyTimes.length-1]){const t=[],e=this.values.length;for(let s=0;s<e;s++)t.push(s/(e-1));this._keyTimes=t,this._keySplines=void 0}}}convertToValues(t){this.to&&(this.values=[this.from,this.to],this.keyTimes=t&&2===t.length&&0===this.keyTimes[0]&&this.keyTimes[1]<=1?t:[0,1],""===this.from&&(this.evaluateStart=!0))}isLoop(t){return!!this.loopIntervals&&!0===this.loopIntervals[t]}setGroupOrdering(t){if(this.group.ordering=t,this.fillBackwards)for(let e=t.length-1,s=!1;e>=0;e--)if(s){if("backwards"===t[e].fillMode||"both"===t[e].fillMode){this.fillBackwards=!1;break}}else t[e].name===this.group.name&&(s=!0)}getIntervalEndTime(t){const e=this.getTotalDuration();if(t<e){const s=this.duration;let i=this.delay;for(;i+s<=t;)i+=s;return Math.min(i+this.keyTimes[this.keyTimes.length-1]*this.duration,e)}return e}getTotalDuration(t=!1){const e=t&&-1===this.iterationCount?1:this.iterationCount;return-1!==e?Math.min(this.delay+this.duration*e,this.end||1/0):1/0}set delay(t){super.delay=t;const e=B.getNamedItem(this.animationElement,"end");if(e){const t=L.sortNumber(L.replaceMap(e.split(";"),t=>F.convertClockTime(t)))[0];!isNaN(t)&&(-1===this.iterationCount||this.duration>0&&t<this.duration*this.iterationCount)&&(this.delay>t?(this.end=t,-1===this.iterationCount&&(this.iterationCount=Math.ceil((this.end-this.delay)/this.duration))):this.duration=-1)}}get delay(){return super.delay}set duration(t){super.duration=t}get duration(){const t=super.duration;return-1===t&&-1!==this._repeatDuration?this._repeatDuration:t}set iterationCount(t){this._iterationCount=isNaN(t)?1:t,this.fillFreeze=-1!==this.iterationCount&&"freeze"===B.getNamedItem(this.animationElement,"fill"),1!==this.iterationCount?this.setAttribute("accumulate","sum"):this.accumulateSum=!1}get iterationCount(){return this.duration>0?-1!==this._repeatDuration&&(-1===this._iterationCount||this._repeatDuration<this._iterationCount*this.duration)?this._repeatDuration/this.duration:this._iterationCount:1}set to(t){super.to=t}get to(){return this._setterType?this.valueTo||super.to:this.setterType?this.values[0]:super.to}set values(t){this._values=t,this._keyTimes&&this._keyTimes.length!==t.length&&(this._keyTimes=void 0,this._keySplines=void 0)}get values(){return void 0===this._values&&(this._values=[]),this._values}get valueTo(){return this._values?this._values[this._values.length-1]:""}get valueFrom(){return this.values[0]||""}set keyTimes(t){!t.every(t=>t>=0&&t<=1)||void 0!==this._values&&this._values.length!==t.length||(this._keyTimes=t)}get keyTimes(){return void 0===this._keyTimes&&(this._keyTimes=[]),this._keyTimes}set keySplines(t){if(t&&t.length){const e=this.keyTimes.length-1;if(t.length>=e&&!t.every(t=>""===t||t===P.linear)){const s=[];for(let i=0;i<e;i++){const e=L.replaceMap(t[i].split(" "),t=>parseFloat(t));4===e.length&&!e.some(t=>isNaN(t))&&e[0]>=0&&e[0]<=1&&e[2]>=0&&e[2]<=1?s.push(e.join(" ")):s.push(P.linear)}this._keySplines=s}}else this._keySplines=void 0}get keySplines(){return this._keySplines}set timingFunction(t){this._timingFunction=t}get timingFunction(){return this._timingFunction||this.keySplines&&this.keySplines[0]}set reverse(t){if(t!==this._reverse&&this.length){this.values.reverse();const e=[];for(const t of this.keyTimes)e.push(1-t);if(e.reverse(),this.keyTimes=e,this._keySplines){const t=[];for(let e=this._keySplines.length-1;e>=0;e--){const s=L.replaceMap(this._keySplines[e].split(" "),t=>parseFloat(t));t.push(4===s.length?`${I(s[2])} ${I(s[3])} ${I(s[0])} ${I(s[1])}`:P.linear)}this._keySplines=t}this._reverse=t}}get reverse(){return this._reverse}get playable(){return!this.paused&&this.keyTimes&&this.keyTimes.length>1&&this.duration>0}get fillReplace(){return super.fillReplace||-1===this.iterationCount}get fromToType(){return 2===this.keyTimes.length&&0===this.keyTimes[0]&&1===this.keyTimes[1]}get partialType(){return this.keyTimes.length>1&&this.keyTimes[this.keyTimes.length-1]<1}set setterType(t){this._setterType=t}get setterType(){return this._setterType||null!==this.animationElement&&0===this.duration&&this.keyTimes.length>=2&&0===this.keyTimes[0]&&""!==this.values[0]}get length(){return this._values?this._values.length:0}get instanceType(){return 16392}}const z=squared.lib.dom,X=squared.lib.util;class Y extends q{static toRotateList(t){const e=[];for(const s of t)if(""===s)e.push([0,0,0]);else{const t=R.parseCoordinates(s);if(1===t.length&&(t[1]=0,t[2]=0),3!==t.length)return;e.push(t)}return e}static toScaleList(t){const e=[];for(const s of t)if(""===s)e.push([1,1,0,0]);else{const t=R.parseCoordinates(s);if(1===t.length&&(t[1]=t[0]),2===t.length&&(t[2]=0,t[3]=0),4!==t.length)return;e.push(t)}return e}static toTranslateList(t){const e=[];for(const s of t)if(""===s)e.push([0,0]);else{const t=R.parseCoordinates(s);if(1===t.length&&(t[1]=0),2!==t.length)return;e.push(t)}return e}static toSkewList(t){const e=[];for(const s of t)if(""===s)e.push([0]);else{const t=R.parseCoordinates(s);if(1!==t.length)return;e.push(t)}return e}constructor(t,e){if(super(t,e),e){const t=z.getNamedItem(e,"type");this.setType(t),this.setCalcMode(t)}}expandToValues(){if(this.additiveSum&&-1!==this.iterationCount&&this.keyTimes.length&&this.duration>0){const t=this.duration*this.iterationCount;t:{const e=[],s=[],i=[];let a;for(let n=0;n<this.iterationCount;n++){n>0&&this.keySplines&&i.push("");for(let r=0;r<this.keyTimes.length;r++){const o=X.replaceMap(this.values[r].split(" "),t=>parseFloat(t));if(!o.every(t=>!isNaN(t)))break t;{let l;switch(this.type){case SVGTransform.SVG_TRANSFORM_TRANSLATE:1===o.length?l=[o[0],0]:2===o.length&&(l=o);break;case SVGTransform.SVG_TRANSFORM_SCALE:1===o.length?l=[o[0],o[0]]:2===o.length&&(l=o);break;case SVGTransform.SVG_TRANSFORM_ROTATE:1===o.length?l=[o[0],0,0]:3===o.length&&(l=o);break;case SVGTransform.SVG_TRANSFORM_SKEWX:case SVGTransform.SVG_TRANSFORM_SKEWY:1===o.length&&(l=o)}if(!l)break t;{let o=(this.keyTimes[r]+n)*this.duration;if(a)for(let t=0;t<l.length;t++)l[t]+=a[t];n<this.iterationCount-1&&r===this.keyTimes.length-1&&(this.accumulateSum&&(a=l),o--),e.push(o/t),s.push(l.join(" ")),this.keySplines&&r<this.keyTimes.length-1&&i.push(this.keySplines[r])}}}}this.keyTimes=e,this.values=s,this.keySplines=i.length?i:void 0,this.duration=t,this.iterationCount=1,this.accumulateSum=!1}}}setType(t){let e;switch(t){case"translate":this.type=SVGTransform.SVG_TRANSFORM_TRANSLATE,this.animationElement&&(e=Y.toTranslateList(this.values));break;case"scale":this.type=SVGTransform.SVG_TRANSFORM_SCALE,this.animationElement&&(e=Y.toScaleList(this.values));break;case"rotate":this.type=SVGTransform.SVG_TRANSFORM_ROTATE,this.animationElement&&(e=Y.toRotateList(this.values));break;case"skewX":this.type=SVGTransform.SVG_TRANSFORM_SKEWX,this.animationElement&&(e=Y.toSkewList(this.values));break;case"skewY":this.type=SVGTransform.SVG_TRANSFORM_SKEWY,this.animationElement&&(e=Y.toSkewList(this.values));break;default:return}e&&(this.values=X.replaceMap(e,t=>t.join(" "))),this.baseValue=h.typeAsValue(this.type)}get instanceType(){return 81928}}const D=squared.lib.util;class W{static getGroupEndTime(t){return"infinite"===t.iterationCount?1/0:t.delay+t.duration*parseInt(t.iterationCount)}static getKeyName(t){return t.attributeName+(R.asAnimateTransform(t)?`:${h.typeAsName(t.type)}`:"")}constructor(t,...e){t=(e.length?D.filterArray(t,t=>e.includes(t.attributeName)):t.slice(0)).sort((t,e)=>t.delay===e.delay?t.group.id<e.group.id?1:-1:t.delay<e.delay?-1:1),e.length=0;for(const s of t){const t=W.getKeyName(s);e.includes(t)||e.push(t)}this.map={};const s={},i={};function a(t,e,a,n=0,r,o=!1,l=!1,h=0,c=!1,u){a&&(void 0===s[t][e]&&(s[t][e]=[]),s[t][e].push({time:e,value:a,animation:r,start:o,end:l,endTime:n,fillMode:h,infinite:c,valueFrom:u}),i[t].add(e))}for(const r of e){this.map[r]=new Map,s[r]={},i[r]=new Set;const e=-1!==(n=r).indexOf(":")?n.split(":")[0]:n,o=t.filter(t=>t.fillBackwards&&t.attributeName===e).sort((t,e)=>t.group.id<e.group.id?1:-1)[0];o&&a(r,0,o.values[0],o.delay,o,0===o.delay,!1,8)}var n;for(const e of t){const t=W.getKeyName(e);if(void 0===s[t][-1]&&e.baseValue&&a(t,-1,e.baseValue),e.setterType){const s=e.fillReplace&&e.duration>0;a(t,e.delay,e.to,s?e.delay+e.duration:0,e,s,!s,2),s&&a(t,e.delay+e.duration,"",0,e,!1,!0,2)}else if(R.isAnimate(e)&&e.duration>0){const s=-1===e.iterationCount,i=e.getTotalDuration();a(t,e.delay,e.valueTo,i,e,!0,!1,0,s,e.valueFrom),s||e.fillReplace||a(t,i,e.valueTo,0,e,!1,!0,e.fillForwards?4:2)}}for(const t in s)for(const e of D.sortNumber(Array.from(i[t]))){const i=s[t][e];for(let e=0;e<i.length;e++){const s=i[e];if(""===s.value||s.start&&s.animation&&R.isAnimate(s.animation)&&s.animation.evaluateStart){let a;for(const e of this.map[t].values())for(const t of e)if(s.animation!==t.animation&&""!==t.value&&(-1===t.time||4===t.fillMode||2===t.fillMode)){a=t.value;break}a?s.value=a:""===s.value&&i.splice(e--,1)}}i.length&&(i.sort((t,e)=>t.animation&&e.animation?t.fillMode===e.fillMode?t.animation.group.id<e.animation.group.id?1:-1:t.fillMode<e.fillMode?1:-1:0),this.map[t].set(e,i))}for(const t in this.map)for(const[e,s]of this.map[t].entries())for(const i of s)if(i.animation)if(2===i.fillMode){const s=[];for(const[a,n]of this.map[t].entries())if(a<e)for(const t of n)t.start&&t.animation&&t.animation.animationElement&&s.push(t.animation);else if(a>e)for(let t=0;t<n.length;t++){const e=n[t];e.end&&s.includes(e.animation)&&n.splice(t--,1)}else for(let t=0;t<n.length;t++){const e=n[t];e.end&&e.animation&&e.animation.animationElement&&e.animation.group.id<i.animation.group.id&&n.splice(t--,1)}}else if(4===i.fillMode||i.infinite){let s=!1;if(i.animation.group.ordering){const t=i.animation.getTotalDuration();for(const e of i.animation.group.ordering)if(e.name===i.animation.group.name)s=!0;else if(W.getGroupEndTime(e)>=t)break}const a=[];for(const[n,r]of this.map[t].entries())if(!s&&n<e)for(const t of r)t.start&&t.animation&&a.push(t.animation);else if(n>e)for(let t=0;t<r.length;t++){const e=r[t];(s||e.animation&&(e.end&&a.includes(e.animation)||null===i.animation.animationElement&&e.animation.group.id<i.animation.group.id))&&r.splice(t--,1)}else for(let t=0;t<r.length;t++){const e=r[t];e.end&&e.animation&&e.animation.group.id<i.animation.group.id&&r.splice(t--,1)}}for(const t in this.map)for(const[e,s]of Array.from(this.map[t].entries()))0===s.length&&this.map[t].delete(e)}has(t,e,s){if(void 0!==e){if(this.map[t]&&this.map[t].has(e)){if(void 0===s)return!0;return-1!==this.map[t].get(e).findIndex(t=>t.animation===s)}return!1}return void 0!==this.map[t]}get(t,e,s=!1){let i;if(this.map[t])for(const[a,n]of this.map[t].entries()){if(!(a<=e))break;for(const t of n)if(""!==t.value&&(-1===t.time||t.end&&(4===t.fillMode||2===t.fillMode))||s&&t.start&&e!==a){i=t.value;break}}return i}paused(t,e){let s=0;if(this.map[t])for(const[i,a]of this.map[t].entries()){if(!(i<=e))break;for(const t of a)if(t.start&&(t.infinite||0===t.fillMode&&t.endTime>e)){if(!t.animation){s=1;break}s=2}else if(t.end&&(4===t.fillMode||1===s&&2===t.fillMode)){s=0;break}}return 0===s}evaluateStart(t,e){if(t.evaluateStart){const s=this.get(t.attributeName,t.delay)||e&&""+e||t.baseValue;s&&(t.reverse?t.values[t.values.length-1]=s:t.values[0]=s),t.evaluateStart=!1}return t.values}}const U=squared.lib.math,H=squared.lib.regex,j=squared.lib.util,K=["x1","y1","x2","y2"],Z=["width","height","x","y"],Q=["points"],J=["cx","cy","r"],tt=["cx","cy","rx","ry"];function et(t,e,s,i,a){let n,r,o,l=0;for(const[e,i]of t.entries()){if(s===e){r={key:e,value:i};break}if(s>l&&s<e&&void 0!==n){r={key:l,value:n},o={key:e,value:i};break}l=e,n=i}if(r&&o)dt(t,s,ut(s,r.key,r.value,o.key,o.value),!0);else if(r)dt(t,s,r.value,!0);else if(!a){let a=i.get(e,s,!0);a&&""!==(a=it(a,!0))&&dt(t,s,a)}}function st(t){const e=t[t.length-1][0],s=new Set;for(let i=0;i<t.length;i++){let a=t[i][0]/e;if(a>0)for(let t=7;;t++){const e=parseFloat((""+a).substring(0,t));if(!s.has(e)){a=e;break}}t[i][0]=a,s.add(a)}return t}function it(t,e=!1){return"string"==typeof t&&(j.isNumber(t)?t=parseFloat(t):0===(t=R.parsePoints(t)).length&&(t="")),e&&"string"==typeof t?"":t}function at(t,e){let s;if(t)for(const i of t){if(!(i.time<=e))break;s=i.value}return s}function nt(t,e,s,i,a){const n=[],r=e.element.tagName;let o;switch(r){case"line":o=K;break;case"rect":o=Z;break;case"polyline":case"polygon":o=Q;break;case"circle":o=J;break;case"ellipse":o=tt;break;default:return}const l=h.origin(e.element);for(let h=0;h<t.length;h++){const c=t[h][0],u=t[h][1],f=[];for(const t of o){let s=u.get(t);if(void 0===s&&(void 0===s&&(s=at(i[t],c)),void 0===s&&(s=e.getBaseValue(t))),void 0===s)return;f.push(s)}let p;switch(r){case"line":p=rt(f);break;case"rect":p=ot(f);break;case"polygon":case"polyline":p=f[0];break;case"circle":case"ellipse":p=bt(f)}if(p){let t;switch(e.transformed&&(p=R.applyTransforms(e.transformed,p,l)),s&&s.refitPoints(p),r){case"line":case"polyline":t=R.drawPolyline(p,a);break;case"rect":case"polygon":t=R.drawPolygon(p,a);break;case"circle":case"ellipse":const i=p[0];t=R.drawEllipse(i.x,i.y,i.rx,i.ry,a)}void 0!==t&&n.push({key:c,value:t})}}return n}function rt(t){return[{x:t[0],y:t[1]},{x:t[2],y:t[4]}]}function ot(t){const e=t[0],s=t[1],i=t[2],a=t[3];return[{x:i,y:a},{x:i+e,y:a},{x:i+e,y:a+s},{x:i,y:a+s}]}function lt(t,e,s){const i=new Map;for(const a of e){const e=new Map;for(const i in t){let n;void 0!==(n=t[i].has(a)?t[i].get(a):at(s[i],a))&&e.set(i,n)}i.set(a,e)}return i}function ht(t,e,s,i){e&&(t.set(s,e),void 0!==i&&t.set(i,e))}function ct(t,e,s,i,a){switch(t.alternate&&s%2!=0&&(e=e.slice(0).reverse()),t.attributeName){case"transform":if(t.additiveSum&&"string"==typeof a){const n=j.replaceMap(a.split(H.CHAR.SPACE),t=>parseFloat(t)),r=j.objectMap(e,t=>j.replaceMap(t.trim().split(H.CHAR.SPACE),t=>parseFloat(t)));if(r.every(t=>n.length===t.length)){const e=r[i];t.accumulateSum||(s=0);for(let t=0;t<n.length;t++)e[t]+=n[t];for(let t=0;t<s;t++)for(let t=0;t<r.length;t++)for(let s=0;s<r[t].length;s++)e[s]+=r[t][s];return e.join(" ")}}return e[i];case"points":return R.parsePoints(e[i]);default:{let n=parseFloat(e[i]);if(isNaN(n))return a||0;if(t.additiveSum&&"number"==typeof a){n+=a,t.accumulateSum||(s=0);for(let t=0;t<s;t++)for(let t=0;t<e.length;t++)n+=parseFloat(e[t])}return n}}}function ut(t,e,s,i,a){if(t>e){if("number"==typeof s&&"number"==typeof a)return q.getSplitValue(s,a,(t-e)/(i-e));if("string"==typeof s&&"string"==typeof a){const n=j.replaceMap(s.split(" "),t=>parseFloat(t)),r=j.replaceMap(a.split(" "),t=>parseFloat(t));if(n.length===r.length){const s=[];for(let a=0;a<n.length;a++)s.push(ut(t,e,n[a],i,r[a]));return s.join(" ")}}else if(Array.isArray(s)&&Array.isArray(a)){const n=[];for(let r=0;r<Math.min(s.length,a.length);r++)n.push({x:ut(t,e,s[r].x,i,a[r].x),y:ut(t,e,s[r].y,i,a[r].y)});return n}}return s}function ft(t,e,s,i,a,n,r,o,l,h,c,u,f){r<0&&(e-=r,r=0);const p=Math.max(0,Math.min((e-(r+t.duration*o))/t.duration,1));let d,m=-1,g=-1;for(let t=0;t<i.length;t++){if(-1!==m&&p<=i[t]){g=t;break}p>=i[t]&&(m=t)}return mt(t,l=dt(c,l,d=-1!==m&&-1!==g?ut(p,i[m],ct(t,a,o,m,s),i[g],ct(t,a,o,g,s)):ct(t,a,o,g=-1!==m?m+1:i.length-1,s)),n,g,h,u,f),[l,d]}function pt(t,e,s,i,a,n,r){const o=e.keyTimes.slice(0),l=e.keySplines?e.keySplines.slice(0):[].fill(""),h=s+e.duration;let c=e.getIntervalEndTime(s);for(let s=0;s<r.length;s++){const f=r[s];if(f!==e){const p=f.getTotalDuration();if(p>c){const d=Math.min(h,p),m=gt(t,e,n);t:for(let t=At(c,f.delay,f.duration),s=!1;;t++)for(let i=0;i<f.keyTimes.length;i++){const r=vt(f.delay,f.duration,f.keyTimes,t,i);if(r>=c){function u(h){let u;if(r===h)u=St(ct(f,m,t,i,n));else{const e=(r-h)/f.duration;for(let s=1;s<f.keyTimes.length;s++)if(e>=f.keyTimes[s-1]&&e<=f.keyTimes[s]){u=St(ut(e,f.keyTimes[s-1],ct(f,m,t,s-1,n),f.keyTimes[s],ct(f,m,t,s,n)));break}}let p=h===d?1:h%e.duration/e.duration;0===p&&i>0&&(p=1),void 0===u||p===o[o.length-1]&&u===a[a.length-1]||(h===c?p+=.001:c=h,o.push(p),a.push(u),l&&l.push(s&&f.keySplines&&f.keySplines[i]?f.keySplines[i]:""))}if(!s&&r>=c&&(u(c),s=!0,r===c))continue;if(s){if(u(Math.min(r,d)),r>=d||1===o[o.length-1])break t;c=r}}}if(p===d&&p<=i&&(f.addState(16),r.splice(s--,1)),d===h)break}else i!==1/0&&p<i&&r.splice(s--,1)}}return[o,a,l]}function dt(t,e,s,i=!1){if(""!==s){let a=t.get(e),n=!1;if(void 0===a&&(a=t.get(e-1),n=!0),a!==s||i){if(!i){if("number"==typeof a&&U.isEqual(s,a))return e;for(;e>0&&t.has(e);)e++}t.set(e,s)}else n&&!t.has(e)&&(t.delete(e-1),t.set(e,s))}return e}function mt(t,e,s,i,a,n,r){if(!Tt(R.asAnimateTransform(t),a)){if(0===i)return;i--}const o=s&&s[i];o&&n.set(e,o),r&&function(t,e,s,i){R.asAnimateTransform(e)&&e.transformOrigin&&e.transformOrigin[i]&&t.set(s,e.transformOrigin[i])}(r,t,e,i)}function gt(t,e,s){if(e.evaluateStart){const i=e.reverse?e.length-1:0;t.get(W.getKeyName(e),e.delay)||e.values[i]||!e.additiveSum&&e.baseValue||(e.values[i]=St(s)),e.by&&j.isNumber(e.values[i])&&(e.values[i]=""+(parseFloat(e.values[i])+e.by)),e.evaluateStart=!1}return e.values}function yt(t,e,s,i){t[t.length-1]<1&&(t.push(1),e.push(void 0!==i?St(i):e[0]),s&&s.push(""))}const vt=(t,e,s,i,a)=>Math.round(t+(s[a]+i)*e),bt=t=>[{x:t[0],y:t[1],rx:t[2],ry:t[t.length-1]}],St=t=>Array.isArray(t)?j.objectMap(t,t=>`${t.x},${t.y}`).join(" "):""+t,Tt=(t,e)=>j.hasBit(e,t?32:4),kt=(t,e)=>j.hasBit(e,t?16:2),xt=t=>t.playable||t.animationElement&&-1!==t.duration,Rt=t=>[t.keyTimes.slice(0),t.values.slice(0),t.keySplines?t.keySplines.slice(0):void 0],At=(t,e,s)=>Math.floor(Math.max(0,t-e)/s);var wt=t=>(class extends t{getAnimateShape(t,e){void 0===e&&(e=this.animations);const s=[];for(const i of e)if(xt(i))switch(i.attributeName){case"r":case"cx":case"cy":if(c.circle(t)){s.push(i);break}case"rx":case"ry":c.ellipse(t)&&s.push(i);break;case"x1":case"x2":case"y1":case"y2":c.line(t)&&s.push(i);break;case"points":(c.polyline(t)||c.polygon(t))&&s.push(i);break;case"x":case"y":case"width":case"height":c.rect(t)&&s.push(i)}return s}getAnimateViewRect(t){void 0===t&&(t=this.animations);const e=[];for(const s of t)if(xt(s))switch(s.attributeName){case"x":case"y":e.push(s)}return e}getAnimateTransform(t){return void 0===t&&(t=this.animations),j.filterArray(t,t=>R.asAnimateTransform(t)&&t.duration>0)}animateSequentially(t,e,s,i){let a,n=18;i&&(i.keyTimeMode&&(n=i.keyTimeMode),a=i.precision),[t,e].forEach(t=>{const i=t===e;if(!t||0===t.length||!i&&j.hasBit(n,8)||i&&j.hasBit(n,64))return;const r=[],o={},l=new Set;let c=0;function u(t){void 0===o[t.attributeName]&&(o[t.attributeName]=[]),o[t.attributeName].push(t),c++}{const e=[];for(let s=0;s<t.length;s++){const i=t[s];if(i.setterType)u(i);else{const a=i.getTotalDuration();for(let n=0;n<t.length;n++){const r=t[n];if(s!==n&&i.attributeName===r.attributeName&&i.group.id<r.group.id&&i.fillReplace&&!r.partialType)if(r.setterType){if(i.delay===r.delay){e[s]=i;break}}else{const t=r.getTotalDuration();if(i.delay===r.delay&&(!r.fillReplace||a<=t||-1===r.iterationCount)||r.fillBackwards&&i.delay<=r.delay&&(r.fillForwards||i.fillReplace&&a<=r.delay)||i.animationElement&&null===r.animationElement&&(i.delay>=r.delay&&a<=t||r.fillForwards)){e[s]=i;break}}}}}const s=[];for(let i=0;i<t.length;i++){const a=t[i];e[i]?a.fillReplace?s.push(a):(a.setterType=!0,u(a)):a.setterType||(r.push(a),l.add(a.group.name))}this._removeAnimations(s)}if(r.length+c>1||1===r.length&&(r[0].alternate||void 0!==r[0].end)){for(const t of r)t.group.ordering&&j.spliceArray(t.group.ordering,t=>!l.has(t.name));const e={},c={};let u=0;for(const t of r){const s=t.attributeName;void 0===e[s]&&(e[s]=new Map,c[s]=[]);const i=e[s].get(t.delay)||[];i.push(t),c[s].push(t),e[s].set(t.delay,i)}for(const t in e){const s=new Map;for(const i of j.sortNumber(Array.from(e[t].keys()))){const a=e[t].get(i);for(const t of a)u=Math.max(u,t.getTotalDuration(!0));a.reverse(),s.set(i,a)}e[t]=s,c[t].reverse()}const V=new W(t),_={},E=new Map,N=i?new Map:void 0,M={},F=new Set,P={},G=new Map,C=i?new Map:void 0,O={},B={},$=new Map;let L,I,z=-1;function f(t){return B[t]?B[t][B[t].length-1]:void 0}for(const t in e){if(_[t]=new Map,!i){let e;try{e=(s||this).getBaseValue(t)}catch(t){}j.hasValue(e)&&(O[t]=e)}const a=o[t]||[],r=[],l=[];for(const[s,i]of e[t].entries())r.push(s),l.push(i);const G=[];let C,L,I,q=-1,z=0,X=1/0;function p(e,s){if(F.add(e),e.addState(16),I=e,e.fillForwards){if(T(z,C,e.type,e),e.group.ordering){const t=e.getTotalDuration();for(const s of e.group.ordering){if(s.name===e.group.name)return!0;if(W.getGroupEndTime(s)>=t)return!1}}}else{if(e.fillFreeze&&T(z,C,e.type,e),void 0!==s){let a=q;const n=g(z,z+1);void 0!==n&&e.fillReplace&&s>z&&0===G.length&&(a=dt(_[t],a,n),i&&ht($,e.type,a),C=n,q=a)}y()}return!1}function d(e,s,a){return void 0===s&&(s=e.delay),void 0===a&&(a=e.to),dt(_[t],s,i?a:it(a))}function m(t){t&&a.push(t),a.sort((t,e)=>t.delay===e.delay?t.group.id<e.group.id?-1:1:t.delay<e.delay?-1:1);for(let t=0;t<a.length-1;t++)a[t].delay===a[t+1].delay&&a.splice(t--,1)}function g(e,s){const n=f(t);let r=n&&n.value;return j.spliceArray(a,t=>t.delay>=e&&t.delay<s,t=>{t.animationElement&&S(),0===G.length&&(C=t.to),T(t.delay,t.to,t.type,t),t.delay===e?r=i?t.to:it(t.to):(q=d(t),z=t.delay)}),r}function y(t,e){G.length&&j.spliceArray(G,t=>t.getTotalDuration()<=z,s=>{if(s.addState(16),s.fillForwards&&(T(s.getTotalDuration(),s.valueTo,s.type,s),void 0!==t&&void 0!==e))for(let i=t;i<r.length;i++){i!==t&&(e=-1);for(let t=e+1;t<l[i].length;t++){const e=l[i][t];s.group.id>e.group.id&&e.addState(16)}}})}function v(t){t.hasState(16,64)||(t.addState(4),G.push(t))}function b(){G.sort((t,e)=>t.animationElement&&e.animationElement&&t.delay!==e.delay?t.delay<e.delay?1:-1:t.group.id<e.group.id?1:-1)}function S(t){j.spliceArray(G,t?e=>e===t:t=>null!==t.animationElement)}function T(e,s,n=0,r){i||(s=it(s));const o=f(t);if(""!==s&&(void 0===o||e>=o.time)&&(void 0===B[t]&&(B[t]=[]),B[t].push({key:n,value:s,time:e})),r&&R.isAnimate(r)&&!r.fillReplace)if(r.fillForwards){j.spliceArray(a,t=>t.group.id<r.group.id||t.delay<e),G.length=0;for(const t of l)for(const e of t)e.group.id<r.group.id&&e.addState(16)}else r.fillFreeze&&S()}function k(e,s,i){L&&!e&&(void 0===i&&(i=h.typeAsValue(L.type)),s!==(q=dt(_[t],s,i))&&ht($,L.type,q)),L=void 0}function x(t){for(let e=0;e<r.length;e++){if(t.length)for(let s=0;s<l[e].length;s++)t.includes(l[e][s])&&l[e].splice(s--,1);0===l[e].length&&(l.splice(e,1),r.splice(e--,1))}}const Y=c[t].find(t=>t.fillBackwards);if(Y){C=ct(Y,Y.values,0,0),q=dt(_[t],0,C),i&&(ht($,Y.type,0),L=Y);let e=!0;for(const s of c[t])if(s.group.id>Y.group.id&&s.delay<=Y.delay){e=!1;break}const s=Y.getTotalDuration(),n=[];for(let t=0;t<r.length;t++)for(let i=0;i<l[t].length;i++){const o=l[t][i];if(e){if(o===Y&&(0!==t||0!==i)){l[t].splice(i--,1),r.unshift(Y.delay),l.unshift([Y]);continue}if(o.group.id<Y.group.id&&(Y.fillForwards||o.getTotalDuration()<=s)){o.fillForwards&&(o.setterType=!0,a.push(o)),n.push(o);continue}}o.animationElement&&o.delay<=Y.delay&&(l[t].splice(i--,1),v(o))}x(n),Y.addState(2)}if(!i&&(void 0===B[t]&&void 0!==O[t]&&T(0,O[t],0),void 0===C)){const e=f(t);C=e&&e.value||O[t]}m();{let e;j.spliceArray(a,t=>t.delay<=r[0],s=>{const a=R.isAnimate(s)&&s.fillForwards;if(s.delay<r[0]&&(void 0===Y||a))if(Y&&a)T(s.delay,s.to,s.type);else{const a=s.delay-1;if(void 0===e)if(_[t].has(0))i||d(s,a,C);else{let e;void 0!==(e=i&&R.asAnimateTransform(s)?h.typeAsValue(s.type):O[t])&&(d(s,0,e),d(s,a,e))}else d(e,a);q=d(s),z=s.delay,e=s}}),e&&d(e,r[0]-1)}t:{for(let e=0;e<r.length;e++){let s=r[e];for(let o=0;o<l[e].length;o++){const c=l[e][o];if(c.hasState(16,64))continue;const x=-1===c.iterationCount,R=c.duration,w=c.iterationCount;let M,F,B;if(x)M=s+R;else if((M=c.getTotalDuration())<=q){c.fillReplace?c.addState(64):v(c);continue}if(x?(F=Math.ceil((u-s)/R),B=0):(F=Math.ceil(w),B=w-Math.floor(w)),a.length&&z>0&&z<s&&g(z,s),-1!==q&&q<s&&(q=dt(_[t],s-1,C),z=s),X=1/0,c.group.ordering&&c.group.ordering.length>1){let s=!0;for(const e of c.group.ordering){if(e.name===c.group.name){s=!1;break}if(!e.paused&&z<=e.delay&&e.attributes.includes(t))break}if(s)e:for(let t=e+1;t<r.length;t++)for(let e=0;e<l[t].length;e++){const s=l[t][e];if(s.group.ordering){X=s.delay;break e}s.getTotalDuration()<=M?(s.fillFreeze&&m(s),s.addState(16)):s.delay<M&&v(s)}}else for(let t=e+1;t<r.length;t++)if(r[t]!==1/0&&l[t].length&&!l[t].every(t=>t.hasState(16,64))){X=r[t];break}const I=z;let Y,D=q+1,W=Math.min(X,c.end||1/0);if(a.length&&c.animationElement){const t=Math.min(X,M,W);if(Y=a.find(e=>e.delay>=z&&e.delay<=t)){switch(Y.delay){case z:T(z,C=Y.to,Y.type,Y),Y.group.id>c.group.id&&(i&&L&&k(c.additiveSum,Math.max(s-1,q)),q=d(Y,Math.max(Y.delay,q),C),W=-1);break;case X:Y.addState(32);break;default:W=Y.delay,Y.addState(32)}j.spliceArray(a,t=>t!==Y),c.addState(4)}}let U,H=!1;if(W>q){i&&(L&&(k(c.additiveSum,Math.max(s-1,q)),D=q+1),C=h.typeAsValue(c.type),T(z,C,c.type));let a=r[e]===1/0||(-1!==q||c.hasState(2))&&!(0===e&&0===o);H=!0;e:{const i=f(t);for(let r=At(z,s,R);r<F;r++){let h,u,f=gt(V,c,C);if(c.partialType){if(c.getIntervalEndTime(z)<W&&(G.length||o<l[e].length-1)){for(let t=o+1;t<l[e].length;t++)v(l[e][t]);l[e].length=0,b(),[h,f,u]=pt(V,c,z,W,f,C,G)}else[h,f,u]=Rt(c);yt(h,f,u,O[t])}else h=c.keyTimes,u=c.keySplines;for(let e=0;e<h.length;e++){const o=h[e];let l=-1,p=ct(c,f,r,e,C);if(r===F-1&&B>0)if(B===o)B=-1;else if(e===h.length-1)z=l=M,p=ut(B,h[e-1],ct(c,f,r,e-1,C),o,p),B=-1;else if(B>o)for(let t=e+1;t<h.length;t++)if(B<=h[t]){z=l=M,p=ut(B,o,p,h[t],ct(c,f,r,t,C)),B=-1;break}if(-1===l){if((l=vt(s,R,h,r,e))<0||l<q)continue;if(l===W)H=r===F-1&&e===h.length-1,z=l;else{function A(e){[q,U]=ft(c,z,C,h,f,u,s,r,e,n,_[t],E,N)}if(s<0&&-1===q)l>0&&(z=0,A(0));else{if(l>W){a&&q+1<W&&A(q),z=W,A(W+(W!==X||_[t].has(W-1)?0:-1)),H=!1;break e}if(a)c.hasState(2)&&(z=I),s>=q?(l=Math.max(s,q+1),z=s):l===q?(z=l,l=q+1):(A(q),z=Math.max(l,q)),a=!1;else{if(z=l,r>0&&0===e&&c.accumulateSum){mt(c,l,u,e,n,E,N),q=l;continue}l=Math.max(l,q+1)}}}}if(l>q&&(e===h.length-1&&!c.accumulateSum&&(r<F-1||c.fillReplace&&(void 0===i||p!==i.value))&&l--,q=dt(_[t],l,p),mt(c,q,u,e,n,E,N),U=p),!H||-1===B)break e}}}y(e,o)}if(void 0!==U&&(C=U,i&&(ht($,c.type,D,q),L=c)),Y&&(Y.hasState(32)?(q=d(Y,Y.delay,U=Y.to),T(z=Y.delay,U,Y.type,Y)):c.hasState(64)&&ht($,q,Y.type),S(),H=!0),j.spliceArray(a,t=>t.delay>=I&&t.delay<=z,t=>{T(t.delay,t.to,t.type,t),t.animationElement&&S()}),x){if(!H){G.length=0,G.push(c);continue}if(void 0===Y){P[t]=c;break t}}if(H){if(!x&&p(c,X))break t;for(let t=e;t<r.length;t++)if(r[t]<z){for(let e=0;e<l[t].length;e++){const s=l[t][e],i=s.getTotalDuration();i>z&&!s.hasState(4,16,64)?v(s):s.fillReplace||T(i,s.valueTo,s.type,s)}r[t]=1/0,l[t].length=0}if(G.length&&z<X){b();const t=G.find(t=>t.delay<=z);t&&(t.removeState(4,2),t.addState(8),S(t),s=t.delay,l[e]=[t],o=-1)}}else v(c)}}if(G.length){b();for(let e=0;e<G.length;e++){const s=G[e],a=s.delay,r=s.duration,o=q-a;let l=1/0;function w(){let h,c,u=gt(V,s,C);s.partialType?(s.getIntervalEndTime(z)<l&&e<G.length-1?[h,u,c]=pt(V,s,z,l,u,C,G):[h,u,c]=Rt(s),yt(h,u,c,O[t])):(h=s.keyTimes,c=s.keySplines);const f=q+1;let p=Math.floor(o/r),d=!1;function m(e){return ft(s,z,C,h,u,c,a,p,e,n,_[t],E,N)}do{for(let e=0;e<h.length;e++){let i=vt(a,r,h,p,e);!d&&i>=q&&([q,C]=m(q),d=!0),d&&(i>=l?l>q&&([q,C]=m(l),z=l):i>q&&(z=i,e===h.length-1&&i<l&&i--,C=ct(s,u,p,e,C),q=dt(_[t],i,C),mt(s,q,c,e,n,E,N)))}}while(q<l&&++p);i&&ht($,s.type,f,q)}if(-1===s.iterationCount){o>0&&o%s.duration!=0&&(l=a+s.duration*Math.ceil(o/r),w()),P[t]=s;break t}if((l=Math.min(a+s.duration*s.iterationCount,s.end||1/0))>q&&(w(),p(s)))break t}}if(I&&I.fillReplace&&void 0===P[t]){let e,s=0;if(B[t]){const i=f(t);i&&(s=i.key,e=i.value)}else i?(s=Array.from($.values()).pop(),e=h.typeAsValue(s)):e=O[t];void 0===e||j.isEqual(_[t].get(q),e)||(q=dt(_[t],q,e),i&&ht($,s,q))}}M[t]=q}{const t=new Set;let e=0;for(const s in _){let i=0;for(const e of _[s].keys())t.add(e),i=e;e=Math.max(e,i),B[s]&&B[s].sort((t,e)=>t.time===e.time?0:t.time<e.time?-1:1)}if(Object.keys(P).length){const s=[],i=[];for(const t in P)s.push(P[t].delay),i.push(P[t].duration);0===F.size&&1===new Set(s).size&&1===new Set(i).size&&s[0]===t.values().next().value?z=s[0]<=0?0:s[0]:i.length>1&&i.every(t=>t%250==0)?e=U.nextMultiple(i,e,s):(e-s[0])%i[0]!=0&&(e=i[0]*Math.ceil(e/i[0]))}if(-1===z)for(const s in _)if(P[s]){let a=M[s];if(a<e){const r=P[s],o=r.delay,l=a+1;let h=Array.from(_[s].values()).pop(),c=Math.floor((a-o)/r.duration);const u=gt(V,r,h);do{let i=!1;for(let l=0;l<r.keyTimes.length;l++){let f=vt(o,r.duration,r.keyTimes,c,l);!i&&f>=a&&([a,h]=ft(r,a,h,r.keyTimes,u,r.keySplines,o,c,a,n,_[s],E,N),t.add(a),i=!0),i&&f>a&&(l===r.keyTimes.length-1&&f<e&&f--,h=ct(r,u,c,l,h),a=dt(_[s],f,h),mt(r,f,r.keySplines,l,n,E,N),t.add(a))}}while(a<e&&++c);M[s]=a,i&&ht($,r.type,l,a)}}const a=j.sortNumber(Array.from(t));if(s||i){let t=!1;for(const e in _)if(!_[e].has(0)&&void 0!==O[e]){const s=_[e].keys().next().value-1;_[e].set(0,O[e]),_[e].set(s,O[e]),a.includes(0)||(a.push(0),t=!0),a.includes(s)||(a.push(s),t=!0)}t&&j.sortNumber(a)}if(!i)for(const t in _)for(const e of a){if(!(e<=M[t]))break;if(!_[t].has(e)){if(V.paused(t,e)){let s=V.get(t,e);if(s&&""!==(s=it(s,!0))){_[t].set(e,s);continue}}et(_[t],t,e,V,i)}}L=lt(_,a,B)}if(-1===z&&Object.keys(P).length){const t={},e=[],s=[],a=[];for(const t in P)a.push(P[t].duration),e.push(P[t]);const r=U.nextMultiple(a);for(const i of e){const e=i.attributeName;t[e]=new Map;let a=_[e].has(M[e])?_[e].get(M[e]):O[e];const o=gt(V,i,a);let l=0,h=0;do{for(let c=0;c<i.keyTimes.length;c++){let u=vt(0,i.duration,i.keyTimes,h,c);c===i.keyTimes.length-1&&u<r&&u--,a=ct(i,o,h,c,a),mt(i,l=dt(t[e],u,a),i.keySplines,c,n,G,C),s.includes(l)||s.push(l)}}while(l<r&&++h)}if(e.every(t=>t.alternate)){let e=-1;for(const i in P){const a=Array.from(t[i].keys()),n=Array.from(t[i].values()).reverse();for(let o=0;o<a.length;o++)if(0!==a[o]){e=r+a[o];const l=G.get(a[o]);l&&G.set(e,l),e=dt(t[i],e,n[o]),s.includes(e)||s.push(e)}}}j.sortNumber(s);for(const e in t)for(const a of s)t[e].has(a)||et(t[e],e,a,V,i);I=lt(t,s,B)}if(L||I){this._removeAnimations(r);const t=Array.from($.entries()),e=j.joinMap(r,t=>R.asAnimateTransform(t)?h.typeAsName(t.type):t.attributeName,"-");for(const r of[L,I])if(r){const o=r===L,l=o?E:G,h=o?N:C;if(Tt(i,n)){const e=[];if(i){const s=[];if(o){const e=Array.from(r.entries());let i=t[0][1];for(let a=0,n=0,r=0;a<t.length;a++){const o=a<t.length-1?t[a+1][1]:-1;if(i!==o){const l=new Map;for(let s=r;s<e.length;s++){const o=e[s][0];if(o>=t[n][0]&&o<=t[a][0])l.set(o,new Map([[i,e[s][1].values().next().value]])),r=s;else if(o>t[a][0])break}s.push(l),i=o,n=a+1}}}else{if(!P.transform)return;{const t=Array.from(r.entries()),e=new Map;for(const s of t)e.set(s[0],new Map([[P.transform.type,s[1].values().next().value]]));s.push(e)}}let i=0;for(let t=0;t<s.length;t++){const a=Array.from(s[t].entries());let n=a[0][0];1===a.length&&a.push(t<s.length-1?[s[t+1].keys().next().value,a[0][1]]:[n+1,a[0][1]]);const r=a[a.length-1][0];let c=r-n;const u=new Y;u.attributeName="transform",u.type=a[0][1].keys().next().value;for(let t=0;t<a.length;t++){const s=a[t];if(e.push(l.get(s[0])||""),u.type!==SVGTransform.SVG_TRANSFORM_ROTATE){const e=h.get(s[0]);e&&(void 0===u.transformOrigin&&(u.transformOrigin=[]),u.transformOrigin[t]=e)}s[0]-=n}for(const[t,e]of st(a))u.keyTimes.push(t),u.values.push(e.values().next().value);(n-=i)>1?u.delay=n:1===n&&(c+1)%10==0&&c++,u.duration=c,u.keySplines=e,u.synchronized={key:t,value:""},i=r,this._insertAnimate(u,o)}}else{const t=Array.from(r.entries()),i=-1!==z?z:0;let n;for(const s of t)e.push(l.get(s[0])||""),s[0]-=i;if(s){const e=nt(st(t),s,this.parent,B,a);if(!e)return;(n=new q).attributeName="d";for(const t of e)n.keyTimes.push(t.key),n.values.push(""+t.value)}else{const t=new Y;t.attributeName="transform",t.type=SVGTransform.SVG_TRANSFORM_TRANSLATE;for(const[e,s]of r.entries()){const i=s.get("x")||0,a=s.get("y")||0;t.keyTimes.push(e),t.values.push(this.parent?`${this.parent.refitX(i)} ${this.parent.refitX(a)}`:`${i} ${a}`)}n=t}n.delay=i,n.keySplines=e,n.duration=t[t.length-1][0],this._insertAnimate(n,o)}}else if(kt(i,n)){const n=Array.from(r.entries());for(let r=0;r<n.length-1;r++){const[c,u]=n[r],[f,p]=n[r+1];let d,m=e;if(i){const e=new Y;if(e.attributeName="transform",o)for(let s=0;s<t.length-1;s++){const i=t[s],a=t[s+1];if(i[1]===a[1]&&c>=i[0]&&f<=a[0]){e.type=i[1];break}if(f-c==1&&f===a[0]){e.type=a[1];break}}else P.transform&&(e.type=P.transform.type);if(0===e.type)continue;e.values=[u.values().next().value,p.values().next().value];const s=h.get(f);s&&(e.transformOrigin=[s]),d=e}else if(s){const t=nt([[c,u],[f,p]],s,this.parent,B,a);if(!t)continue;(d=new q).attributeName="d",d.values=j.replaceMap(t,t=>""+t.value)}else{const t=new Y;t.attributeName="transform",t.type=SVGTransform.SVG_TRANSFORM_TRANSLATE,t.values=j.objectMap([u,p],t=>{const e=t.get("x")||0,s=t.get("y")||0;return this.parent?`${this.parent.refitX(e)} ${this.parent.refitX(s)}`:`${e} ${s}`}),m+=r,d=t}o&&(d.delay=0===r?c:0),d.duration=f-c,d.keyTimes=[0,1],d.synchronized={key:r,value:m};const g=l.get(f);g&&(d.keySplines=[g]),this._insertAnimate(d,o)}}}}}})}_removeAnimations(t){t.length&&j.spliceArray(this.animations,e=>t.includes(e))}_insertAnimate(t,e){e||(t.iterationCount=-1),t.from=t.valueFrom,t.to=t.valueTo,this.animations.push(t)}});const Vt=squared.lib.dom,_t=squared.lib.util;class Et extends q{constructor(t,e){if(super(t,e),this.path="",this.motionPathElement=null,this.rotate=0,this.rotateAuto=!1,this.rotateAutoReverse=!1,e){this.setAttribute("path");const t=Vt.getNamedItem(e,"rotate");switch(t){case"auto":this.rotateAuto=!0;break;case"auto-reverse":this.rotateAutoReverse=!0;break;default:this.rotate=_t.convertInt(t)}if(this.keyTimes.length){const t=Vt.getNamedItem(e,"keyPoints");if(""!==t){const e=q.toFractionList(t);e.length===this.keyTimes.length&&(this.keyPoints=e)}}for(let t=0;t<e.children.length;t++){const s=e.children[t];if("mpath"===s.tagName){const t=m(s);if(t&&(c.shape(t)||c.use(t))){this.motionPathElement=t;break}}}}}get instanceType(){return 49160}}const Nt=squared.lib.css,Mt=squared.lib.dom,Ft=squared.lib.regex,Pt=squared.lib.util,Gt=`cubic-bezier\\((0(?:\\.\\d+)?|1(?:\\.0+)?), (${Ft.UNIT.DECIMAL}), (0(?:\\.\\d+)?|1(?:\\.0+)?), (${Ft.UNIT.DECIMAL})\\)`,Ct=RegExp(`(ease|ease-in|ease-out|ease-in-out|linear|step-(?:start|end)|steps\\(\\d+, (?:start|end)\\)|${Gt}),?\\s*`,"g"),Ot=Nt.getKeyframeRules(),Bt={"animation-delay":"0s","animation-duration":"0s","animation-iteration-count":"1","animation-play-state":"running","animation-direction":"normal","animation-fill-mode":"none","animation-timing-function":"ease"};function $t(t,e,s){t.style[e]=s,t.setAttribute(e,s)}function Lt(t,e){const s=f(t,e);if("animation-timing-function"===e){const t=[];let e;for(;null!==(e=Ct.exec(s));)t.push(e[1]);return t}return s.split(Ft.XML.SEPARATOR)}const It=t=>t.sort((t,e)=>t.key>=e.key?1:-1);var qt=t=>(class extends t{getTransforms(t){const e=t||this.element;return R.filterTransforms(h.parse(e)||R.convertTransforms(e.transform.baseVal))}getAnimations(t){const e=t||this.element,s=[];let i=0;function a(t,e,a=""){""===a&&i++,t.delay=e,t.group={id:i,name:a},s.push(t)}for(let t=0;t<e.children.length;t++){const s=e.children[t];if(s instanceof SVGAnimationElement){const t=Mt.getNamedItem(s,"begin");if(""!==t&&/^[a-zA-Z]+$/.test(t))continue;const i=t?Pt.sortNumber(Pt.replaceMap(t.split(";"),t=>F.convertClockTime(t))):[0];if(i.length)switch(s.tagName){case"set":for(const t of i)a(new F(e,s),t);break;case"animate":for(const t of i)a(new q(e,s),t);break;case"animateTransform":for(const t of i){const i=new Y(e,s);R.isShape(this)&&this.path&&(i.transformFrom=R.drawRefit(e,this.parent,this.viewport&&this.viewport.precision)),a(i,t)}break;case"animateMotion":for(const t of i)a(new Et(e,s),t)}}}const n=Lt(e,"animation-name");if(n.length){const t={},s=[],o=[];for(const s in Bt){const i=Lt(e,s);for(0===i.length&&i.push(Bt[s]);i.length<n.length;)Pt.concatArray(i,i.slice(0));i.length=n.length,t[s]=i}for(let l=0;l<n.length;l++){const c=Ot[n[l]],u=F.convertClockTime(t["animation-duration"][l]);if(c&&u>0){i++;const f={},p={},d="paused"===t["animation-play-state"][l],m=F.convertClockTime(t["animation-delay"][l]),g=t["animation-iteration-count"][l],y=t["animation-fill-mode"][l],v=`${n[l]}_${l}`,b=[];o.push({name:v,attributes:b,paused:d,delay:m,duration:u,iterationCount:g,fillMode:y});for(const t in c){const s=parseFloat(t)/100;for(const i in c[t]){const a=Bt[i]?p:f;void 0===a[i]&&(a[i]=[]);let n=c[t][i];n&&(Nt.isCalc(n)?n=Nt.calculateVar(e,n,i):Nt.isCustomProperty(n)&&(n=Nt.parseVar(e,n)),void 0!==n&&a[i].push({key:s,value:""+n}))}}if(f.transform){function r(t){const s=f["transform-origin"]&&f["transform-origin"].find(e=>e.key===t);if(s)return h.origin(e,s.value)}for(const t of It(f.transform)){const s=h.parse(e,t.value);if(s){const e=r(t.key);s.forEach(s=>{const i=s.matrix;let a,n,r;switch(s.type){case SVGTransform.SVG_TRANSFORM_TRANSLATE:a="translate",n=`${i.e} ${i.f}`;break;case SVGTransform.SVG_TRANSFORM_SCALE:a="scale",n=`${i.a} ${i.d} ${e?`${e.x} ${e.y}`:"0 0"}`,!e||0===t.key&&0===e.x&&0===e.y||(r={x:e.x*(1-i.a),y:e.y*(1-i.d)});break;case SVGTransform.SVG_TRANSFORM_ROTATE:a="rotate",n=`${s.angle} ${e?`${e.x} ${e.y}`:"0 0"}`;break;case SVGTransform.SVG_TRANSFORM_SKEWX:a="skewX",n=""+s.angle,!e||0===t.key&&0===e.y||(r={x:e.y*i.c*-1,y:0});break;case SVGTransform.SVG_TRANSFORM_SKEWY:a="skewY",n=""+s.angle,!e||0===t.key&&0===e.x||(r={x:0,y:e.x*i.b*-1});break;default:return}void 0===f[a]&&(f[a]=[]);const o=f[a].findIndex(e=>e.key===t.key);-1!==o?(f[a][o].value=n,f[a][o].transformOrigin=r):f[a].push({key:t.key,value:n,transformOrigin:r})})}}}delete f.transform,delete f["transform-origin"];for(const i in f){b.push(i);const n=f[i];let r;switch(i){case"rotate":case"scale":case"skewX":case"skewY":case"translate":(r=new Y(e)).attributeName="transform",r.setType(i);break;default:(r=new q(e)).attributeName=i}const o=t["animation-timing-function"][l],h=t["animation-direction"][l],c=[],S=[],T=[];It(n);for(let t=0;t<n.length;t++){if(c.push(n[t].key),S.push(n[t].value),t<n.length-1){const e=p["animation-timing-function"]&&p["animation-timing-function"].find(e=>e.key===n[t].key);T.push(e?e.value:o)}const e=n[t].transformOrigin;e&&R.asAnimateTransform(r)&&(void 0===r.transformOrigin&&(r.transformOrigin=[]),r.transformOrigin[t]=e)}if(0!==c[0]&&(c.unshift(0),S.unshift(r.baseValue||""),T.unshift(o),r.evaluateStart=!0),a(r,m,v),r.paused=d,r.duration=u,T.every(t=>"linear"===t))r.values=S,r.keyTimes=c;else{const t=[],s=[],a=[];for(let n=0;n<c.length;n++){if(n<c.length-1){const r=(c[n+1]-c[n])*u;if(P[T[n]])T[n]=P[T[n]];else if(T[n].startsWith("step")){if(""!==S[n]){const o=q.convertStepTimingFunction(i,T[n],c,S,n,Nt.getFontSize(e));if(o){const e=1===c[n+1]?1:0;for(let i=0;i<o[0].length-e;i++){let e=(c[n]+o[0][i]*r)/u;t.includes(e)&&(e+=.001),t.push(e),s.push(o[1][i]),a.push(P[-1!==T[n].indexOf("start")?"step-start":"step-end"])}continue}}T[n]=P.linear}else{const t=RegExp(Gt).exec(T[n]);T[n]=t?`${t[1]} ${t[2]} ${t[3]} ${t[4]}`:P.ease}a.push(T[n])}t.push(c[n]),s.push(S[n])}r.values=s,r.keyTimes=t,r.keySplines=a}r.iterationCount="infinite"!==g?parseFloat(g):-1,r.fillForwards="forwards"===y||"both"===y,r.fillBackwards="backwards"===y||"both"===y,r.reverse=h.endsWith("reverse"),r.alternate=(-1===r.iterationCount||r.iterationCount>1)&&h.startsWith("alternate"),s.push(r)}}}o.reverse();for(const t of s)t.setGroupOrdering(o)}for(const t of s)t.parent=this;return s}set name(t){this._name=t}get name(){return void 0===this._name&&(this._name=R.setName(this.element)),this._name}get transforms(){return void 0===this._transforms&&(this._transforms=this.getTransforms()),this._transforms}get animations(){return void 0===this._animations&&(this._animations=this.getAnimations()),this._animations}set visible(t){!function(t,e){$t(t,"display",e?"block":"none"),$t(t,"visibility",e?"visible":"hidden")}(this.element,t)}get visible(){return function(t){const e=f(t,"visibility");return"hidden"!==e&&"collapse"!==e&&"none"!==f(t,"display")}(this.element)}set opacity(t){!function(t,e){if(Pt.isNumber(e)){let s=parseFloat(""+e);s<=0?s=0:s>=1&&(s=1),t.style.setProperty("opacity",""+s),t.setAttribute("opacity",""+s)}}(this.element,t)}get opacity(){return f(this.element,"opacity")||"1"}});const zt=squared.lib.client;function Xt(t){const e=t.parentElement instanceof HTMLElement;return"svg"===t.tagName&&(!e&&zt.isUserAgent(4)||e&&zt.isUserAgent(8))}var Yt=t=>(class extends t{setRect(){const t=this.parent;let e=this.x,s=this.y,i=this.width,a=this.height;t&&(e=t.refitX(e),s=t.refitY(s),i=t.refitSize(i),a=t.refitSize(a)),this.setBaseValue("x",e),this.setBaseValue("y",s),this.setBaseValue("width",i),this.setBaseValue("height",a)}_getElement(){switch(this.element.tagName){case"svg":case"use":case"image":return this.element;default:return null}}set x(t){this._x=t}get x(){if(void 0!==this._x)return this._x;{const t=this._getElement();return t?t.x.baseVal.value:0}}set y(t){this._y=t}get y(){if(void 0!==this._y)return this._y;{const t=this._getElement();return t?t.y.baseVal.value:0}}set width(t){this._width=t}get width(){if(void 0!==this._width)return this._width;{const t=this._getElement();return t?Xt(t)?t.getBoundingClientRect().width:t.width.baseVal.value:0}}set height(t){this._height=t}get height(){if(void 0!==this._height)return this._height;{const t=this._getElement();return t?Xt(t)?t.getBoundingClientRect().height:t.height.baseVal.value:0}}});const Dt=squared.lib.util;function Wt(t,e){const s=d(p(t,"fill"));if(""!==s){if(e&&e.definitions.pattern.has(s))return e.definitions.pattern.get(s);{const t=document.getElementById(s.substring(1));if(t instanceof SVGPatternElement)return t}}}class Ut extends squared.lib.base.Container{constructor(t){super(),this.element=t,this.aspectRatio={x:0,y:0,width:0,height:0,position:{x:0,y:0},parent:{x:0,y:0},unit:1},this._clipRegion=[]}append(t,e){return t.parent=this,t.viewport=e||this.getViewport(),super.append(t)}build(t){let e,s,i=!0;t?(e=(t=Object.assign({},t)).symbolElement||t.patternElement||t.element||this.element,s=t.precision,!1===t.initPath&&(i=!1),t.symbolElement=void 0,t.patternElement=void 0,t.element=void 0):e=this.element,this.clear();const a=this.getViewport();let n=!1;for(let s=0;s<e.children.length;s++){const r=e.children[s];let o;if(c.svg(r))o=new squared.svg.Svg(r,!1),this.setAspectRatio(o,r.viewBox.baseVal),n=!0;else if(c.g(r))o=new squared.svg.SvgG(r),this.setAspectRatio(o);else if(c.use(r)){const t=m(r);if(t)if(c.symbol(t))o=new squared.svg.SvgUseSymbol(r,t),this.setAspectRatio(o,t.viewBox.baseVal),n=!0;else if(c.image(t))o=new squared.svg.SvgImage(r,t);else if(c.shape(t)){const e=Wt(r,a);e?(o=new squared.svg.SvgUsePattern(r,t,e),this.setAspectRatio(o)):o=new squared.svg.SvgUse(r,t,i)}}else if(c.image(r))o=new squared.svg.SvgImage(r);else if(c.shape(r)){const t=Wt(r,a);t?(o=new squared.svg.SvgShapePattern(r,t),this.setAspectRatio(o)):o=new squared.svg.SvgShape(r,i)}o&&(this.append(o,a),o.build(t))}if(R.asSvg(this)&&this.documentRoot)(this.aspectRatio.x<0||this.aspectRatio.y<0)&&this.clipViewBox(this.aspectRatio.x,this.aspectRatio.y,this.aspectRatio.width,this.aspectRatio.height,s,!0);else if(n&&this.hasViewBox()&&(0!==this.aspectRatio.x||0!==this.aspectRatio.y)){const t=R.parseBoxRect(this.getPathAll(!1)),e=this.refitX(this.aspectRatio.x),i=this.refitY(this.aspectRatio.y);(t.left<e||t.top<i)&&this.clipViewBox(t.left,t.top,this.refitSize(this.aspectRatio.width),this.refitSize(this.aspectRatio.height),s)}}hasViewBox(){return R.asSvg(this)&&!!this.element.viewBox.baseVal||R.asUseSymbol(this)&&!!this.symbolElement.viewBox.baseVal}clipViewBox(t,e,s,i,a,n=!1){n&&(s-=t,i-=e,t=t<0?-1*t:0,e=e<0?-1*e:0),this.clipRegion=R.drawRect(s,i,t,e,a)}synchronize(t){this.each(e=>e.synchronize(t))}refitX(t){return(t-this.aspectRatio.x)*this.aspectRatio.unit-this.aspectRatio.parent.x+this.aspectRatio.position.x}refitY(t){return(t-this.aspectRatio.y)*this.aspectRatio.unit-this.aspectRatio.parent.y+this.aspectRatio.position.y}refitSize(t){return t*this.aspectRatio.unit}refitPoints(t){for(const e of t)e.x=this.refitX(e.x),e.y=this.refitY(e.y),void 0!==e.rx&&void 0!==e.ry&&(e.rx*=this.aspectRatio.unit,e.ry*=this.aspectRatio.unit);return t}requireRefit(){return 0!==this.aspectRatio.x||0!==this.aspectRatio.y||0!==this.aspectRatio.position.x||0!==this.aspectRatio.position.y||0!==this.aspectRatio.parent.x||0!==this.aspectRatio.parent.y||1!==this.aspectRatio.unit}getPathAll(t=!0){const e=[];for(const s of t?this.cascade():this)R.isShape(s)&&s.path&&s.path.value&&e.push(s.path.value);return e}getViewport(){return this.viewport||R.asSvg(this)&&this||void 0}setAspectRatio(t,e){const s=function(t){for(;t;){if(t.hasViewBox())return t;t=t.parent}}(this);if(s){const i=t.aspectRatio;if(e&&(Dt.cloneObject(e,i),i.width>0&&i.height>0)){const t=i.width/i.height,e=s.aspectRatio.width||s.viewBox.width,a=s.aspectRatio.height||s.viewBox.height,n=e/a;n>t?i.position.x=(e-a*t)/2:n<t&&(i.position.y=(a-e*(1/t))/2),i.unit=Math.min(e/i.width,a/i.height)}i.parent.x=s.aspectRatio.x+s.aspectRatio.x*(s.aspectRatio.unit-1),i.position.x*=s.aspectRatio.unit,i.position.x+=s.aspectRatio.position.x-s.aspectRatio.parent.x,i.parent.y=s.aspectRatio.y+s.aspectRatio.y*(s.aspectRatio.unit-1),i.position.y*=s.aspectRatio.unit,i.position.y+=s.aspectRatio.position.y-s.aspectRatio.parent.y,i.unit*=s.aspectRatio.unit}}set clipRegion(t){""!==t?this._clipRegion.push(t):this._clipRegion.length=0}get clipRegion(){return this._clipRegion.length?this._clipRegion.join(";"):""}get instanceType(){return 2}}const Ht=squared.lib.color,jt=squared.lib.dom,Kt=squared.lib.util;function Zt(t){const e=[],s=t.getElementsByTagName("stop");for(let t=0;t<s.length;t++){const i=Ht.parseColor(jt.getNamedItem(s[t],"stop-color"),jt.getNamedItem(s[t],"stop-opacity"));i&&e.push({color:i,offset:parseFloat(jt.getNamedItem(s[t],"offset"))/100})}return e}function Qt(t,...e){const s={};for(const i of e)t[i]&&(s[i]=t[i].baseVal.value,s[`${i}AsString`]=t[i].baseVal.valueAsString);return s}class Jt{constructor(t){this.element=t}build(t){}synchronize(t){}get instanceType(){return 4}}const te=squared.lib.color,ee=squared.lib.css,se=squared.lib.regex,ie=squared.lib.util,ae={url:se.CSS.URL,polygon:/polygon\(([^)]+)\)/,inset:RegExp(`inset\\(${se.STRING.LENGTH_PERCENTAGE}\\s?${se.STRING.LENGTH_PERCENTAGE}?\\s?${se.STRING.LENGTH_PERCENTAGE}?\\s?${se.STRING.LENGTH_PERCENTAGE}?\\)`),circle:RegExp(`circle\\(${se.STRING.LENGTH_PERCENTAGE}(?: at ${se.STRING.LENGTH_PERCENTAGE} ${se.STRING.LENGTH_PERCENTAGE})?\\)`),ellipse:RegExp(`ellipse\\(${se.STRING.LENGTH_PERCENTAGE} ${se.STRING.LENGTH_PERCENTAGE}(?: at ${se.STRING.LENGTH_PERCENTAGE} ${se.STRING.LENGTH_PERCENTAGE})?\\)`)};var ne=t=>(class extends t{setPaint(t,e){this.resetPaint(),this.setAttribute("color"),this.setAttribute("fill"),this.setAttribute("fill-opacity"),this.setAttribute("fill-rule"),this.setAttribute("stroke"),this.setAttribute("stroke-opacity"),this.setAttribute("stroke-width"),this.setAttribute("stroke-linecap"),this.setAttribute("stroke-linejoin"),this.setAttribute("stroke-miterlimit"),this.setAttribute("stroke-dasharray"),this.setAttribute("stroke-dashoffset"),this.setAttribute("clip-rule");const s=this.getAttribute("clip-path",!0,!1);if(""!==s)for(const i in ae){const a=ae[i].exec(s);if(a){if("url"===i)return void(this.clipPath=a[1]);if(t&&t.length){const s=R.parseBoxRect(t),n=s.right-s.left,r=s.bottom-s.top,o=this.parent;switch(i){case"inset":{let t=0,i=0,l=this.convertLength(a[1],r),h=0;a[4]?(t=s.left+this.convertLength(a[4],n),i=s.right-this.convertLength(a[2],n),h=s.bottom-this.convertLength(a[3],r)):a[2]?(t=this.convertLength(a[2],n),i=s.right-t,h=s.bottom-(a[3]?this.convertLength(a[3],r):l),t+=s.left):(t=s.left+l,i=s.right-l,h=s.bottom-l);const c=[{x:t,y:l+=s.top},{x:i,y:l},{x:i,y:h},{x:t,y:h}];return o&&o.refitPoints(c),void(this.clipPath=R.drawPolygon(c,e))}case"polygon":{const t=ie.objectMap(a[1].split(se.XML.SEPARATOR),t=>{let[e,i]=ie.replaceMap(t.trim().split(" "),(t,e)=>this.convertLength(t,0===e?n:r));return{x:e+=s.left,y:i+=s.top}});return o&&o.refitPoints(t),void(this.clipPath=R.drawPolygon(t,e))}default:if("circle"===i||"ellipse"===i){const t=n<r?n:r;let l,h;"circle"===i?h=l=this.convertLength(a[1],t):(l=this.convertLength(a[1],n),h=this.convertLength(a[2],r));let c=s.left,u=s.top;a.length>=4&&(c+=this.convertLength(a[a.length-2],t),u+=this.convertLength(a[a.length-1],t)),o&&(c=o.refitX(c),u=o.refitX(u),l=o.refitSize(l),h=o.refitSize(h)),this.clipPath=R.drawEllipse(c,u,l,h,e)}return}}}}}setAttribute(t,e=!0){let s=this.getAttribute(t,e);if(ie.isString(s)){switch(t){case"stroke-dasharray":s="none"!==s?ie.joinMap(s.split(/,\s*/),t=>""+this.convertLength(t),", "):"";break;case"stroke-dashoffset":case"stroke-width":s=""+this.convertLength(s);break;case"fill":case"stroke":const e=d(s);if(""!==e)this[`${t}Pattern`]=e;else{let e;switch(s.toLowerCase()){case"none":case"transparent":case"rgba(0, 0, 0, 0)":this[t]="none";break;case"currentcolor":e=te.parseColor(this.color||f(this.element,t));break;default:e=te.parseColor(s)}e&&(this[t]=e.value)}return}this[ie.convertCamelCase(t)]=s}}getAttribute(t,e=!0,s=!0){let i=f(this.element,t,e);if(s&&!ie.isString(i)){if(this.patternParent)switch(t){case"fill-opacity":case"stroke-opacity":break;default:return i}let s=this.useParent||this.parent;for(;s&&(i=f(s.element,t,e),!ie.isString(i));)s=s.parent}return i}convertLength(t,e){return ee.isLength(t)?ee.parseUnit(t,ee.getFontSize(this.element)):ee.isPercent(t)?Math.round(("number"==typeof e?e:this.element.getBoundingClientRect()[e||"width"])*ie.convertFloat(t)/100):ie.convertFloat(t)}resetPaint(){this.fill="black",this.fillPattern="",this.fillOpacity="1",this.fillRule="nonzero",this.stroke="",this.strokeWidth="1",this.strokePattern="",this.strokeOpacity="1",this.strokeLinecap="butt",this.strokeLinejoin="miter",this.strokeMiterlimit="4",this.strokeDasharray="",this.strokeDashoffset="0",this.color="",this.clipPath="",this.clipRule=""}});const re=squared.lib.util;const oe=squared.lib.dom,le=squared.lib.math,he=squared.lib.util;function ce(t,e,s,i){const a=t[0],n=t[t.length-1];if(void 0!==s)switch(e){case"x":s-=a.start.x;break;case"x1":case"cx":return a.start.x=s,void(a.coordinates[0]=s);case"x2":return n.end.x=s,void(n.coordinates[0]=s)}if(void 0!==i)switch(e){case"y":i-=a.start.y;break;case"y1":case"cy":return a.start.y=i,void(a.coordinates[1]=i);case"y2":return n.end.y=i,void(n.coordinates[1]=i)}for(const e of t)for(let t=0,a=0;t<e.coordinates.length;t+=2,a++)void 0!==s&&(e.relative||(e.coordinates[t]+=s),e.value[a].x+=s),void 0!==i&&(e.relative||(e.coordinates[t+1]+=i),e.value[a].y+=i)}function ue(t,e,s){for(let i=0;i<t.length;i++){const a=t[i];if("A"===a.key.toUpperCase()){if(void 0!==e){const s=e-a.radiusX;a.radiusX=e,a.coordinates[0]=2*e*(a.coordinates[0]<0?-1:1),1===i&&(t[0].coordinates[0]-=s,t[0].end.x-=s)}void 0!==s&&(a.radiusY=s)}}}class fe extends(ne(V(Jt))){constructor(t){super(t),this.element=t,this.name="",this.value="",this.baseValue="",this.init()}static extrapolate(t,e,s,i,a,n){const r=!!i||!!a&&!!a.parent&&a.parent.requireRefit(),o=[];let l;for(let h=0;h<s.length;h++){if("d"===t)o[h]=s[h];else if("points"===t){const t=R.convertPoints(R.parseCoordinates(s[h]));t.length&&(o[h]=a&&c.polygon(a.element)?R.drawPolygon(t,n):R.drawPolyline(t,n))}else if(e){void 0===l&&(l=R.getPathCommands(e));const i=parseFloat(s[h]);if(!isNaN(i)){const e=h<s.length-1?he.cloneArray(l,[],!0):l;switch(t){case"x":case"x1":case"x2":case"cx":ce(e,t,i);break;case"y":case"y1":case"y2":case"cy":ce(e,t,void 0,i);break;case"r":ue(e,i,i);break;case"rx":ue(e,i);break;case"ry":ue(e,void 0,i);break;case"width":for(const t of[1,2]){const s=e[t];switch(s.key){case"m":case"l":case"h":s.coordinates[0]=i*(s.coordinates[0]<0?-1:1);break;case"M":case"L":case"H":s.coordinates[0]=e[0].end.x+i}}break;case"height":for(const t of[2,3]){const s=e[t];switch(s.key){case"m":case"l":case"v":s.coordinates[1]=i*(s.coordinates[1]<0?-1:1);break;case"M":case"L":case"V":s.coordinates[1]=e[0].end.y+i}}break;default:o[h]="";continue}o[h]=R.drawPath(e,n)}}o[h]?r&&(o[h]=R.transformRefit(o[h],i,a,n)):o[h]=""}return o}build(t){let e;t&&t.transforms&&(e=R.filterTransforms(t.transforms,t.exclude&&t.exclude[this.element.tagName])),this.draw(e,t)}draw(t,e){let s,i;e&&(s=e.residual,i=e.precision);const a=this.element,n=this.parent,r=this.patternParent,o=!!n&&n.requireRefit(),l=!!r&&2===r.patternContentUnits;let u;if(this.transformed=void 0,c.path(a)){if(u=this.getBaseValue("d"),t&&t.length||o||l){const e=R.getPathCommands(u);if(e.length){let c=R.extractPathPoints(e);c.length&&(l&&r.patternRefitPoints(c),t&&t.length&&("function"==typeof s&&([this.transformResidual,t]=s.call(this,a,t)),t.length&&(c=R.applyTransforms(t,c,h.origin(this.element)),this.transformed=t)),o&&n.refitPoints(c),u=R.drawPath(R.rebindPathPoints(e,c,void 0!==this.transformed),i))}}}else if(c.line(a)){let e=[{x:this.getBaseValue("x1"),y:this.getBaseValue("y1")},{x:this.getBaseValue("x2"),y:this.getBaseValue("y2")}];l&&r.patternRefitPoints(e),t&&t.length&&("function"==typeof s&&([this.transformResidual,t]=s.call(this,a,t)),t.length&&(e=R.applyTransforms(t,e,h.origin(this.element)),this.transformed=t)),o&&n.refitPoints(e),u=R.drawPolyline(e,i)}else if(c.circle(a)||c.ellipse(a)){let e,f;c.ellipse(a)?(e=this.getBaseValue("rx"),f=this.getBaseValue("ry")):f=e=this.getBaseValue("r");let p=[{x:this.getBaseValue("cx"),y:this.getBaseValue("cy"),rx:e,ry:f}];l&&r.patternRefitPoints(p),t&&t.length&&("function"==typeof s&&([this.transformResidual,t]=s.call(this,a,t,e,f)),t.length&&(p=R.applyTransforms(t,p,h.origin(this.element)),this.transformed=t)),o&&n.refitPoints(p);const d=p[0];u=R.drawEllipse(d.x,d.y,d.rx,d.ry,i)}else if(c.rect(a)){let e=this.getBaseValue("x"),c=this.getBaseValue("y"),f=this.getBaseValue("width"),p=this.getBaseValue("height");if(t&&t.length){let d=[{x:e,y:c},{x:e+f,y:c},{x:e+f,y:c+p},{x:e,y:c+p}];l&&r.patternRefitPoints(d),"function"==typeof s&&([this.transformResidual,t]=s.call(this,a,t)),t.length&&(d=R.applyTransforms(t,d,h.origin(this.element)),this.transformed=t),o&&n.refitPoints(d),u=R.drawPolygon(d,i)}else l&&(e=r.patternRefitX(e),c=r.patternRefitY(c),f=r.patternRefitX(f),p=r.patternRefitY(p)),o&&(e=n.refitX(e),c=n.refitY(c),f=n.refitSize(f),p=n.refitSize(p)),u=R.drawRect(f,p,e,c,i)}else if(c.polygon(a)||c.polyline(a)){let e=this.getBaseValue("points");l&&r.patternRefitPoints(e),t&&t.length&&("function"==typeof s&&([this.transformResidual,t]=s.call(this,a,t)),t.length&&(e=R.applyTransforms(t,e,h.origin(this.element)),this.transformed=t)),o&&(null===this.transformed&&(e=R.clonePoints(e)),n.refitPoints(e)),u=c.polygon(a)?R.drawPolygon(e,i):R.drawPolyline(e,i)}else u="";return this.value=u,this.setPaint([u],i),u}extendLength(t,e){if(""!==this.value)switch(this.element.tagName){case"path":case"line":case"polyline":const s=R.getPathCommands(this.value);if(s.length){const i=s[0],a=i.start,n=s[s.length-1],r=n.end,o=n.key.toUpperCase(),l=t.leading,h=t.trailing;let c=!1;if("Z"!==o&&(a.x!==r.x||a.y!==r.y)){if(l>0){let t;if(i.value.length>1?t=i.value[1]:s.length>1&&(t=s[1].start),t)if(t.x===a.x)i.coordinates[1]=i.coordinates[1]+(a.y>t.y?l:-l),c=!0;else if(t.y===a.y)i.coordinates[0]=i.coordinates[0]+(a.x>t.x?l:-l),c=!0;else{const e=le.offsetAngle(t,a);i.coordinates[0]=i.coordinates[0]-le.offsetAngleX(e,l),i.coordinates[1]=i.coordinates[1]-le.offsetAngleY(e,l),c=!0}}switch(o){case"M":case"L":if(h>0){let t;if(1===s.length?i.value.length>1&&(t=i.value[i.value.length-2]):t=n.value.length>1?n.value[n.value.length-2]:s[s.length-2].end,t)if(t.x===r.x)n.coordinates[1]=n.coordinates[1]+(r.y>t.y?h:-h),c=!0;else if(t.y===r.y)n.coordinates[0]=n.coordinates[0]+(r.x>t.x?h:-h),c=!0;else{const e=le.offsetAngle(t,r),s=n.coordinates[0]+le.offsetAngleX(e,h),i=n.coordinates[1]+le.offsetAngleY(e,h);n.coordinates[0]=s,n.coordinates[1]=i,c=!0}}break;case"H":case"V":{const t="H"===o?0:1;n.coordinates[t]=n.coordinates[t]+(l+h)*(n.coordinates[t]>=0?1:-1),c=!0;break}}}if(c)return t.leading=l,t.trailing=h,t.path=R.drawPath(s,e),t}}}flattenStrokeDash(t,e,s,i,a){let n,r,o,l;i||(i=s);let h=0;const c=t=>r[t%n];if(void 0===a){n=t.length,r=t.slice(0);const u=le.nextMultiple([2,n]);o=0;for(let e=0;e<u;e++){const s=t[e%n];o+=s,e>=n&&r.push(s)}if(n=u,e>0){let t=c(0);for(;e-t>=0;)e-=t,t=c(++h);h%=n}else if(e<0){for(r.reverse();e<0;)e+=c(h++);h=n-h%n,r.reverse()}a={dashArray:r,dashArrayTotal:o,items:[],leading:0,trailing:0,startIndex:h,extendedLength:l=i,lengthRatio:s/(i||s)}}else({dashArray:r,dashArrayTotal:o,extendedLength:l,startIndex:h}=a),n=r.length,a.items=[],a.leading=0;let u,f=0;for(let t=0,s=0;;t+=s,h++){let i,n;s=c(h),t<e?(a.leading=e-t,i=0,n=s-a.leading):(i=t-e,n=s);const r=le.truncateFraction(i/l);if(u=le.truncateFraction(r+n/l),h%2==0?r<1&&(a.items.push({start:r,end:Math.min(u,1),length:s}),f+=s):f+=s,u>=1)break}for(a.trailing=le.truncateFraction((u-1)*l);f%o!=0;){const t=c(++h);a.trailing+=t,f+=t}return 0===a.items.length?a.items.push({start:1,end:1}):(a.leadingOffset=le.truncateFraction(a.items[0].start*l),a.leading*=a.lengthRatio,a.trailing*=a.lengthRatio),a}extractStrokeDash(t,e,s=0){const i=he.convertInt(this.strokeWidth);let a,n="",r="";if(i>0){let d=R.parseCoordinates(this.strokeDasharray);if(d.length){const m=this.totalLength,g=this.pathLength||m,v=[];let b,S=he.convertInt(this.strokeDashoffset),T=0;const k=(t,e,s,i=0)=>{const a=this.flattenStrokeDash(t,e,m,g);return 0===v.length&&(b=a),T=Math.max(T,a.items.length),v.push({items:a.items,delay:s,duration:i}),a.items};if(a=k(d,S,0),t){const x=t.slice(0).sort((t,e)=>{if(t.attributeName.startsWith("stroke-dash")&&e.attributeName.startsWith("stroke-dash")){if(t.delay!==e.delay)return t.delay<e.delay?-1:1;if(R.asSet(t)&&R.asAnimate(e)||void 0===t.animationElement&&e.animationElement)return-1;if(R.asAnimate(t)&&R.asSet(e)||t.animationElement&&void 0===e.animationElement)return 1}return 0}),A=new W(x,"stroke-dasharray","stroke-dashoffset");if(x.length>1)for(let t=0;t<x.length;t++)A.has(x[t].attributeName,x[t].delay,x[t])||x.splice(t--,1);function o(t,e=!1){const s=A.get("stroke-dashoffset",t,e);return s?parseFloat(s):S}function l(t,e=!1){const s=A.get("stroke-dasharray",t,e);return s?R.parseCoordinates(s):d}const w=t=>t?`${t.start} ${t.end}`:"1 1";let V=t=>{let e=S;for(let s=t;s<x.length;s++){const t=x[s];if("stroke-dasharray"===t.attributeName){const s=A.get("stroke-dashoffset",t.delay);s&&(e=parseFloat(s));for(const s of R.asAnimate(t)?A.evaluateStart(t):[t.to])T=Math.max(T,this.flattenStrokeDash(R.parseCoordinates(s),e,m,g).items.length)}}};const _=[];let E=!1;for(let t=0;t<x.length;t++){const N=x[t];if(N.setterType){function h(t,e){k(t,e,N.delay,N.fillReplace&&N.duration>0?N.duration:0),E=!0}switch(N.attributeName){case"stroke-dasharray":h(d=R.parseCoordinates(N.to),o(N.delay));continue;case"stroke-dashoffset":S=he.convertInt(N.to),h(l(N.delay),S);continue}}else if(R.asAnimate(N)&&N.playable)switch(A.evaluateStart(N),N.attributeName){case"stroke-dasharray":{V&&(V(t),V=void 0);const e=o(N.delay),s=this.flattenStrokeDash(l(N.delay),e,m,g).items,i=[],a=[];for(let t=0;t<T;t++){const e=new q(this.element);e.id=t,e.baseValue=w(s[t]),e.attributeName="stroke-dasharray",e.delay=N.delay,e.duration=N.duration,e.iterationCount=N.iterationCount,e.fillMode=N.fillMode,a[t]=[],i.push(e)}for(const t of N.values){const s=this.flattenStrokeDash(R.parseCoordinates(t),e,m,g).items;for(let t=0;t<T;t++)a[t].push(w(s[t]))}const n=N.keyTimes,r=N.keySplines,h=N.timingFunction;for(let t=0;t<T;t++)i[t].values=a[t],i[t].keyTimes=n,r?i[t].keySplines=r:h&&(i[t].timingFunction=h);if(N.fillReplace){const t=N.getTotalDuration(),e=this.flattenStrokeDash(l(t),o(t),m,g).items;for(let t=0;t<T;t++)i[t].replaceValue=w(e[t])}he.concatArray(_,i),E=!0;continue}case"stroke-dashoffset":{const t=N.duration,o=s/1e3,l=parseFloat(N.values[0]),h=[],d=[],k=[];let x=0,w=0;S===l||0!==N.delay||N.fillReplace||(b=this.flattenStrokeDash(b.dashArray,l,m,g),v[0].items=a=b.items,T=Math.max(T,b.items.length),S=l);let V,_=m,M=1;if((b.leading>0||b.trailing>0)&&(this.extendLength(b,e),b.path)){const t=R.parseBoxRect([this.value]);M=(_=le.truncateFraction(y(b.path)))/m,b.extendedLength=this.pathLength,b.extendedLength>0?b.extendedLength*=M:b.extendedLength=_;const e=this.flattenStrokeDash(b.dashArray,0,m,g,b);v[0].items=a=e.items,T=Math.max(T,a.length);const s=Math.ceil(i/2);n=b.path,r=R.drawRect(t.right-t.left,t.bottom-t.top+2*s,t.left,t.top-s)}if(N.fillReplace&&-1!==N.iterationCount){const t=he.convertFloat(A.get(N.attributeName,N.getTotalDuration()));if(t!==S){let e=Math.abs(t-S)%_/_;t>S&&(e=1-e),V=""+e}}for(let e=0;e<N.keyTimes.length;e++){const s=0===e?S:parseFloat(N.values[e-1]),i=parseFloat(N.values[e]),a=Math.abs(i-s),n=N.keyTimes[e];if(0===a){e>0&&(d.push(x=n),h.length?(h.push(h[h.length-1]),w=parseFloat(h[h.length-1])):(h.push("0"),w=0));continue}const r=i>s,l=e>0?(n-N.keyTimes[e-1])*t:0,m=a*b.lengthRatio;let g=m/_;function c(e){return e/m*l/t}function u(t,e=!1){if(v=(y-t)/_,e){const t=le.truncateFraction(v);r?t>0&&(v=1-v):0===t&&(v=1)}}function f(){e>0&&(r?"1"===h[h.length-1]:"0"===h[h.length-1])||(k[d.length]=!0,d.push(0===x?0:le.truncateFraction(x+o)),h.push(r?"1":"0"))}function p(){d.push(x=n);const t=le.truncateFraction(v);h.push(""+t),w=t>0&&t<1?v:0}let y=m,v=0;if(0===e)y%=_,u(0),r&&(v=1-v),p();else{if(w>0){const t=r?w:1-w,e=le.truncateFraction(t*_);if(le.lessEqual(y,e)){u(0),r?v=w-v:v+=w,p();continue}h.push(r?"0":"1"),x+=c(e),d.push(le.truncateFraction(x)),g=le.truncateFraction(g-t),y=le.truncateFraction(y-e)}if(le.isEqual(y,_)&&(y=_),y>_){const t=(g=Math.floor(g))*_;t===y&&g--,u(t,!0)}else g=0,u(0,!0);for(;g>0;)f(),h.push(r?"0":"1"),x+=c(_),d.push(le.truncateFraction(x)),g--;f(),p()}}N.baseValue="0",N.replaceValue=V,N.values=h,N.keyTimes=d,N.loopIntervals=k;const F=N.timingFunction;F&&(N.keySplines=void 0,N.timingFunction=F),E=!0;break}}_.push(N)}if(E){for(let t=0;t<v.length;t++){const e=v[t].items;if(e===a)for(let t=e.length;t<T;t++)e.push({start:1,end:1});else{const s=v[t].delay,i=v[t].duration,n=v.length>2?this.flattenStrokeDash(l(s-1),o(s-1),m,g).items:a;for(let t=0;t<T;t++){const a=new F(this.element);a.id=t,a.attributeName="stroke-dasharray",a.baseValue=w(n[t]),a.delay=s,a.to=w(e[t]),a.duration=i,a.fillFreeze=0===i,_.push(a)}}}t.length=0,he.concatArray(t,_)}}}}return[a,n,r]}init(){const t=this.element;c.path(t)?this.setBaseValue("d"):c.line(t)?(this.setBaseValue("x1"),this.setBaseValue("y1"),this.setBaseValue("x2"),this.setBaseValue("y2")):c.rect(t)?(this.setBaseValue("x"),this.setBaseValue("y"),this.setBaseValue("width"),this.setBaseValue("height")):c.circle(t)?(this.setBaseValue("cx"),this.setBaseValue("cy"),this.setBaseValue("r")):c.ellipse(t)?(this.setBaseValue("cx"),this.setBaseValue("cy"),this.setBaseValue("rx"),this.setBaseValue("ry")):(c.polygon(t)||c.polyline(t))&&this.setBaseValue("points",R.clonePoints(t.points))}get transforms(){return void 0===this._transforms&&(this._transforms=R.filterTransforms(h.parse(this.element)||R.convertTransforms(this.element.transform.baseVal))),this._transforms}get pathLength(){return he.convertFloat(oe.getNamedItem(this.element,"pathLength"))}get totalLength(){return this.element.getTotalLength()}get instanceType(){return 1028}}class pe extends(qt(Ut)){constructor(t,e){super(t),this.element=t,this.patternElement=e}build(t){(t=Object.assign({},t)).patternElement=this.patternElement,t.initPath=!1,super.build(t)}get animations(){return[]}get instanceType(){return 130}}class de extends(wt(qt(Jt))){constructor(t,e=!0){super(t),this.element=t,e&&this.setPath()}setPath(){this.path=new fe(this.element)}build(t){this.path&&(this.path.parent=this.parent,(t=Object.assign({},t)).transforms=this.transforms,this.path.build(t))}synchronize(t){if(this.path&&this.animations.length){const e=t&&t.element;this.animateSequentially(this.getAnimateShape(e||this.element),e?void 0:this.getAnimateTransform(),this.path,t)}}set path(t){this._path=t,t&&(t.name=this.name)}get path(){return this._path}get instanceType(){return 2052}}const me=squared.lib.css,ge=squared.lib.dom,ye=squared.lib.util,ve=t=>me.isPercent(t)?parseFloat(t)/100:parseFloat(t);class be extends(ne(V(qt(Ut)))){constructor(t,e){super(t),this.element=t,this.patternElement=e,this.__get_transforms=!1,this.patternUnits="userSpaceOnUse"===ge.getNamedItem(this.patternElement,"patternUnits")?1:2,this.patternContentUnits="objectBoundingBox"===ge.getNamedItem(this.patternElement,"patternContentUnits")?2:1}build(t){const e=t&&t.element||this.element,s=new fe(e);if(s.build(t),s.value){const i=(t=Object.assign({},t))&&t.precision;this.clipRegion=s.value,s.clipPath&&(this.clipRegion=s.clipPath);const a=[s.value];this.setPaint(a,i),this.drawRegion=R.parseBoxRect(a);const n=2===this.patternUnits,r=this.patternWidth,o=this.patternHeight,l=this.tileWidth,h=this.tileHeight,c=n?this.drawRegion.left:0,u=n?this.drawRegion.top:0;let f=this.offsetX%l,p=this.offsetY%h,d=this.drawRegion.right-(n?this.drawRegion.left:0),m=this.drawRegion.bottom-(n?this.drawRegion.top:0),g=0;for(0!==f&&(f=l-f,d+=l),0!==p&&(p=h-p,m+=h);m>0;){const s=u+g*h-p;let a=d,n=0;do{const u=c+n*l-f,p=new pe(e,this.patternElement);p.build(t);for(const e of p.cascade())R.isShape(e)&&(e.setPath(),e.path&&(e.path.patternParent=this,2===this.patternContentUnits?e.path.refitBaseValue(u/r,s/o,i):e.path.refitBaseValue(u,s,i),t.transforms=e.transforms,e.path.build(t),e.path.fillOpacity=""+parseFloat(e.path.fillOpacity)*parseFloat(this.fillOpacity),e.path.clipPath=R.drawRect(l,h,u,s,i)+(""!==e.path.clipPath?`;${e.path.clipPath}`:"")));this.append(p),a-=l,n++}while(a>0);g++,m-=h}if(""!==this.stroke&&parseFloat(this.strokeWidth)>0){s.fill="",s.fillOpacity="0",s.stroke=this.stroke,s.strokeWidth=this.strokeWidth;const t=new de(e,!1);t.path=s,this.append(t)}}}patternRefitX(t){return this.drawRegion?t*this.patternWidth:t}patternRefitY(t){return this.drawRegion?t*this.patternHeight:t}patternRefitPoints(t){if(this.drawRegion){const e=this.patternWidth,s=this.patternHeight;for(const i of t)if(i.x*=e,i.y*=s,void 0!==i.rx&&void 0!==i.ry)if(i.rx===i.ry){const t=Math.min(e,s);i.rx*=t,i.ry*=t}else i.rx*=e,i.ry*=s}return t}get patternWidth(){return this.drawRegion?this.drawRegion.right-this.drawRegion.left:0}get patternHeight(){return this.drawRegion?this.drawRegion.bottom-this.drawRegion.top:0}get transforms(){if(!this.__get_transforms){const t=R.convertTransforms(this.patternElement.patternTransform.baseVal);if(t.length){const e=h.rotateOrigin(this.patternElement,"patternTransform"),s=this.patternWidth/2,i=this.patternHeight/2;for(const a of t)switch(a.type){case SVGTransform.SVG_TRANSFORM_TRANSLATE:break;case SVGTransform.SVG_TRANSFORM_ROTATE:for(;e.length;){const t=e.shift();if(t.angle===a.angle){a.origin={x:s+t.x,y:i+t.y};break}}if(a.origin)break;default:a.origin={x:s,y:i}}ye.concatArray(super.transforms,R.filterTransforms(t))}this.__get_transforms=!0}return super.transforms}get offsetX(){let t=0;return 2===this.patternUnits&&(t=this.patternWidth*ve(this.patternElement.x.baseVal.valueAsString)),t||this.patternElement.x.baseVal.value}get offsetY(){let t=0;return 2===this.patternUnits&&(t=this.patternHeight*ve(this.patternElement.y.baseVal.valueAsString)),t||this.patternElement.y.baseVal.value}get tileWidth(){let t=0;return 2===this.patternUnits&&(t=this.patternWidth*ve(this.patternElement.width.baseVal.valueAsString)),t||this.patternElement.width.baseVal.value}get tileHeight(){let t=0;return 2===this.patternUnits&&(t=this.patternHeight*ve(this.patternElement.height.baseVal.valueAsString)),t||this.patternElement.height.baseVal.value}get instanceType(){return 258}}const Se=squared.lib.util;const Te=squared.lib.util;const ke={constant:G,util:v};t.Svg=class extends(wt(Yt(V(qt(Ut))))){constructor(t,e=!0){super(t),this.element=t,this.documentRoot=e,this.definitions={clipPath:new Map,pattern:new Map,gradient:new Map},this.init()}build(t){this.precision=t&&t.precision,this.setRect(),super.build(t)}synchronize(t){!this.documentRoot&&this.animations.length&&this.animateSequentially(this.getAnimateViewRect(),this.getAnimateTransform(),void 0,t),super.synchronize(t)}init(){this.documentRoot&&(Kt.cloneObject(this.element.viewBox.baseVal,this.aspectRatio),this.element.querySelectorAll("set, animate, animateTransform, animateMotion").forEach(t=>{const e=m(t,this.element);e&&(t.parentElement&&t.parentElement.removeChild(t),e.appendChild(t))})),this.setDefinitions(this.element),this.element.querySelectorAll("defs").forEach(t=>this.setDefinitions(t))}setDefinitions(t){t.querySelectorAll("clipPath, pattern, linearGradient, radialGradient").forEach(t=>{if(t.id){const e=`#${t.id}`;c.clipPath(t)?this.definitions.clipPath.set(e,t):c.pattern(t)?this.definitions.pattern.set(e,t):c.linearGradient(t)?this.definitions.gradient.set(e,Object.assign({type:"linear",element:t,spreadMethod:t.spreadMethod.baseVal,colorStops:Zt(t)},Qt(t,"x1","x2","y1","y2"))):c.radialGradient(t)&&this.definitions.gradient.set(e,Object.assign({type:"radial",element:t,spreadMethod:t.spreadMethod.baseVal,colorStops:Zt(t)},Qt(t,"cx","cy","r","fx","fy","fr")))}})}get viewBox(){return this.element.viewBox.baseVal||u(this.element)}get instanceType(){return 18}},t.SvgAnimate=q,t.SvgAnimateMotion=Et,t.SvgAnimateTransform=Y,t.SvgAnimation=F,t.SvgAnimationIntervalMap=W,t.SvgBaseVal=V,t.SvgBuild=R,t.SvgContainer=Ut,t.SvgElement=Jt,t.SvgG=class extends(ne(qt(Ut))){constructor(t){super(t),this.element=t}build(t){super.build(t),this.setPaint(this.getPathAll(),t&&t.precision)}get instanceType(){return 34}},t.SvgImage=class extends(Yt(V(qt(Jt)))){constructor(t,e){super(t),this.element=t,this.imageElement=null,this.__get_transforms=!1,this.__get_animations=!1,e&&(this.imageElement=e)}build(){this.setRect()}extract(t){const e=t?R.filterTransforms(this.transforms,t):this.transforms;let{x:s,y:i,width:a,height:n}=this;if(e.length){e.reverse();for(let t=0;t<e.length;t++){const r=e[t],o=r.matrix,h=s;switch(s=l.applyX(o,h,i),i=l.applyY(o,h,i),r.type){case SVGTransform.SVG_TRANSFORM_SCALE:a*=o.a,n*=o.d;break;case SVGTransform.SVG_TRANSFORM_ROTATE:0!==r.angle&&(o.a<0&&(s+=o.a*a),o.c<0&&(s+=o.c*a),o.b<0&&(i+=o.b*n),o.d<0&&(i+=o.d*n),this.rotateAngle?this.rotateAngle+=r.angle:this.rotateAngle=r.angle)}}this.transformed=e}this.parent&&(s=this.parent.refitX(s),i=this.parent.refitY(i),a=this.parent.refitSize(a),n=this.parent.refitSize(n)),this.translationOffset&&(s+=this.translationOffset.x,i+=this.translationOffset.y),this.setBaseValue("x",s),this.setBaseValue("y",i),this.setBaseValue("width",a),this.setBaseValue("height",n)}set x(t){super.x=t}get x(){const t=super.x;return 0===t&&this.imageElement?this.imageElement.x.baseVal.value:t}set y(t){super.y=t}get y(){const t=super.y;return 0===t&&this.imageElement?this.imageElement.y.baseVal.value:t}set width(t){super.width=t}get width(){const t=super.width;return 0===t&&this.imageElement?this.imageElement.width.baseVal.value:t}set height(t){super.height=t}get height(){const t=super.height;return 0===t&&this.imageElement?this.imageElement.height.baseVal.value:t}get href(){const t=this.imageElement||this.element;return c.image(t)?re.resolvePath(t.href.baseVal):""}get transforms(){const t=super.transforms;return this.__get_transforms||(this.imageElement&&re.concatArray(t,this.getTransforms(this.imageElement)),this.__get_transforms=!0),t}get animations(){const t=super.animations;return this.__get_animations||(this.imageElement&&re.concatArray(t,this.getAnimations(this.imageElement)),this.__get_animations=!0),t}get instanceType(){return 4100}},t.SvgPaint=ne,t.SvgPath=fe,t.SvgPattern=pe,t.SvgShape=de,t.SvgShapePattern=be,t.SvgSynchronize=wt,t.SvgUse=class extends(ne(Yt(V(de)))){constructor(t,e,s=!0){super(t,!1),this.element=t,this.shapeElement=e,this.__get_transforms=!1,this.__get_animations=!1,s&&this.setPath()}setPath(){this.path=new fe(this.shapeElement),this.path.useParent=this}build(t){super.build(t),this.setPaint(this.path?[this.path.value]:void 0,t&&t.precision)}synchronize(t){(t=Object.assign({},t)).element=this.shapeElement,this.animations.length&&this.animateSequentially(this.getAnimateViewRect(),this.getAnimateTransform(),void 0,t),super.synchronize(t)}get transforms(){const t=super.transforms;return this.__get_transforms||(Se.concatArray(t,this.getTransforms(this.shapeElement)),this.__get_transforms=!0),t}get animations(){const t=super.animations;return this.__get_animations||(Se.concatArray(t,this.getAnimations(this.shapeElement)),this.__get_animations=!0),t}get instanceType(){return 10244}},t.SvgUsePattern=class extends(wt(Yt(be))){constructor(t,e,s){super(t,s),this.element=t,this.shapeElement=e}build(t){(t=Object.assign({},t)).element=this.shapeElement,super.build(t)}synchronize(t){const e=Te.filterArray(this.animations,t=>void 0===this.verifyBaseValue(t.attributeName,0)||"x"===t.attributeName||"y"===t.attributeName),s=this.getAnimateTransform();(e.length||s.length)&&this.animateSequentially(this.getAnimateViewRect(e),s,void 0,t),super.synchronize(t)}get instanceType(){return 514}},t.SvgUseSymbol=class extends(ne(wt(Yt(V(qt(Ut)))))){constructor(t,e){super(t),this.element=t,this.symbolElement=e}build(t){(t=Object.assign({},t)).symbolElement=this.symbolElement,this.setRect(),super.build(t);const e=this.getBaseValue("x",0),s=this.getBaseValue("y",0);if(0!==e||0!==s){const t={x:e,y:s};for(const e of this.cascade())e.translationOffset=t}this.setPaint(this.getPathAll(),t&&t.precision)}synchronize(t){this.animations.length&&this.animateSequentially(this.getAnimateViewRect(),this.getAnimateTransform(),void 0,t),super.synchronize(t)}get viewBox(){return this.symbolElement.viewBox.baseVal||u(this.element)}get instanceType(){return 66}},t.SvgView=qt,t.SvgViewRect=Yt,t.lib=ke,Object.defineProperty(t,"__esModule",{value:!0})});
