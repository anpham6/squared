import { AutoMargin, InitialData, SiblingOptions, VisibleStyle } from '../base/@types/node';

import Container = squared.lib.base.Container;

declare global {
    namespace squared.base {
        interface Node extends Container<Node>, BoxModel {
            id: number;
            localSettings: {};
            style: CSSStyleDeclaration;
            alignmentType: number;
            depth: number;
            siblingIndex: number;
            documentRoot: boolean;
            lineBreakLeading: boolean;
            lineBreakTrailing: boolean;
            siblingsLeading: Node[];
            siblingsTrailing: Node[];
            floatContainer: boolean;
            tagName: string;
            baseline: boolean;
            textContent: string;
            multiline: boolean;
            positionAuto: boolean;
            visible: boolean;
            rendered: boolean;
            excluded: boolean;
            overflow: number;
            contentBoxWidth: number;
            contentBoxHeight: number;
            flexbox: Flexbox;
            dir: string;
            documentParent: Node;
            actualChildren: Node[];
            parent?: Node;
            renderParent?: Node;
            outerWrapper?: Node;
            innerWrapped?: Node;
            innerBefore?: Node;
            innerAfter?: Node;
            readonly sessionId: string;
            readonly initial: InitialData<Node>;
            readonly box: BoxRectDimension;
            readonly bounds: BoxRectDimension;
            readonly linear: BoxRectDimension;
            readonly element: Element | null;
            readonly elementId: string;
            readonly htmlElement: boolean;
            readonly styleElement: boolean;
            readonly naturalElement: boolean;
            readonly imageElement: boolean;
            readonly svgElement: boolean;
            readonly flexElement: boolean;
            readonly gridElement: boolean;
            readonly textElement: boolean;
            readonly tableElement: boolean;
            readonly inputElement: boolean;
            readonly layoutElement: boolean;
            readonly pseudoElement: boolean;
            readonly documentBody: boolean;
            readonly dataset: DOMStringMap;
            readonly extensions: string[];
            readonly centerAligned: boolean;
            readonly rightAligned: boolean;
            readonly bottomAligned: boolean;
            readonly horizontalAligned: boolean;
            readonly width: number;
            readonly height: number;
            readonly hasWidth: boolean;
            readonly hasHeight: boolean;
            readonly lineHeight: number;
            readonly display: string;
            readonly positionRelative: boolean;
            readonly top: number;
            readonly right: number;
            readonly bottom: number;
            readonly left: number;
            readonly marginTop: number;
            readonly marginRight: number;
            readonly marginBottom: number;
            readonly marginLeft: number;
            readonly borderTopWidth: number;
            readonly borderRightWidth: number;
            readonly borderBottomWidth: number;
            readonly borderLeftWidth: number;
            readonly paddingTop: number;
            readonly paddingRight: number;
            readonly paddingBottom: number;
            readonly paddingLeft: number;
            readonly inlineFlow: boolean;
            readonly inline: boolean;
            readonly inlineStatic: boolean;
            readonly inlineVertical: boolean;
            readonly plainText: boolean;
            readonly inlineText: boolean;
            readonly lineBreak: boolean;
            readonly positionStatic: boolean;
            readonly block: boolean;
            readonly blockStatic: boolean;
            readonly blockDimension: boolean;
            readonly blockVertical: boolean;
            readonly contentBox: boolean;
            readonly autoMargin: AutoMargin;
            readonly pageFlow: boolean;
            readonly floating: boolean;
            readonly float: string;
            readonly zIndex: number;
            readonly positiveAxis: boolean;
            readonly leftTopAxis: boolean;
            readonly backgroundImage: string;
            readonly visibleStyle: VisibleStyle;
            readonly fontSize: number;
            readonly percentWidth: boolean;
            readonly percentHeight: boolean;
            readonly src: string;
            readonly overflowX: boolean;
            readonly overflowY: boolean;
            readonly verticalAlign: string;
            readonly textEmpty: boolean;
            readonly preserveWhiteSpace: boolean;
            readonly absoluteParent: Node | null;
            readonly actualParent: Node | null;
            readonly actualWidth: number;
            readonly actualHeight: number;
            readonly actualDimension: Dimension;
            readonly firstChild: Node | null;
            readonly lastChild: Node | null;
            readonly previousSibling: Node | null;
            readonly nextSibling: Node | null;
            readonly singleChild: boolean;
            readonly center: Point;
            init(): void;
            saveAsInitial(overwrite?: boolean): void;
            addAlign(value: number): void;
            removeAlign(value: number): void;
            hasAlign(value: number): boolean;
            unsafe(name: string, unset?: boolean): any;
            data(name: string, attr: string, value?: any, overwrite?: boolean): any;
            unsetCache(...attrs: string[]): void;
            ascend(generated?: boolean, condition?: (item: Node) => boolean, parent?: Node): Node[];
            alignedVertically(siblings?: Node[], cleared?: Map<Node, string>, horizontal?: boolean): number;
            inherit(node: Node, ...modules: string[]): void;
            intersectX(rect: BoxRectDimension, dimension?: string): boolean;
            intersectY(rect: BoxRectDimension, dimension?: string): boolean;
            withinX(rect: BoxRectDimension, dimension?: string): boolean;
            withinY(rect: BoxRectDimension, dimension?: string): boolean;
            outsideX(rect: BoxRectDimension, dimension?: string): boolean;
            outsideY(rect: BoxRectDimension, dimension?: string): boolean;
            css(attr: string, value?: string, cache?: boolean): string;
            cssSet(attr: string, value: string, cache?: boolean): this;
            cssApply(values: StringMap, cache?: boolean): this;
            cssInitial(attr: string, modified?: boolean, computed?: boolean): string;
            cssAny(attr: string, ...values: string[]): boolean;
            cssInitialAny(attr: string, ...values: string[]): boolean;
            cssAscend(attr: string, startChild?: boolean, dimension?: string): string;
            cssSort(attr: string, ascending?: boolean, duplicate?: boolean): Node[];
            cssPX(attr: string, value: number, negative?: boolean, cache?: boolean): string;
            cssSpecificity(attr: string): number;
            cssTry(attr: string, value: string): boolean;
            cssFinally(attr: string): boolean;
            toInt(attr: string, initial?: boolean, fallback?: number): number;
            toFloat(attr: string, initial?: boolean, fallback?: number): number;
            parseUnit(value: string, dimension?: string, parent?: boolean): number;
            convertPX(value: string, dimension?: string, parent?: boolean): string;
            has(attr: string, checkType?: number, options?: {}): boolean;
            setBounds(cache?: boolean): void;
            setInlineText(value: boolean, overwrite?: boolean): void;
            previousSiblings(options?: SiblingOptions): Node[];
            nextSiblings(options?: SiblingOptions): Node[];
            getFirstChildElement(options?: SiblingOptions): Element | null;
            getLastChildElement(options?: SiblingOptions): Element | null;
        }

        class Node implements Node {
            constructor(id: number, sessionId?: string, element?: Element);
        }
    }
}

export = squared.base.Node;